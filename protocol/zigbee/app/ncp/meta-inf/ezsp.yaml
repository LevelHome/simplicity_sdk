#################################################################################
- {
  section: Common,

  ncpCpps: ~,

  typedefs: [
    {
      name: "sl_802154_short_addr_t",
      description: "16-bit ZigBee network address.",
      definition: "uint16_t"
    },
    {
      name: "sl_status_t",
      description: "See sl_status.h for an enumerated list.",
      definition: "uint32_t"
    },
    {
      name: "sl_zigbee_gp_status_t",
      description: "See enumeration in gp-types.h",
      definition: "uint8_t"
    },
    {
      name: "sl_802154_pan_id_t",
      description: "802.15.4 PAN ID.",
      definition: "uint16_t"
    },
    {
      name: "sl_zigbee_multicast_id_t",
      description: "16-bit ZigBee multicast group identifier.",
      definition: "uint16_t"
    },
    {
      name: "sl_802154_long_addr_t",
      description: "EUI 64-bit ID (an IEEE address).",
      definition: "uint8_t[8]"
    },
    {
      name: "sl_zigbee_mac_interface_id_t",
      description: "The 8-bit identifier to uniquely identify the interface.",
      definition: "uint8_t"
    },
    {
      name: "sl_zigbee_manufacturing_string_t",
      description: "A 16-byte array for the manufacturing string.",
      definition: "uint8_t[16]"
    },
    {
      name: "sl_zigbee_network_parameters_t",
      description: "Network parameters.",
      definition: [
        {
          type: "uint8_t[8]",
          name: "extendedPanId",
          description: "The network's extended PAN identifier.",
        },
        {
          type: "uint16_t",
          name: "panId",
          description: "The network's PAN identifier.",
        },
        {
          type: "int8_t",
          name: "radioTxPower",
          description: "A power setting, in dBm.",
        },
        {
          type: "uint8_t",
          name: "radioChannel",
          description: "A radio channel.",
        },
        {
          type: "sl_zigbee_join_method_t",
          name: "joinMethod",
          description: "The method used to initially join the network.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "nwkManagerId",
          description: "NWK Manager ID. The ID of the network manager
                        in the current network. This may only be set
                        at joining when using SL_ZIGBEE_USE_CONFIGURED_NWK_STATE
                        as the join method.",
        },
        {
          type: "uint8_t",
          name: "nwkUpdateId",
          description: "NWK Update ID. The value of the ZigBee
                        nwkUpdateId known by the stack. This is used to
                        determine the newest instance of the network
                        after a PAN ID or channel change. This may
                        only be set at joining when using
                        SL_ZIGBEE_USE_CONFIGURED_NWK_STATE as the join method.",
        },
        {
          type: "uint32_t",
          name: "channels",
          description: "NWK channel mask. The list of preferred
                        channels that the NWK manager has told this
                        device to use when searching for the network.
                        This may only be set at joining when using
                        SL_ZIGBEE_USE_CONFIGURED_NWK_STATE as the join method.",
        },
      ]
    },
    {
      name: "sl_zigbee_alt_mac_config_t",
      description: "Defines alternate MAC configuration parameters.",
      definition: [
        {
          type: "uint16_t",
          name: "scanDuration",
          description: "Scan duration over alternate MAC.",
        },
        {
          type: "MacTransmitCallback",
          name: "macTransmit",
          description: "To register the transmit callback.
                        Called when there is packet to transmit.",
        },
      ]
    },
    {
      name: "sl_zigbee_multi_phy_radio_parameters_t",
      description: "Radio parameters.",
      definition: [
        {
          type: "int8_t",
          name: "radioTxPower",
          description: "A power setting, in dBm.",
        },
        {
          type: "uint8_t",
          name: "radioPage",
          description: "A radio page.",
        },
        {
          type: "uint8_t",
          name: "radioChannel",
          description: "A radio channel.",
        },
      ]
    },
    {
      name: "sl_zigbee_zigbee_network_t",
      description: "The parameters of a ZigBee network.",
      definition: [
        {
          type: "uint8_t",
          name: "channel",
          description: "The 802.15.4 channel associated with the
                        network.",
        },
        {
          type: "uint16_t",
          name: "panId",
          description: "The network's PAN identifier.",
        },
        {
          type: "uint8_t[8]",
          name: "extendedPanId",
          description: "The network's extended PAN identifier.",
        },
        {
          type: "bool",
          name: "allowingJoin",
          description: "Whether the network is allowing MAC associations.",
        },
        {
          type: "uint8_t",
          name: "stackProfile",
          description: "The Stack Profile associated with the network.",
        },
        {
          type: "uint8_t",
          name: "nwkUpdateId",
          description: "The instance of the Network.",
        },
      ]
    },
    {
      name: "sl_zigbee_aps_frame_t",
      description: "ZigBee APS frame parameters.",
      definition: [
        {
          type: "uint16_t",
          name: "profileId",
          description: "The application profile ID that describes the
                        format of the message.",
        },
        {
          type: "uint16_t",
          name: "clusterId",
          description: "The cluster ID for this message.",
        },
        {
          type: "uint8_t",
          name: "sourceEndpoint",
          description: "The source endpoint.",
        },
        {
          type: "uint8_t",
          name: "destinationEndpoint",
          description: "The destination endpoint.",
        },
        {
          type: "sl_zigbee_aps_option_t",
          name: "options",
          description: "A bitmask of options.",
        },
        {
          type: "uint16_t",
          name: "groupId",
          description: "The group ID for this message, if it is
                        multicast mode.",
        },
        {
          type: "uint8_t",
          name: "sequence",
          description: "The sequence number.",
        },
      ]
    },
    {
      name: "sl_zigbee_binding_table_entry_t",
      description: "An entry in the binding table.",
      definition: [
        {
          type: "sl_zigbee_binding_type_t",
          name: "type",
          description: "The type of binding.",
        },
        {
          type: "uint8_t",
          name: "local",
          description: "The endpoint on the local node.",
        },
        {
          type: "uint16_t",
          name: "clusterId",
          description: "A cluster ID that matches one from the local
                        endpoint's simple descriptor. This cluster ID is
                        set by the provisioning application to indicate
                        which part an endpoint's functionality is bound
                        to this particular remote node and is used to
                        distinguish between unicast and multicast
                        bindings. Note that a binding can be used to
                        send messages with any cluster ID, not just
                        the one listed in the binding.",
        },
        {
          type: "uint8_t",
          name: "remote",
          description: "The endpoint on the remote node (specified by
                        identifier).",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "identifier",
          description: "A 64-bit identifier. This is either the
                        destination EUI64 (for unicasts) or the 64-bit
                        group address (for multicasts).",
        },
        {
          type: "uint8_t",
          name: "networkIndex",
          description: "The index of the network the binding belongs
                        to.",
        },
      ]
    },
    {
      name: "sl_zigbee_multicast_table_entry_t",
      description: "A multicast table entry indicates that a particular
                    endpoint is a member of a particular multicast
                    group. Only devices with an endpoint in a multicast
                    group will receive messages sent to that multicast
                    group.",
      definition: [
        {
          type: "sl_zigbee_multicast_id_t",
          name: "multicastId",
          description: "The multicast group ID.",
        },
        {
          type: "uint8_t",
          name: "endpoint",
          description: "The endpoint that is a member, or 0 if this
                        entry is not in use (the ZDO is not a member
                        of any multicast groups.)",
        },
        {
          type: "uint8_t",
          name: "networkIndex",
          description: "The network index of the network the entry is
                        related to.",
        },
      ]
    },
    {
      name: "sl_zigbee_key_data_t",
      description: "A 128-bit key.",
      definition: [
        {
          type: "uint8_t[16]",
          name: "contents",
          description: "The key data.",
        },
      ]
    },
    {
      name: "sl_zigbee_certificate_data_t",
      description: "The implicit certificate used in CBKE.",
      definition: [
        {
          type: "uint8_t[48]",
          name: "contents",
          description: "The certificate data.",
        },
      ]
    },
    {
      name: "sl_zigbee_public_key_data_t",
      description: "The public key data used in CBKE.",
      definition: [
        {
          type: "uint8_t[22]",
          name: "contents",
          description: "The public key data.",
        },
      ]
    },
    {
      name: "sl_zigbee_private_key_data_t",
      description: "The private key data used in CBKE.",
      definition: [
        {
          type: "uint8_t[21]",
          name: "contents",
          description: "The private key data.",
        },
      ]
    },
    {
      name: "sl_zigbee_smac_data_t",
      description: "The Shared Message Authentication Code data used in
                    CBKE.",
      definition: [
        {
          type: "uint8_t[16]",
          name: "contents",
          description: "The Shared Message Authentication Code data.",
        },
      ]
    },
    {
      name: "sl_zigbee_signature_data_t",
      description: "An ECDSA signature",
      definition: [
        {
          type: "uint8_t[42]",
          name: "contents",
          description: "The signature data.",
        },
      ]
    },
    {
      name: "sl_zigbee_certificate_283k1_data_t",
      description: "The implicit certificate used in CBKE.",
      definition: [
        {
          type: "uint8_t[74]",
          name: "contents",
          description: "The 283k1 certificate data.",
        },
      ]
    },
    {
      name: "sl_zigbee_public_key_283k1_data_t",
      description: "The public key data used in CBKE.",
      definition: [
        {
          type: "uint8_t[37]",
          name: "contents",
          description: "The 283k1 public key data.",
        },
      ]
    },
    {
      name: "sl_zigbee_private_key_283k1_data_t",
      description: "The private key data used in CBKE.",
      definition: [
        {
          type: "uint8_t[36]",
          name: "contents",
          description: "The 283k1 private key data.",
        },
      ]
    },
    {
      name: "sl_zigbee_signature_283k1_data_t",
      description: "An ECDSA signature",
      definition: [
        {
          type: "uint8_t[72]",
          name: "contents",
          description: "The 283k1 signature data.",
        },
      ]
    },
    {
      name: "sl_zigbee_message_digest_t",
      description: "The calculated digest of a message",
      definition: [
        {
          type: "uint8_t[16]",
          name: "contents",
          description: "The calculated digest of a message.",
        },
      ]
    },
    {
      name: "sl_zigbee_aes_mmo_hash_context_t",
      description: "The hash context for an ongoing hash operation.",
      definition: [
        {
          type: "uint8_t[16]",
          name: "result",
          description: "The result of ongoing the hash operation.",
        },
        {
          type: "uint32_t",
          name: "length",
          description: "The total length of the data that has been
                        hashed so far.",
        },
      ]
    },
    {
      name: "sl_zigbee_beacon_data_t",
      description: "Beacon data structure.",
      definition: [
        {
          type: "uint8_t",
          name: "channel",
          description: "The channel of the received beacon.",
        },
        {
          type: "uint8_t",
          name: "lqi",
          description: "The LQI of the received beacon.",
        },
        {
          type: "int8_t",
          name: "rssi",
          description: "The RSSI of the received beacon.",
        },
        {
          type: "uint8_t",
          name: "depth",
          description: "The depth of the received beacon.",
        },
        {
          type: "uint8_t",
          name: "nwkUpdateId",
          description: "The network update ID of the received beacon.",
        },
        {
          type: "int8_t",
          name: "power",
          description: "The power level of the received beacon. This field is
          valid only if the beacon is an enhanced beacon.",
        },
        {
          type: "int8_t",
          name: "parentPriority",
          description: "The TC connectivity and long uptime from capacity
          field.",
        },
        {
          type: "sl_802154_pan_id_t",
          name: "panId",
          description: "The PAN ID of the received beacon.",
        },
        {
          type: "uint8_t[8]",
          name: "extendedPanId",
          description: "The extended PAN ID of the received beacon.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "sender",
          description: "The sender of the received beacon.",
        },
        {
          type: "bool",
          name: "enhanced",
          description: "Whether or not the beacon is enhanced.",
        },
        {
          type: "bool",
          name: "permitJoin",
          description: "Whether the beacon is advertising permit join.",
        },
        {
          type: "bool",
          name: "hasCapacity",
          description: "Whether the beacon is advertising capacity.",
        },
      ]
    },
    {
      name: "sl_zigbee_beacon_classification_params_t",
      description: "The parameters related to beacon prioritization.",
      definition: [
        {
          type: "int8_t",
          name: "minRssiForReceivingPkts",
          description: "The min rssi value for receiving packets that is used is some beacon prioritization algorithms.",
        },
        {
          type: "uint16_t",
          name: "beaconClassificationMask",
          description: "The beacon classification mask that identifies which beacon prioritization algorithm to pick, and defines the relevant parameters.",
        },
      ]
    },
    {
      name: "sl_zigbee_neighbor_table_entry_t",
      description: "A neighbor table entry stores information about the
                    reliability of RF links to and from neighboring
                    nodes.",
      definition: [
        {
          type: "uint16_t",
          name: "shortId",
          description: "The neighbor's two byte network id",
        },
        {
          type: "uint8_t",
          name: "averageLqi",
          description: "An exponentially weighted moving average of the
                        link quality values of incoming packets from
                        this neighbor as reported by the PHY.",
        },
        {
          type: "uint8_t",
          name: "inCost",
          description: "The incoming cost for this neighbor, computed
                        from the average LQI. Values range from 1 for
                        a good link to 7 for a bad link.",
        },
        {
          type: "uint8_t",
          name: "outCost",
          description: "The outgoing cost for this neighbor, obtained
                        from the most recently received neighbor exchange
                        message from the neighbor. A value of zero
                        means that a neighbor exchange message from the
                        neighbor has not been received recently enough,
                        or that our id was not present in the most
                        recently received one.",
        },
        {
          type: "uint8_t",
          name: "age",
          description: "The number of aging periods elapsed since a
                        link status message was last received from this
                        neighbor. The aging period is 16 seconds.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "longId",
          description: "The 8 byte EUI64 of the neighbor.",
        },
      ]
    },
    {
      name: "sl_zigbee_route_table_entry_t",
      description: "A route table entry stores information about the
                    next hop along the route to the destination.",
      definition: [
        {
          type: "uint16_t",
          name: "destination",
          description: "The short id of the destination. A value of
                        0xFFFF indicates the entry is unused.",
        },
        {
          type: "uint16_t",
          name: "nextHop",
          description: "The short id of the next hop to this
                        destination.",
        },
        {
          type: "uint8_t",
          name: "status",
          description: "Indicates whether this entry is active (0),
                        being discovered (1), unused (3), or validating
                        (4).",
        },
        {
          type: "uint8_t",
          name: "age",
          description: "The number of seconds since this route entry
                        was last used to send a packet.",
        },
        {
          type: "uint8_t",
          name: "concentratorType",
          description: "Indicates whether this destination is a High
                        RAM Concentrator (2), a Low RAM Concentrator
                        (1), or not a concentrator (0).",
        },
        {
          type: "uint8_t",
          name: "routeRecordState",
          description: "For a High RAM Concentrator, indicates whether
                        a route record is needed (2), has been sent
                        (1), or is no long needed (0) because a source
                        routed message from the concentrator has been
                        received.",
        },
      ]
    },
    {
      name: "sl_zigbee_initial_security_state_t",
      description: "The security data used to set the configuration
                    for the stack, or the retrieved configuration
                    currently in use.",
      definition: [
        {
          type: "sl_zigbee_initial_security_bitmask_t",
          name: "bitmask",
          description: "A bitmask indicating the security state used to
                        indicate what the security configuration will be
                        when the device forms or joins the network.",
        },
        {
          type: "sl_zigbee_key_data_t",
          name: "preconfiguredKey",
          description: "The pre-configured Key data that should be used
                        when forming or joining the network. The
                        security bitmask must be set with the
                        SL_ZIGBEE_HAVE_PRECONFIGURED_KEY bit to indicate that
                        the key contains valid data.",
        },
        {
          type: "sl_zigbee_key_data_t",
          name: "networkKey",
          description: "The Network Key that should be used by the
                        Trust Center when it forms the network, or the
                        Network Key currently in use by a joined
                        device. The security bitmask must be set with
                        SL_ZIGBEE_HAVE_NETWORK_KEY to indicate that the key
                        contains valid data.",
        },
        {
          type: "uint8_t",
          name: "networkKeySequenceNumber",
          description: "The sequence number associated with the network
                        key. This is only valid if the
                        SL_ZIGBEE_HAVE_NETWORK_KEY has been set in the
                        security bitmask.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "preconfiguredTrustCenterEui64",
          description: "This is the long address of the trust center
                        on the network that will be joined. It is
                        usually NOT set prior to joining the network
                        and instead it is learned during the joining
                        message exchange. This field is only examined if
                        ::SL_ZIGBEE_HAVE_TRUST_CENTER_EUI64 is set in the
                        sl_zigbee_initial_security_state_t::bitmask. Most devices
                        should clear that bit and leave this field
                        alone. This field must be set when using
                        commissioning mode.",
        },
      ]
    },
    {
      name: "sl_zigbee_current_security_state_t",
      description: "The security options and information currently used
                    by the stack.",
      definition: [
        {
          type: "sl_zigbee_current_security_bitmask_t",
          name: "bitmask",
          description: "A bitmask indicating the security options
                        currently in use by a device joined in the
                        network.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "trustCenterLongAddress",
          description: "The IEEE Address of the Trust Center device.",
        },
      ]
    },
    {
      name: "sl_zigbee_key_struct_t",
      description: "A structure containing a key and its associated
                    data.",
      definition: [
        {
          type: "sl_zigbee_key_struct_bitmask_t",
          name: "bitmask",
          description: "A bitmask indicating the presence of data
                        within the various fields in the structure.",
        },
        {
          type: "sl_zigbee_key_type_t",
          name: "type",
          description: "The type of the key.",
        },
        {
          type: "sl_zigbee_key_data_t",
          name: "key",
          description: "The actual key data.",
        },
        {
          type: "uint32_t",
          name: "outgoingFrameCounter",
          description: "The outgoing frame counter associated with the
                        key.",
        },
        {
          type: "uint32_t",
          name: "incomingFrameCounter",
          description: "The frame counter of the partner device
                        associated with the key.",
        },
        {
          type: "uint8_t",
          name: "sequenceNumber",
          description: "The sequence number associated with the key.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "partnerEUI64",
          description: "The IEEE address of the partner device also in
                        possession of the key.",
        },
      ]
    },
    {
      name: "sl_zigbee_network_init_struct_t",
      description: "Network Initialization parameters.",
      definition: [
        {
          type: "sl_zigbee_network_init_bitmask_t",
          name: "bitmask",
          description: "Configuration options for network init.",
        },
      ]
    },
    {
      name: "sl_zigbee_zll_security_algorithm_data_t",
      description: "Data associated with the ZLL security algorithm.",
      definition: [
        {
          type: "uint32_t",
          name: "transactionId",
          description: "Transaction identifier.",
        },
        {
          type: "uint32_t",
          name: "responseId",
          description: "Response identifier.",
        },
        {
          type: "uint16_t",
          name: "bitmask",
          description: "Bitmask.",
        },
      ]
    },
    {
      name: "sl_zigbee_zll_network_t",
      description: "The parameters of a ZLL network.",
      definition: [
        {
          type: "sl_zigbee_zigbee_network_t",
          name: "zigbeeNetwork",
          description: "The parameters of a ZigBee network.",
        },
        {
          type: "sl_zigbee_zll_security_algorithm_data_t",
          name: "securityAlgorithm",
          description: "Data associated with the ZLL security algorithm.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "Associated EUI64.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "nodeId",
          description: "The node id.",
        },
        {
          type: "sl_zigbee_zll_state_t",
          name: "state",
          description: "The ZLL state.",
        },
        {
          type: "sl_zigbee_node_type_t",
          name: "nodeType",
          description: "The node type.",
        },
        {
          type: "uint8_t",
          name: "numberSubDevices",
          description: "The number of sub devices.",
        },
        {
          type: "uint8_t",
          name: "totalGroupIdentifiers",
          description: "The total number of group identifiers.",
        },
        {
          type: "uint8_t",
          name: "rssiCorrection",
          description: "RSSI correction value.",
        },
      ]
    },
    {
      name: "sl_zigbee_zll_initial_security_state_t",
      description: "Describes the initial security features and
                    requirements that will be used when forming or
                    joining ZLL networks.",
      definition: [
        {
          type: "uint32_t",
          name: "bitmask",
          description: "Unused bitmask; reserved for future use.",
        },
        {
          type: "sl_zigbee_zll_key_index_t",
          name: "keyIndex",
          description: "The key encryption algorithm advertised by the
                        application.",
        },
        {
          type: "sl_zigbee_key_data_t",
          name: "encryptionKey",
          description: "The encryption key for use by algorithms that
                        require it.",
        },
        {
          type: "sl_zigbee_key_data_t",
          name: "preconfiguredKey",
          description: "The pre-configured link key used during
                        classical ZigBee commissioning.",
        },
      ]
    },
    {
      name: "sl_zigbee_zll_device_info_record_t",
      description: "Information about a specific ZLL Device.",
      definition: [
        {
          type: "sl_802154_long_addr_t",
          name: "ieeeAddress",
          description: "EUI64 associated with the device.",
        },
        {
          type: "uint8_t",
          name: "endpointId",
          description: "Endpoint id.",
        },
        {
          type: "uint16_t",
          name: "profileId",
          description: "Profile id.",
        },
        {
          type: "uint16_t",
          name: "deviceId",
          description: "Device id.",
        },
        {
          type: "uint8_t",
          name: "version",
          description: "Associated version.",
        },
        {
          type: "uint8_t",
          name: "groupIdCount",
          description: "Number of relevant group ids.",
        },
      ]
    },
    {
      name: "sl_zigbee_zll_address_assignment_t",
      description: "ZLL address assignment data.",
      definition: [
        {
          type: "sl_802154_short_addr_t",
          name: "nodeId",
          description: "Relevant node id.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "freeNodeIdMin",
          description: "Minimum free node id.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "freeNodeIdMax",
          description: "Maximum free node id.",
        },
        {
          type: "sl_zigbee_multicast_id_t",
          name: "groupIdMin",
          description: "Minimum group id.",
        },
        {
          type: "sl_zigbee_multicast_id_t",
          name: "groupIdMax",
          description: "Maximum group id.",
        },
        {
          type: "sl_zigbee_multicast_id_t",
          name: "freeGroupIdMin",
          description: "Minimum free group id.",
        },
        {
          type: "sl_zigbee_multicast_id_t",
          name: "freeGroupIdMax",
          description: "Maximum free group id.",
        },
      ]
    },
    {
      name: "sl_zigbee_tok_type_stack_zll_data_t",
      description: "Public API for ZLL stack data token.",
      definition: [
        {
          type: "uint32_t",
          name: "bitmask",
          description: "Token bitmask.",
        },
        {
          type: "uint16_t",
          name: "freeNodeIdMin",
          description: "Minimum free node id.",
        },
        {
          type: "uint16_t",
          name: "freeNodeIdMax",
          description: "Maximum free node id.",
        },
        {
          type: "uint16_t",
          name: "myGroupIdMin",
          description: "Local minimum group id.",
        },
        {
          type: "uint16_t",
          name: "freeGroupIdMin",
          description: "Minimum free group id.",
        },
        {
          type: "uint16_t",
          name: "freeGroupIdMax",
          description: "Maximum free group id.",
        },
        {
          type: "uint8_t",
          name: "rssiCorrection",
          description: "RSSI correction value.",
        },
      ]
    },
    {
      name: "sl_zigbee_tok_type_stack_zll_security_t",
      description: "Public API for ZLL stack security token.",
      definition: [
        {
          type: "uint32_t",
          name: "bitmask",
          description: "Token bitmask.",
        },
        {
          type: "uint8_t",
          name: "keyIndex",
          description: "Key index.",
        },
        {
          type: "uint8_t[16]",
          name: "encryptionKey",
          description: "Encryption key.",
        },
        {
          type: "uint8_t[16]",
          name: "preconfiguredKey",
          description: "Preconfigured key.",
        },
      ]
    },
    {
      name: "sl_zigbee_duty_cycle_hecto_pct_t",
      description: "The percent of duty cycle for a limit.
                    Duty Cycle, Limits, and Thresholds are reported in
                    units of Percent * 100 (i.e. 10000 = 100.00%, 1 = 0.01%).",
      definition: "uint16_t"
    },
    {
      name: "sl_zigbee_duty_cycle_limits_t",
      description: "A structure containing duty cycle limit configurations.
                    All limits are absolute, and are required to be as
                    follows: suspLimit > critThresh > limitThresh
                    For example:  suspLimit = 250 (2.5%),
                    critThresh = 180 (1.8%), limitThresh 100 (1.00%).",
      definition: [
        {
          type: "sl_zigbee_duty_cycle_hecto_pct_t",
          name: "limitThresh",
          description: "The Limited Threshold in % * 100",
        },
        {
          type: "sl_zigbee_duty_cycle_hecto_pct_t",
          name: "critThresh",
          description: "The Critical Threshold in % * 100.",
        },
        {
          type: "sl_zigbee_duty_cycle_hecto_pct_t",
          name: "suspLimit",
          description: "The Suspended Limit (LBT) in % * 100.",
        },
      ]
    },
    {
      name: "sl_zigbee_per_device_duty_cycle_t",
      description: "A structure containing per device overall duty cycle
                    consumed (up to the suspend limit).",
      definition: [
        {
          type: "sl_802154_short_addr_t",
          name: "nodeId",
          description: "Node Id of device whose duty cycle is reported.",
        },
        {
          type: "sl_zigbee_duty_cycle_hecto_pct_t",
          name: "dutyCycleConsumed",
          description: "Amount of overall duty cycle consumed (up to suspend limit).",
        },
      ]
    },
    {
      name: "sl_zigbee_transient_key_data_t",
      description: "The transient key data structure.",
      definition: [
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "The IEEE address paired with the transient link key.",
        },
        {
          type: "sl_zigbee_key_data_t",
          name: "keyData",
          description: "The key data structure matching the transient key.",
        },
        {
          type: "uint32_t",
          name: "incomingFrameCounter",
          description: "The incoming frame counter associated with this key.",
        },
        {
          type: "sl_zigbee_key_struct_bitmask_t",
          name: "bitmask",
          description: "This bitmask indicates whether various fields
                        in the structure contain valid data.",
        },
        {
          type: "uint16_t",
          name: "remainingTimeSeconds",
          description: "The number of seconds remaining before the key is
                        automatically timed out of the transient key table.",
        },
        {
          type: "uint8_t",
          name: "networkIndex",
          description: "The network index indicates which NWK uses this key.",
        },
      ]
    },
    {
      name: "sl_zigbee_child_data_t",
      description: "A structure containing a child node's data.",
      definition: [
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "The EUI64 of the child",
        },
        {
          type: "sl_zigbee_node_type_t",
          name: "type",
          description: "The node type of the child",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "id",
          description: "The short address of the child",
        },
        {
          type: "uint8_t",
          name: "phy",
          description: "The phy of the child",
        },
        {
          type: "uint8_t",
          name: "power",
          description: "The power of the child",
        },
        {
          type: "uint8_t",
          name: "timeout",
          description: "The timeout of the child",
        },
      ],
    },
    {
      name: "sl_zigbee_library_id_t",
      description: "A library identifier",
      definition: "uint8_t",
    },
    {
      name: "sl_zigbee_sec_man_key_t",
      description: "A 128-bit key.",
      definition: [
        {
          type: "uint8_t[16]",
          name: "key",
          description: "The key data.",
        },
      ],
    },
    {
      name: "sl_zigbee_sec_man_context_t",
      description: "Context for Zigbee Security Manager operations.",
      definition: [
        {
          type: "sl_zigbee_sec_man_key_type_t",
          name: "core_key_type",
          description: "The type of key being referenced.",
        },
        {
          type: "uint8_t",
          name: "key_index",
          description: "The index of the referenced key.",
        },
        {
          type: "sl_zigbee_sec_man_derived_key_type_t",
          name: "derived_type",
          description: "The type of key derivation operation to perform on a key.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "The EUI64 associated with this key.",
        },
        {
          type: "uint8_t",
          name: "multi_network_index",
          description: "Multi-network index.",
        },
        {
          type: "sl_zigbee_sec_man_flags_t",
          name: "flags",
          description: "Flag bitmask.",
        },
        {
          type: "uint32_t",
          name: "psa_key_alg_permission",
          description: "Algorithm to use with this key (for PSA APIs)",
        },
      ],
    },
    {
      name: "sl_zigbee_sec_man_network_key_info_t",
      description: "Metadata for network keys.",
      definition: [
        {
          type: "bool",
          name: "network_key_set",
          description: "Whether the current network key is set.",
        },
        {
          type: "bool",
          name: "alternate_network_key_set",
          description: "Whether the alternate network key is set.",
        },
        {
          type: "uint8_t",
          name: "network_key_sequence_number",
          description: "Current network key sequence number.",
        },
        {
          type: "uint8_t",
          name: "alt_network_key_sequence_number",
          description: "Alternate network key sequence number.",
        },
        {
          type: "uint32_t",
          name: "network_key_frame_counter",
          description: "Frame counter for the network key."
        }
      ],
    },
    {
      name: "sl_zigbee_sec_man_aps_key_metadata_t",
      description: "Metadata for APS link keys.",
      definition: [
        {
          type: "sl_zigbee_key_struct_bitmask_t",
          name: "bitmask",
          description: "Bitmask of key properties",
        },
        {
          type: "uint32_t",
          name: "outgoing_frame_counter",
          description: "Outgoing frame counter.",
        },
        {
          type: "uint32_t",
          name: "incoming_frame_counter",
          description: "Incoming frame counter.",
        },
        {
          type: "uint16_t",
          name: "ttl_in_seconds",
          description: "Remaining lifetime (for transient keys).",
        },
      ],
    },
    {
      name: "sl_802154_radio_priorities_t",
      description: "Scheduler priorities for radio operations",
      definition: [
        {
          type: "uint8_t",
          name: "background_rx",
          description: "The priority of a Zigbee RX operation while not receiving a packet",
        },
        {
          type: "uint8_t",
          name: "min_tx_priority",
          description: "Starting priority of a Zigbee TX operation. The first transmit of the packet, before retries, uses this priority",
        },
        {
          type: "uint8_t",
          name: "tx_step",
          description: "The increase in TX priority (which is a decrement in value) for each retry",
        },
        {
          type: "uint8_t",
          name: "max_tx_priority",
          description: "Maximum priority of a Zigbee TX operation. Retried messages have priorities bumped by tx_step, up to a maximum of max_tx_priority",
        },
        {
          type: "uint8_t",
          name: "active_rx",
          description: "The priority of a Zigbee RX operation while receiving a packet",
        },
      ],
    },
    {
      name: "sl_zigbee_endpoint_description_t",
      description: "Description of a particular endpoint.",
      definition: [
        {
          type: "uint16_t",
          name: "profileId",
          description: "The endpoint's application profile.",
        },
        {
          type: "uint16_t",
          name: "deviceId",
          description: "The endpoint's device ID within the application profile.",
        },
        {
          type: "uint8_t",
          name: "deviceVersion",
          description: "The endpoint's device version.",
        },
        {
          type: "uint8_t",
          name: "inputClusterCount",
          description: "The number of input clusters.",
        },
        {
          type: "uint8_t",
          name: "outputClusterCount",
          description: "The number of output clusters.",
        },
      ],
    },
    {
      name: "sl_zigbee_rx_packet_info_t",
      description: "Incoming message Information",
      definition: [
        {
          type: "uint16_t",
          name: "sender_short_id",
          description: "Short ID of the sender of the message.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "sender_long_id",
          description: "EUI64 of the sender of the message if the sender chose to
                        this information in the message. The ::SL_ZIGBEE_APS_OPTION_SOURCE_EUI64 
                        bit in the options field of the APS frame of the incoming message 
                        indicates that the EUI64 is present in the message.",
        },
        {
          type: "uint8_t",
          name: "binding_index",
          description: "The index of the entry in the binding table that matches the sender of
                        the message or 0xFF if there is no matching entry.",
        },
        {
          type: "uint8_t",
          name: "address_index",
          description: "The index of the entry in the address table that matches the sender of
                        the message or 0xFF if there is no matching entry.",
        },
        {
          type: "uint8_t",
          name: "lasy_hop_lqi",
          description: "Link quality of the node that last relayed the current message.",
        },
        {
          type: "int8_t",
          name: "lasy_hop_rssi",
          description: "Received signal strength indicator (RSSI) of the node that last
                        relayed the message.",
        },
        {
          type: "uint32_t",
          name: "lasy_hop_timestamp",
          description: "Timestamp of the moment when Start Frame Delimiter (SFD) was received.",
        }
      ]
    }
  ],

  enums: [
    {
      name: "bool",
      type: "uint8_t",
      description: "Boolean type with values true and false.",
      items: [
        {
          name: "false",
          value: "0x00",
          description: "An alias for zero, used for clarity.",
        },
        {
          name: "true",
          value: "0x01",
          description: "An alias for one, used for clarity.",
        },
      ],
    },
    {
      name: "sl_zigbee_ezsp_config_id_t",
      type: "uint8_t",
      description: "Identifies a configuration value.",
      items: [
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_PACKET_BUFFER_HEAP_SIZE",
          value: "0x01",
          description: "The NCP no longer supports configuration of  
                        packet buffer heap at runtime using this
                        parameter. Packet buffer heap space must be configured
                        using the SL_ZIGBEE_PACKET_BUFFER_HEAP_SIZE macro
                        when building the NCP project.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_NEIGHBOR_TABLE_SIZE",
          value: "0x02",
          description: "The maximum number of router neighbors the
                        stack can keep track of. A neighbor is a node
                        within radio range.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_APS_UNICAST_MESSAGE_COUNT",
          value: "0x03",
          description: "The maximum number of APS retried messages the
                        stack can be transmitting at any time.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_BINDING_TABLE_SIZE",
          value: "0x04",
          description: "The maximum number of non-volatile bindings
                        supported by the stack.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_ADDRESS_TABLE_SIZE",
          value: "0x05",
          description: "The maximum number of EUI64 to network address
                        associations that the stack can maintain for
                        the application. (Note, the total number of such
                        address associations maintained by the NCP is
                        the sum of the value of this setting and the value
                        of ::SL_ZIGBEE_EZSP_CONFIG_TRUST_CENTER_ADDRESS_CACHE_SIZE.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_MULTICAST_TABLE_SIZE",
          value: "0x06",
          description: "The maximum number of multicast groups that the
                        device may be a member of.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_ROUTE_TABLE_SIZE",
          value: "0x07",
          description: "The maximum number of destinations to which a
                        node can route messages. This includes both
                        messages originating at this node and those
                        relayed for others.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_DISCOVERY_TABLE_SIZE",
          value: "0x08",
          description: "The number of simultaneous route discoveries
                        that a node will support.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_STACK_PROFILE",
          value: "0x0C",
          description: "Specifies the stack profile.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_SECURITY_LEVEL",
          value: "0x0D",
          description: "The security level used for security at the
                        MAC and network layers. The supported values are
                        0 (no security) and 5 (payload is encrypted and
                        a four-byte MIC is used for authentication).",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_MAX_HOPS",
          value: "0x10",
          description: "The maximum number of hops for a message.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_MAX_END_DEVICE_CHILDREN",
          value: "0x11",
          description: "The maximum number of end device children that
                        a router will support.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_INDIRECT_TRANSMISSION_TIMEOUT",
          value: "0x12",
          description: "The maximum amount of time that the MAC will
                        hold a message for indirect transmission to a
                        child.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_END_DEVICE_POLL_TIMEOUT",
          value: "0x13",
          description: "The maximum amount of time that an end device
                        child can wait between polls. If no poll is
                        heard within this timeout, then the parent
                        removes the end device from its tables.
                        Value range 0-14. The timeout corresponding
                        to a value of zero is 10 seconds. The timeout
                        corresponding to a nonzero value N is
                        2^N minutes, ranging from 2^1 = 2 minutes
                        to 2^14 = 16384 minutes.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_TX_POWER_MODE",
          value: "0x17",
          description: "Enables boost power mode and/or the alternate
                        transmitter output.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_DISABLE_RELAY",
          value: "0x18",
          description: "0: Allow this node to relay messages. 1:
                        Prevent this node from relaying messages.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_TRUST_CENTER_ADDRESS_CACHE_SIZE",
          value: "0x19",
          description: "The maximum number of EUI64 to network address
                        associations that the Trust Center can maintain.
                        These address cache entries are reserved for and
                        reused by the Trust Center when processing device
                        join/rejoin authentications. This cache size
                        limits the number of overlapping joins the Trust
                        Center can process within a narrow time window
                        (e.g. two seconds), and thus should be set to the
                        maximum number of near simultaneous joins the Trust
                        Center is expected to accommodate. (Note, the total
                        number of such address associations maintained by
                        the NCP is the sum of the value of this setting and
                        the value of ::SL_ZIGBEE_EZSP_CONFIG_ADDRESS_TABLE_SIZE.)",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_SOURCE_ROUTE_TABLE_SIZE",
          value: "0x1A",
          description: "The size of the source route table.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_FRAGMENT_WINDOW_SIZE",
          value: "0x1C",
          description: "The number of blocks of a fragmented message
                        that can be sent in a single window.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_FRAGMENT_DELAY_MS",
          value: "0x1D",
          description: "The time the stack will wait (in milliseconds)
                        between sending blocks of a fragmented message.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_KEY_TABLE_SIZE",
          value: "0x1E",
          description: "The size of the Key Table used for storing
                        individual link keys (if the device is a Trust
                        Center) or Application Link Keys (if the device
                        is a normal node).",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_APS_ACK_TIMEOUT",
          value: "0x1F",
          description: "The APS ACK timeout value. The stack waits
                        this amount of time between resends of APS
                        retried messages.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_BEACON_JITTER_DURATION",
          value: "0x20",
          description: "The duration of a beacon jitter, in the units
                        used by the 15.4 scan parameter (((1 <<
                        duration) + 1) * 15ms), when responding to a beacon
                        request.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_PAN_ID_CONFLICT_REPORT_THRESHOLD",
          value: "0x22",
          description: "The number of PAN id conflict reports that
                        must be received by the network manager within
                        one minute to trigger a PAN id change.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_REQUEST_KEY_TIMEOUT",
          value: "0x24",
          description: "The timeout value in minutes for how long the
                        Trust Center or a normal node waits for the
                        ZigBee Request Key to complete. On the Trust
                        Center this controls whether or not the device
                        buffers the request, waiting for a matching pair
                        of ZigBee Request Key. If the value is
                        non-zero, the Trust Center buffers and waits for
                        that amount of time. If the value is zero, the
                        Trust Center does not buffer the request and
                        immediately responds to the request. Zero is the
                        most compliant behavior.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_CERTIFICATE_TABLE_SIZE",
          value: "0x29",
          description: "This value indicates the size of the runtime
                        modifiable certificate table. Normally certificates
                        are stored in MFG tokens but this table can be
                        used to field upgrade devices with new Smart
                        Energy certificates. This value cannot be set,
                        it can only be queried.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_APPLICATION_ZDO_FLAGS",
          value: "0x2A",
          description: "This is a bitmask that controls which incoming
                        ZDO request messages are passed to the
                        application. The bits are defined in the
                        sl_zigbee_zdo_configuration_flags_t enumeration. To see if
                        the application is required to send a ZDO
                        response in reply to an incoming message, the
                        application must check the APS options bitfield
                        within the incomingMessageHandler callback to see
                        if the SL_ZIGBEE_APS_OPTION_ZDO_RESPONSE_REQUIRED flag
                        is set.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_BROADCAST_TABLE_SIZE",
          value: "0x2B",
          description: "The maximum number of broadcasts during a
                        single broadcast timeout period.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_MAC_FILTER_TABLE_SIZE",
          value: "0x2C",
          description: "The size of the MAC filter list table.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_SUPPORTED_NETWORKS",
          value: "0x2D",
          description: "The number of supported networks.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_SEND_MULTICASTS_TO_SLEEPY_ADDRESS",
          value: "0x2E",
          description: "Whether multicasts are sent to the
                        RxOnWhenIdle=true address (0xFFFD) or the sleepy
                        broadcast address (0xFFFF). The RxOnWhenIdle=true
                        address is the ZigBee compliant destination for
                        multicasts.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_ZLL_GROUP_ADDRESSES",
          value: "0x2F",
          description: "ZLL group address initial configuration.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_ZLL_RSSI_THRESHOLD",
          value: "0x30",
          description: "ZLL rssi threshold initial configuration.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_MTORR_FLOW_CONTROL",
          value: "0x33",
          description: "Toggles the MTORR flow control in the stack.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_RETRY_QUEUE_SIZE",
          value: "0x34",
          description: "Setting the retry queue size. Applies to all queues.
                        Default value in the sample applications is 16.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_NEW_BROADCAST_ENTRY_THRESHOLD",
          value: "0x35",
          description: "Setting the new broadcast entry threshold. The number
                        (BROADCAST_TABLE_SIZE - NEW_BROADCAST_ENTRY_THRESHOLD) of
                        broadcast table entries are reserved for relaying the
                        broadcast messages originated on other devices. The
                        local device will fail to originate a broadcast message
                        after this threshold is reached. Setting this value to
                        BROADCAST_TABLE_SIZE and greater will effectively kill
                        this limitation.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_TRANSIENT_KEY_TIMEOUT_S",
          value: "0x36",
          description: "<Deprecated: See SL_ZIGBEE_EZSP_VALUE_TRANSIENT_KEY_TIMEOUT_S> The length of time, in seconds, that a trust center will
                        store a transient link key that a device can use
                        to join its network. A transient key is added with a call
                        to emberAddTransientLinkKey. After the transient key is
                        added, it will be removed once this amount of time has
                        passed. A joining device will not be able to use that
                        key to join until it is added again on the trust center.
                        The default value is 300 seconds, i.e., 5 minutes."
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_BROADCAST_MIN_ACKS_NEEDED",
          value: "0x37",
          description: "The number of passive acknowledgements to record from
                        neighbors before we stop re-transmitting broadcasts",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_TC_REJOINS_USING_WELL_KNOWN_KEY_TIMEOUT_S",
          value: "0x38",
          description: "The length of time, in seconds, that a trust center will
                        allow a Trust Center (insecure) rejoin for a device that
                        is using the well-known link key. This timeout takes
                        effect once rejoins using the well-known key has been
                        allowed. This command updates the
                        sli_zigbee_allow_tc_rejoins_using_well_known_key_timeout_sec value.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_CTUNE_VALUE",
          value: "0x39",
          description: "Valid range of a CTUNE value is 0x0000-0x01FF.
                        Higher order bits (0xFE00) of the 16-bit value
                        are ignored.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_ASSUME_TC_CONCENTRATOR_TYPE",
          value: "0x40",
          description: "To configure non trust center node to assume a concentrator
                        type of the trust center it join to, until it receive
                        many-to-one route request from the trust center. For the
                        trust center node, concentrator type is configured from
                        the concentrator plugin. The stack by default assumes trust
                        center be a low RAM concentrator that make other devices send
                        route record to the trust center even without receiving
                        a many-to-one route request. The default concentrator
                        type can be changed by setting appropriate
                        sl_zigbee_assume_trust_center_concentrator_type_t config value.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_GP_PROXY_TABLE_SIZE",
          value: "0x41",
          description: "This is green power proxy table size.
                        This value is read-only and cannot be set at runtime",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_GP_SINK_TABLE_SIZE",
          value: "0x42",
          description: "This is green power sink table size.
                        This value is read-only and cannot be set at runtime",
        },
        {
          name: "SL_ZIGBEE_EZSP_CONFIG_END_DEVICE_CONFIGURATION",
          value: "0x43",
          description: "This is The configuration advertised by the end device to the
                        parent when joining/rejoining, either
                        SL_ZIGBEE_END_DEVICE_CONFIG_NONE or
                        SL_ZIGBEE_END_DEVICE_CONFIG_PERSIST_DATA_ON_PARENT.",
        },
      ],
    },
    {
      name: "sl_zigbee_ezsp_value_id_t",
      type: "uint8_t",
      description: "Identifies a value.",
      items: [
        {
          name: "SL_ZIGBEE_EZSP_VALUE_TOKEN_STACK_NODE_DATA",
          value: "0x00",
          description: "The contents of the node data stack token.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_MAC_PASSTHROUGH_FLAGS",
          value: "0x01",
          description: "The types of MAC passthrough messages that the
                        host wishes to receive.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_EMBERNET_PASSTHROUGH_SOURCE_ADDRESS",
          value: "0x02",
          description: "The source address used to filter legacy
                        EmberNet messages when the
                        SL_802154_PASSTHROUGH_EMBERNET_SOURCE flag is set
                        in SL_ZIGBEE_EZSP_VALUE_MAC_PASSTHROUGH_FLAGS.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_BUFFER_HEAP_FREE_SIZE",
          value: "0x03",
          description: "The amount in bytes (max 2^16) of available general purpose heap memory",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_UART_SYNCH_CALLBACKS",
          value: "0x04",
          description: "Selects sending synchronous callbacks in
                        ezsp-uart.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_MAXIMUM_INCOMING_TRANSFER_SIZE",
          value: "0x05",
          description: "The maximum incoming transfer size for the local node.
                        Default value is set to 82 and does not use fragmentation.
                        Sets the value in Node Descriptor. To set, this takes the
                        input of a uint8 array of length 2 where you pass the
                        lower byte at index 0 and upper byte at index 1.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_MAXIMUM_OUTGOING_TRANSFER_SIZE",
          value: "0x06",
          description: "The maximum outgoing transfer size for the local node.
                        Default value is set to 82 and does not use fragmentation.
                        Sets the value in Node Descriptor. To set, this takes the
                        input of a uint8 array of length 2 where you pass the
                        lower byte at index 0 and upper byte at index 1.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_STACK_TOKEN_WRITING",
          value: "0x07",
          description: "A bool indicating whether stack tokens are
                        written to persistent storage as they change.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_STACK_IS_PERFORMING_REJOIN",
          value: "0x08",
          description: "A read-only value indicating whether the stack
                        is currently performing a rejoin.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_MAC_FILTER_LIST",
          value: "0x09",
          description: "A list of sl_zigbee_mac_filter_match_data_t values.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_EXTENDED_SECURITY_BITMASK",
          value: "0x0A",
          description: "The Ember Extended Security Bitmask.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_NODE_SHORT_ID",
          value: "0x0B",
          description: "The node short ID.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_DESCRIPTOR_CAPABILITY",
          value: "0x0C",
          description: "The descriptor capability of the local node. Write only.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_STACK_DEVICE_REQUEST_SEQUENCE_NUMBER",
          value: "0x0D",
          description: "The stack device request sequence number of the
                        local node.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_RADIO_HOLD_OFF",
          value: "0x0E",
          description: "Enable or disable radio hold-off.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_ENDPOINT_FLAGS",
          value: "0x0F",
          description: "The flags field associated with the endpoint
                        data.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_MFG_SECURITY_CONFIG",
          value: "0x10",
          description: "Enable/disable the Mfg security config key
                        settings.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_VERSION_INFO",
          value: "0x11",
          description: "Retrieves the version information from the stack
                        on the NCP.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_LAST_REJOIN_REASON",
          value: "0x13",
          description: "This is the reason that the last rejoin took
                        place. This value may only be retrieved, not
                        set. The rejoin may have been initiated by the
                        stack (NCP) or the application (host). If a
                        host initiated a rejoin the reason will be set
                        by default to SL_ZIGBEE_REJOIN_DUE_TO_APP_EVENT_1. If
                        the application wishes to denote its own rejoin
                        reasons it can do so by calling
                        sl_zigbee_ezsp_set_value(EMBER_VALUE_HOST_REJOIN_REASON,
                        SL_ZIGBEE_REJOIN_DUE_TO_APP_EVENT_X). X is a number
                        corresponding to one of the app events defined.
                        If the NCP initiated a rejoin it will record
                        this value internally for retrieval by
                        sl_zigbee_ezsp_get_value(EZSP_VALUE_REAL_REJOIN_REASON).",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_NEXT_ZIGBEE_SEQUENCE_NUMBER",
          value: "0x14",
          description: "The next ZigBee sequence number.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_CCA_THRESHOLD",
          value: "0x15",
          description: "CCA energy detect threshold for radio.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_SET_COUNTER_THRESHOLD",
          value: "0x17",
          description: "The threshold value for a counter",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_RESET_COUNTER_THRESHOLDS",
          value: "0x18",
          description: "Resets all counters thresholds to 0xFF",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_CLEAR_COUNTERS",
          value: "0x19",
          description: "Clears all the counters",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_CERTIFICATE_283K1",
          value: "0x1A",
          description: "The node's new certificate signed by the CA.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_PUBLIC_KEY_283K1",
          value: "0x1B",
          description: "The Certificate Authority's public key.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_PRIVATE_KEY_283K1",
          value: "0x1C",
          description: "The node's new static private key.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_NWK_FRAME_COUNTER",
          value: "0x23",
          description: "The NWK layer security frame counter value",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_APS_FRAME_COUNTER",
          value: "0x24",
          description: "The APS layer security frame counter value.
                        Managed by the stack. Users should not set these
                        unless doing backup and restore.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_RETRY_DEVICE_TYPE",
          value: "0x25",
          description: "Sets the device type to use on the next rejoin using device type",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_ENABLE_R21_BEHAVIOR",
          value: "0x29",
          description: "Setting this byte enables R21 behavior on the NCP.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_ANTENNA_MODE",
          value: "0x30",
          description: "Configure the antenna mode(0-don't switch,1-primary,2-secondary,3-TX antenna diversity).",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_ENABLE_PTA",
          value: "0x31",
          description: "Enable or disable packet traffic arbitration.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_PTA_OPTIONS",
          value: "0x32",
          description: "Set packet traffic arbitration configuration options.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_MFGLIB_OPTIONS",
          value: "0x33",
          description: "Configure manufacturing library options (0-non-CSMA
                        transmits,1-CSMA transmits). To be used with
                        Manufacturing Library.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_USE_NEGOTIATED_POWER_BY_LPD",
          value: "0x34",
          description: "Sets the flag to use either negotiated power by link power delta (LPD)
                        or fixed power value provided by user while forming/joining a network
                        for packet transmissions on sub-ghz interface. This is mainly for testing purposes.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_PTA_PWM_OPTIONS",
          value: "0x35",
          description: "Set packet traffic arbitration PWM options.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_PTA_DIRECTIONAL_PRIORITY_PULSE_WIDTH",
          value: "0x36",
          description: "Set packet traffic arbitration directional priority pulse width in microseconds.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_PTA_PHY_SELECT_TIMEOUT",
          value: "0x37",
          description: "Set packet traffic arbitration phy select timeout(ms).",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_ANTENNA_RX_MODE",
          value: "0x38",
          description: "Configure the RX antenna mode: (0-do not switch; 1-primary; 2-secondary; 3-RX antenna diversity).",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_NWK_KEY_TIMEOUT",
          value: "0x39",
          description: "Configure the timeout to wait for the network key before
                        failing a join. Acceptable timeout range [3,255]. Value
                        is in seconds.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_FORCE_TX_AFTER_FAILED_CCA_ATTEMPTS",
          value: "0x3A",
          description: "The number of failed CSMA attempts due to failed CCA made by the MAC before
                        continuing transmission with CCA disabled.  This is the same as calling the
                        sli_zigbee_stack_force_tx_after_failed_cca(uint8_t csmaAttempts) API. A value of 0
                        disables the feature."
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_TRANSIENT_KEY_TIMEOUT_S",
          value: "0x3B",
          description: "The length of time, in seconds, that a trust center will
                        store a transient link key that a device can use
                        to join its network. A transient key is added with a call
                        to sli_zigbee_stack_sec_man_import_transient_key. After the transient key is
                        added, it will be removed once this amount of time has
                        passed. A joining device will not be able to use that
                        key to join until it is added again on the trust center.
                        The default value is 300 seconds (5 minutes)."
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_COULOMB_COUNTER_USAGE",
          value: "0x3C",
          description: "Cumulative energy usage metric since the last value reset of the coulomb counter plugin. Setting this value will reset the coulomb counter.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_MAX_BEACONS_TO_STORE",
          value: "0x3D",
          description: "When scanning, configure the maximum number of beacons
          to store in cache. Each beacon consumes on average 32-bytes (+ buffer overhead) in RAM.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_END_DEVICE_TIMEOUT_OPTIONS_MASK",
          value: "0x3E",
          description: "Set the mask to filter out unacceptable child timeout options on a router.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_END_DEVICE_KEEP_ALIVE_SUPPORT_MODE",
          value: "0x3F",
          description: "The end device keep-alive mode supported by the parent.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_ACTIVE_RADIO_CONFIG",
          value: "0x41",
          description: "Return the active radio config. Read only. Values are
                        0: Default, 1: Antenna Diversity, 2: Co-Existence,
                        3: Antenna Diversity and Co-Existence.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_NWK_OPEN_DURATION",
          value: "0x42",
          description: "Return the number of seconds the network will remain open.
                        A return value of 0 indicates that the network is closed.
                        Read only.",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_TRANSIENT_DEVICE_TIMEOUT",
          value: "0x43",
          description: "Timeout in milliseconds to store entries in the transient device
                        table. If the devices are not authenticated before the timeout, 
                        the entry shall be purged",
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_KEY_STORAGE_VERSION",
          value: "0x44",
          description: "Return information about the key storage on an NCP.  Returns 0
                        if keys are in classic key storage, and 1 if they are located in
                        PSA key storage. Read only."
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_DELAYED_JOIN_ACTIVATION",
          value: "0x45",
          description: "Return activation state about TC Delayed Join on an NCP.  A return value of 0
                        indicates that the feature is not activated."
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_MAX_NWK_RETRIES",
          value: "0x46",
          description: "The maximum number of NWK retries that will be attempted."
        },
        {
          name: "SL_ZIGBEE_EZSP_VALUE_REJOIN_MODE",
          value: "0x47",
          description: "Policies for allowing/disallowing rejoins."
        }
      ],
    },
    {
      name: "sl_zigbee_ezsp_extended_value_id_t",
      type: "uint8_t",
      description: "Identifies a value based on specified
                    characteristics. Each set of characteristics is
                    unique to that value and is specified during the
                    call to get the extended value.",
      items: [
        {
          name: "SL_ZIGBEE_EZSP_EXTENDED_VALUE_ENDPOINT_FLAGS",
          value: "0x00",
          description: "The flags field associated with the specified
                        endpoint.",
        },
        {
          name: "SL_ZIGBEE_EZSP_EXTENDED_VALUE_LAST_LEAVE_REASON",
          value: "0x01",
          description: "This is the reason for the node to leave the
                        network as well as the device that told it to
                        leave. The leave reason is the 1st byte of the
                        value while the node ID is the 2nd and 3rd
                        byte. If the leave was caused due to an API
                        call rather than an over the air message, the
                        node ID will be SL_ZIGBEE_UNKNOWN_NODE_ID (0xFFFD).",
        },
        {
          name: "SL_ZIGBEE_EZSP_EXTENDED_VALUE_GET_SOURCE_ROUTE_OVERHEAD",
          value: "0x02",
          description: "This number of bytes of overhead required in
                        the network frame for source routing to a
                        particular destination.",
        },
      ],
    },
    {
      name: "sl_zigbee_ezsp_endpoint_flags_t",
      type: "uint16_t",
      description: "Flags associated with the endpoint data configured
                    on the NCP.",
      items: [
        {
          name: "SL_ZIGBEE_EZSP_ENDPOINT_DISABLED",
          value: "0x00",
          description: "Indicates that the endpoint is disabled and NOT
                        discoverable via ZDO.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ENDPOINT_ENABLED",
          value: "0x01",
          description: "Indicates that the endpoint is enabled and
                        discoverable via ZDO.",
        },
      ],
    },
    {
      name: "EmberConfigTxPowerMode",
      type: "uint16_t",
      description: "Values for SL_ZIGBEE_EZSP_CONFIG_TX_POWER_MODE.",
      items: [
        {
          name: "SL_ZIGBEE_TX_POWER_MODE_DEFAULT",
          value: "0x00",
          description: "Normal power mode and bi-directional RF
                        transmitter output.",
        },
        {
          name: "SL_ZIGBEE_TX_POWER_MODE_BOOST",
          value: "0x01",
          description: "Enable boost power mode. This is a high-performance
                        radio mode which offers increased receive
                        sensitivity and transmit power at the
                        cost of an increase in power consumption.",
        },
        {
          name: "SL_ZIGBEE_TX_POWER_MODE_ALTERNATE",
          value: "0x02",
          description: "Enable the alternate transmitter output. This
                        allows for simplified connection to an external
                        power amplifier via the RF_TX_ALT_P and
                        RF_TX_ALT_N pins.",
        },
        {
          name: "SL_ZIGBEE_TX_POWER_MODE_BOOST_AND_ALTERNATE",
          value: "0x03",
          description: "Enable both boost mode and the alternate
                        transmitter output.",
        },
      ],
    },
    {
      name: "sl_zigbee_ezsp_policy_id_t",
      type: "uint8_t",
      description: "Identifies a policy.",
      items: [
        {
          name: "SL_ZIGBEE_EZSP_TRUST_CENTER_POLICY",
          value: "0x00",
          description: "Controls trust center behavior.",
        },
        {
          name: "SL_ZIGBEE_EZSP_BINDING_MODIFICATION_POLICY",
          value: "0x01",
          description: "Controls how external binding modification
                        requests are handled.",
        },
        {
          name: "SL_ZIGBEE_EZSP_UNICAST_REPLIES_POLICY",
          value: "0x02",
          description: "Controls whether the Host supplies unicast
                        replies.",
        },
        {
          name: "SL_ZIGBEE_EZSP_POLL_HANDLER_POLICY",
          value: "0x03",
          description: "Controls whether pollHandler callbacks are
                        generated.",
        },
        {
          name: "SL_ZIGBEE_EZSP_MESSAGE_CONTENTS_IN_CALLBACK_POLICY",
          value: "0x04",
          description: "Controls whether the message contents are
                        included in the messageSentHandler callback.",
        },
        {
          name: "SL_ZIGBEE_EZSP_TC_KEY_REQUEST_POLICY",
          value: "0x05",
          description: "Controls whether the Trust Center will respond
                        to Trust Center link key requests.",
        },
        {
          name: "SL_ZIGBEE_EZSP_APP_KEY_REQUEST_POLICY",
          value: "0x06",
          description: "Controls whether the Trust Center will respond
                        to application link key requests.",
        },
        {
          name: "SL_ZIGBEE_EZSP_PACKET_VALIDATE_LIBRARY_POLICY",
          value: "0x07",
          description: "Controls whether ZigBee packets that appear
                        invalid are automatically dropped by the stack.
                        A counter will be incremented when this occurs.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ZLL_POLICY",
          value: "0x08",
          description: "Controls whether the stack will process ZLL
                        messages.",
        },
        {
          name: "SL_ZIGBEE_EZSP_TC_REJOINS_USING_WELL_KNOWN_KEY_POLICY",
          value: "0x09",
          description: "Controls whether Trust Center (insecure) rejoins for
                        devices using the well-known link key are accepted. If
                        rejoining using the well-known key is allowed, it is
                        disabled again after
                        sli_zigbee_allow_tc_rejoins_using_well_known_key_timeout_sec seconds.",
        },
      ],
    },
    {
      name: "sl_zigbee_ezsp_decision_bitmask_t",
      type: "uint16_t",
      description: "This is the policy decision bitmask that controls
                    the trust center decision strategies. The bitmask
                    is modified and extracted from the sl_zigbee_ezsp_decision_id_t
                    for supporting bitmask operations.",
      items: [
        {
          name: "SL_ZIGBEE_EZSP_DECISION_BITMASK_DEFAULT_CONFIGURATION",
          value: "0x0000",
          description: "Disallow joins and rejoins.",
        },
        {
          name: "SL_ZIGBEE_EZSP_DECISION_ALLOW_JOINS",
          value: "0x0001",
          description: "Send the network key to all joining devices.",
        },
        {
          name: "SL_ZIGBEE_EZSP_DECISION_ALLOW_UNSECURED_REJOINS",
          value: "0x0002",
          description: "Send the network key to all rejoining devices.",
        },
        {
          name: "SL_ZIGBEE_EZSP_DECISION_SEND_KEY_IN_CLEAR",
          value: "0x0004",
          description: "Send the network key in the clear.",
        },
        {
          name: "SL_ZIGBEE_EZSP_DECISION_IGNORE_UNSECURED_REJOINS",
          value: "0x0008",
          description: "Do nothing for unsecured rejoins.",
        },
        {
          name: "SL_ZIGBEE_EZSP_DECISION_JOINS_USE_INSTALL_CODE_KEY",
          value: "0x0010",
          description: "Allow joins if there is an entry in the transient key table.",
        },
        {
          name: "SL_ZIGBEE_EZSP_DECISION_DEFER_JOINS",
          value: "0x0020",
          description: "Delay sending the network key to a new joining device.",
        },
      ],
    },
    {
      name: "sl_zigbee_ezsp_decision_id_t",
      type: "uint8_t",
      description: "Identifies a policy decision.",
      items: [
        {
          name: "SL_ZIGBEE_EZSP_DISALLOW_BINDING_MODIFICATION",
          value: "0x10",
          description: "SL_ZIGBEE_EZSP_BINDING_MODIFICATION_POLICY default decision.
                        Do not allow the local binding table to be
                        changed by remote nodes.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ALLOW_BINDING_MODIFICATION",
          value: "0x11",
          description: "SL_ZIGBEE_EZSP_BINDING_MODIFICATION_POLICY decision. Allow
                        remote nodes to change the local binding table.",
        },
        {
          name: "SL_ZIGBEE_EZSP_CHECK_BINDING_MODIFICATIONS_ARE_VALID_ENDPOINT_CLUSTERS",
          value: "0x12",
          description: "SL_ZIGBEE_EZSP_BINDING_MODIFICATION_POLICY decision. Allows
                        remote nodes to set local binding entries only
                        if the entries correspond to endpoints defined
                        on the device, and for output clusters bound to
                        those endpoints.",
        },
        {
          name: "SL_ZIGBEE_EZSP_HOST_WILL_NOT_SUPPLY_REPLY",
          value: "0x20",
          description: "SL_ZIGBEE_EZSP_UNICAST_REPLIES_POLICY default decision. The
                        NCP will automatically send an empty reply
                        (containing no payload) for every unicast
                        received.",
        },
        {
          name: "SL_ZIGBEE_EZSP_HOST_WILL_SUPPLY_REPLY",
          value: "0x21",
          description: "SL_ZIGBEE_EZSP_UNICAST_REPLIES_POLICY decision. The NCP will
                        only send a reply if it receives a sendReply
                        command from the Host.",
        },
        {
          name: "SL_ZIGBEE_EZSP_POLL_HANDLER_IGNORE",
          value: "0x30",
          description: "SL_ZIGBEE_EZSP_POLL_HANDLER_POLICY default decision. Do not
                        inform the Host when a child polls.",
        },
        {
          name: "SL_ZIGBEE_EZSP_POLL_HANDLER_CALLBACK",
          value: "0x31",
          description: "SL_ZIGBEE_EZSP_POLL_HANDLER_POLICY decision. Generate a
                        pollHandler callback when a child polls.",
        },
        {
          name: "SL_ZIGBEE_EZSP_MESSAGE_TAG_ONLY_IN_CALLBACK",
          value: "0x40",
          description: "SL_ZIGBEE_EZSP_MESSAGE_CONTENTS_IN_CALLBACK_POLICY default
                        decision. Include only the message tag in the
                        messageSentHandler callback.",
        },
        {
          name: "SL_ZIGBEE_EZSP_MESSAGE_TAG_AND_CONTENTS_IN_CALLBACK",
          value: "0x41",
          description: "SL_ZIGBEE_EZSP_MESSAGE_CONTENTS_IN_CALLBACK_POLICY decision.
                        Include both the message tag and the message
                        contents in the messageSentHandler callback.",
        },
        {
          name: "SL_ZIGBEE_EZSP_DENY_TC_KEY_REQUESTS",
          value: "0x50",
          description: "SL_ZIGBEE_EZSP_TC_KEY_REQUEST_POLICY decision. When the
                        Trust Center receives a request for a Trust
                        Center link key, it will be ignored.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ALLOW_TC_KEY_REQUESTS_AND_SEND_CURRENT_KEY",
          value: "0x51",
          description: "SL_ZIGBEE_EZSP_TC_KEY_REQUEST_POLICY decision. When the
                        Trust Center receives a request for a Trust
                        Center link key, it will reply to it with the
                        corresponding key.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ALLOW_TC_KEY_REQUEST_AND_GENERATE_NEW_KEY",
          value: "0x52",
          description: "SL_ZIGBEE_EZSP_TC_KEY_REQUEST_POLICY decision. When the
                        Trust Center receives a request for a Trust
                        Center link key, it will generate a key to
                        send to the joiner. After generation, the key
                        will be added to the transient key tabe and
                        After verification, this key will be added
                        into the link key table",
        },
        {
          name: "SL_ZIGBEE_EZSP_DENY_APP_KEY_REQUESTS",
          value: "0x60",
          description: "SL_ZIGBEE_EZSP_APP_KEY_REQUEST_POLICY decision. When the
                        Trust Center receives a request for an
                        application link key, it will be ignored.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ALLOW_APP_KEY_REQUESTS",
          value: "0x61",
          description: "SL_ZIGBEE_EZSP_APP_KEY_REQUEST_POLICY decision. When the
                        Trust Center receives a request for an
                        application link key, it will randomly generate
                        a key and send it to both partners.",
        },
        {
          name: "SL_ZIGBEE_EZSP_PACKET_VALIDATE_LIBRARY_CHECKS_ENABLED",
          value: "0x62",
          description: "Indicates that packet validate library checks
                        are enabled on the NCP.",
        },
        {
          name: "SL_ZIGBEE_EZSP_PACKET_VALIDATE_LIBRARY_CHECKS_DISABLED",
          value: "0x63",
          description: "Indicates that packet validate library checks
                        are NOT enabled on the NCP.",
        },
      ],
    },
    {
      name: "sl_zigbee_ezsp_mfg_token_id_t",
      type: "uint8_t",
      description: "Manufacturing token IDs used by sl_zigbee_ezsp_get_mfg_token().",
      items: [
        {
          name: "SL_ZIGBEE_EZSP_MFG_CUSTOM_VERSION",
          value: "0x00",
          description: "Custom version (2 bytes).",
        },
        {
          name: "SL_ZIGBEE_EZSP_MFG_STRING",
          value: "0x01",
          description: "Manufacturing string (16 bytes).",
        },
        {
          name: "SL_ZIGBEE_EZSP_MFG_BOARD_NAME",
          value: "0x02",
          description: "Board name (16 bytes).",
        },
        {
          name: "SL_ZIGBEE_EZSP_MFG_MANUF_ID",
          value: "0x03",
          description: "Manufacturing ID (2 bytes).",
        },
        {
          name: "SL_ZIGBEE_EZSP_MFG_PHY_CONFIG",
          value: "0x04",
          description: "Radio configuration (2 bytes).",
        },
        {
          name: "SL_ZIGBEE_EZSP_MFG_BOOTLOAD_AES_KEY",
          value: "0x05",
          description: "Bootload AES key (16 bytes).",
        },
        {
          name: "SL_ZIGBEE_EZSP_MFG_ASH_CONFIG",
          value: "0x06",
          description: "ASH configuration (40 bytes).",
        },
        {
          name: "SL_ZIGBEE_EZSP_MFG_SL_ZIGBEE_EZSP_STORAGE",
          value: "0x07",
          description: "EZSP storage (8 bytes).",
        },
        {
          name: "SL_ZIGBEE_EZSP_STACK_CAL_DATA",
          value: "0x08",
          description: "Radio calibration data (64 bytes). 4 bytes are
                        stored for each of the 16 channels. This token
                        is not stored in the Flash Information Area. It
                        is updated by the stack each time a calibration
                        is performed.",
        },
        {
          name: "SL_ZIGBEE_EZSP_MFG_CBKE_DATA",
          value: "0x09",
          description: "Certificate Based Key Exchange (CBKE) data (92
                        bytes).",
        },
        {
          name: "SL_ZIGBEE_EZSP_MFG_INSTALLATION_CODE",
          value: "0x0A",
          description: "Installation code (20 bytes).",
        },
        {
          name: "SL_ZIGBEE_EZSP_STACK_CAL_FILTER",
          value: "0x0B",
          description: "Radio channel filter calibration data (1 byte).
                        This token is not stored in the Flash
                        Information Area. It is updated by the stack
                        each time a calibration is performed.",
        },
        {
          name: "SL_ZIGBEE_EZSP_MFG_CUSTOM_EUI_64",
          value: "0x0C",
          description: "Custom EUI64 MAC address (8 bytes).",
        },
        {
          name: "SL_ZIGBEE_EZSP_MFG_CTUNE",
          value: "0x0D",
          description: "CTUNE value (2 byte).",
        },
      ],
    },
    {
      name: "sl_zigbee_ezsp_status_t",
      type: "uint8_t",
      description: "Status values used by EZSP.",
      items: [
        {
          name: "SL_ZIGBEE_EZSP_SUCCESS",
          value: "0x00",
          description: "Success.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_FATAL",
          value: "0x10",
          description: "Fatal error.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_NCP_RESET",
          value: "0x11",
          description: "The Response frame of the current transaction
                        indicates the NCP has reset.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_OVERSIZED_SL_ZIGBEE_EZSP_FRAME",
          value: "0x12",
          description: "The NCP is reporting that the Command frame of
                        the current transaction is oversized (the length
                        byte is too large).",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_ABORTED_TRANSACTION",
          value: "0x13",
          description: "The Response frame of the current transaction
                        indicates the previous transaction was aborted
                        (nSSEL deasserted too soon).",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_MISSING_FRAME_TERMINATOR",
          value: "0x14",
          description: "The Response frame of the current transaction
                        indicates the frame terminator is missing from
                        the Command frame.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_WAIT_SECTION_TIMEOUT",
          value: "0x15",
          description: "The NCP has not provided a Response within the
                        time limit defined by WAIT_SECTION_TIMEOUT.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_NO_FRAME_TERMINATOR",
          value: "0x16",
          description: "The Response frame from the NCP is missing the
                        frame terminator.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_SL_ZIGBEE_EZSP_COMMAND_OVERSIZED",
          value: "0x17",
          description: "The Host attempted to send an oversized Command
                        (the length byte is too large) and the AVR's
                        spi-protocol.c blocked the transmission.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_SL_ZIGBEE_EZSP_RESPONSE_OVERSIZED",
          value: "0x18",
          description: "The NCP attempted to send an oversized Response
                        (the length byte is too large) and the AVR's
                        spi-protocol.c blocked the reception.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_WAITING_FOR_RESPONSE",
          value: "0x19",
          description: "The Host has sent the Command and is still
                        waiting for the NCP to send a Response.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_HANDSHAKE_TIMEOUT",
          value: "0x1A",
          description: "The NCP has not asserted nHOST_INT within the
                        time limit defined by WAKE_HANDSHAKE_TIMEOUT.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_STARTUP_TIMEOUT",
          value: "0x1B",
          description: "The NCP has not asserted nHOST_INT after an
                        NCP reset within the time limit defined by
                        STARTUP_TIMEOUT.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_STARTUP_FAIL",
          value: "0x1C",
          description: "The Host attempted to verify the SPI Protocol
                        activity and version number, and the verification
                        failed.",
        },
        {
          name: "SL_ZIGBEE_EZSP_SPI_ERR_UNSUPPORTED_SPI_COMMAND",
          value: "0x1D",
          description: "The Host has sent a command with a SPI Byte
                        that is unsupported by the current mode the NCP
                        is operating in.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_IN_PROGRESS",
          value: "0x20",
          description: "Operation not yet complete.",
        },
        {
          name: "SL_ZIGBEE_EZSP_HOST_FATAL_ERROR",
          value: "0x21",
          description: "Fatal error detected by host.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_NCP_FATAL_ERROR",
          value: "0x22",
          description: "Fatal error detected by NCP.",
        },
        {
          name: "SL_ZIGBEE_EZSP_DATA_FRAME_TOO_LONG",
          value: "0x23",
          description: "Tried to send DATA frame too long.",
        },
        {
          name: "SL_ZIGBEE_EZSP_DATA_FRAME_TOO_SHORT",
          value: "0x24",
          description: "Tried to send DATA frame too short.",
        },
        {
          name: "SL_ZIGBEE_EZSP_NO_TX_SPACE",
          value: "0x25",
          description: "No space for tx'ed DATA frame.",
        },
        {
          name: "SL_ZIGBEE_EZSP_NO_RX_SPACE",
          value: "0x26",
          description: "No space for rec'd DATA frame.",
        },
        {
          name: "SL_ZIGBEE_EZSP_NO_RX_DATA",
          value: "0x27",
          description: "No receive data available.",
        },
        {
          name: "SL_ZIGBEE_EZSP_NOT_CONNECTED",
          value: "0x28",
          description: "Not in Connected state.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_VERSION_NOT_SET",
          value: "0x30",
          description: "The NCP received a command before the EZSP
                        version had been set.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_INVALID_FRAME_ID",
          value: "0x31",
          description: "The NCP received a command containing an
                        unsupported frame ID.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_WRONG_DIRECTION",
          value: "0x32",
          description: "The direction flag in the frame control field
                        was incorrect.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_TRUNCATED",
          value: "0x33",
          description: "The truncated flag in the frame control field
                        was set, indicating there was not enough memory
                        available to complete the response or that the
                        response would have exceeded the maximum EZSP
                        frame length.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_OVERFLOW",
          value: "0x34",
          description: "The overflow flag in the frame control field
                        was set, indicating one or more callbacks
                        occurred since the previous response and there
                        was not enough memory available to report them
                        to the Host.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_OUT_OF_MEMORY",
          value: "0x35",
          description: "Insufficient memory was available.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_INVALID_VALUE",
          value: "0x36",
          description: "The value was out of bounds.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_INVALID_ID",
          value: "0x37",
          description: "The configuration id was not recognized.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_INVALID_CALL",
          value: "0x38",
          description: "Configuration values can no longer be modified.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_NO_RESPONSE",
          value: "0x39",
          description: "The NCP failed to respond to a command.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_COMMAND_TOO_LONG",
          value: "0x40",
          description: "The length of the command exceeded the maximum
                        EZSP frame length.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_QUEUE_FULL",
          value: "0x41",
          description: "The UART receive queue was full causing a
                        callback response to be dropped.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_COMMAND_FILTERED",
          value: "0x42",
          description: "The command has been filtered out by NCP.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_SECURITY_KEY_ALREADY_SET",
          value: "0x43",
          description: "EZSP Security Key is already set",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_SECURITY_TYPE_INVALID",
          value: "0x44",
          description: "EZSP Security Type is invalid",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_SECURITY_PARAMETERS_INVALID",
          value: "0x45",
          description: "EZSP Security Parameters are invalid",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_SECURITY_PARAMETERS_ALREADY_SET",
          value: "0x46",
          description: "EZSP Security Parameters are already set",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_SECURITY_KEY_NOT_SET",
          value: "0x47",
          description: "EZSP Security Key is not set",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_SECURITY_PARAMETERS_NOT_SET",
          value: "0x48",
          description: "EZSP Security Parameters are not set",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_UNSUPPORTED_CONTROL",
          value: "0x49",
          description: "Received frame with unsupported control byte",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_UNSECURE_FRAME",
          value: "0x4A",
          description: "Received frame is unsecure, when security is established",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_ERROR_VERSION",
          value: "0x50",
          description: "Incompatible ASH version",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_ERROR_TIMEOUTS",
          value: "0x51",
          description: "Exceeded max ACK timeouts",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_ERROR_RESET_FAIL",
          value: "0x52",
          description: "Timed out waiting for RSTACK",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_ERROR_NCP_RESET",
          value: "0x53",
          description: "Unexpected ncp reset",
        },
        {
          name: "SL_ZIGBEE_EZSP_ERROR_SERIAL_INIT",
          value: "0x54",
          description: "Serial port initialization failed",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_ERROR_NCP_TYPE",
          value: "0x55",
          description: "Invalid ncp processor type",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_ERROR_RESET_METHOD",
          value: "0x56",
          description: "Invalid ncp reset method",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_ERROR_XON_XOFF",
          value: "0x57",
          description: "XON/XOFF not supported by host driver",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_STARTED",
          value: "0x70",
          description: "ASH protocol started",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_CONNECTED",
          value: "0x71",
          description: "ASH protocol connected",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_DISCONNECTED",
          value: "0x72",
          description: "ASH protocol disconnected",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_ACK_TIMEOUT",
          value: "0x73",
          description: "Timer expired waiting for ack",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_CANCELLED",
          value: "0x74",
          description: "Frame in progress cancelled",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_OUT_OF_SEQUENCE",
          value: "0x75",
          description: "Received frame out of sequence",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_BAD_CRC",
          value: "0x76",
          description: "Received frame with CRC error",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_COMM_ERROR",
          value: "0x77",
          description: "Received frame with comm error",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_BAD_ACKNUM",
          value: "0x78",
          description: "Received frame with bad ackNum",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_TOO_SHORT",
          value: "0x79",
          description: "Received frame shorter than minimum",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_TOO_LONG",
          value: "0x7A",
          description: "Received frame longer than maximum",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_BAD_CONTROL",
          value: "0x7B",
          description: "Received frame with illegal control byte",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_BAD_LENGTH",
          value: "0x7C",
          description: "Received frame with illegal length for its type",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_ACK_RECEIVED",
          value: "0x7D",
          description: "Received ASH Ack",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_ACK_SENT",
          value: "0x7E",
          description: "Sent ASH Ack",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_NAK_RECEIVED",
          value: "0x7F",
          description: "Received ASH Nak",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_NAK_SENT",
          value: "0x80",
          description: "Sent ASH Nak",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_RST_RECEIVED",
          value: "0x81",
          description: "Received ASH RST",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_RST_SENT",
          value: "0x82",
          description: "Sent ASH RST",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_STATUS",
          value: "0x83",
          description: "ASH Status",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_TX",
          value: "0x84",
          description: "ASH TX",
        },
        {
          name: "SL_ZIGBEE_EZSP_ASH_RX",
          value: "0x85",
          description: "ASH RX",
        },
        {
          name: "SL_ZIGBEE_EZSP_CPC_ERROR_INIT",
          value: "0x86",
          description: "Failed to connect to CPC daemon or failed to open CPC endpoint",
        },
        {
          name: "SL_ZIGBEE_EZSP_NO_ERROR",
          value: "0xFF",
          description: "No reset or error",
        },
      ],
    },
    {
      name: "sl_zigbee_af_status_t",
      type: "uint8_t",
      description: "A ZCL status. See relevant header files for enumeration and
                    possible values.",
      items: [
      ],
    },
    {
      name: "sl_zigbee_event_units_t",
      type: "uint8_t",
      description: "Either marks an event as inactive or specifies the
                    units for the event execution time.",
      items: [
        {
          name: "SL_ZIGBEE_EVENT_INACTIVE",
          value: "0x00",
          description: "The event is not scheduled to run.",
        },
        {
          name: "SL_ZIGBEE_EVENT_MS_TIME",
          value: "0x01",
          description: "The execution time is in approximate
                        milliseconds.",
        },
        {
          name: "SL_ZIGBEE_EVENT_QS_TIME",
          value: "0x02",
          description: "The execution time is in 'binary' quarter
                        seconds (256 approximate milliseconds each).",
        },
        {
          name: "SL_ZIGBEE_EVENT_MINUTE_TIME",
          value: "0x03",
          description: "The execution time is in 'binary' minutes
                        (65536 approximate milliseconds each).",
        },
      ],
    },
    {
      name: "sl_zigbee_node_type_t",
      type: "uint8_t",
      description: "The type of the node.",
      items: [
        {
          name: "SL_ZIGBEE_UNKNOWN_DEVICE",
          value: "0x00",
          description: "Device is not joined.",
        },
                {
          name: "SL_ZIGBEE_DEVICE_TYPE_UNCHANGED",
          value: "0x00",
          description: "Device type has not changed since last join.",
        },
        {
          name: "SL_ZIGBEE_COORDINATOR",
          value: "0x01",
          description: "Will relay messages and can act as a parent
                        to other nodes.",
        },
        {
          name: "SL_ZIGBEE_ROUTER",
          value: "0x02",
          description: "Will relay messages and can act as a parent
                        to other nodes.",
        },
        {
          name: "SL_ZIGBEE_END_DEVICE",
          value: "0x03",
          description: "Communicates only with its parent and will not
                        relay messages.",
        },
        {
          name: "SL_ZIGBEE_SLEEPY_END_DEVICE",
          value: "0x04",
          description: "An end device whose radio can be turned off
                        to save power. The application must poll to
                        receive messages.",
        },
      ],
    },
    {
      name: "sl_zigbee_network_status_t",
      type: "uint8_t",
      description: "The possible join states for a node.",
      items: [
        {
          name: "SL_ZIGBEE_NO_NETWORK",
          value: "0x00",
          description: "The node is not associated with a network in
                        any way.",
        },
        {
          name: "SL_ZIGBEE_JOINING_NETWORK",
          value: "0x01",
          description: "The node is currently attempting to join a
                        network.",
        },
        {
          name: "SL_ZIGBEE_JOINED_NETWORK",
          value: "0x02",
          description: "The node is joined to a network.",
        },
        {
          name: "SL_ZIGBEE_JOINED_NETWORK_NO_PARENT",
          value: "0x03",
          description: "The node is an end device joined to a network
                        but its parent is not responding.",
        },
        {
          name: "SL_ZIGBEE_LEAVING_NETWORK",
          value: "0x04",
          description: "The node is in the process of leaving its
                        current network.",
        },
      ],
    },
    {
      name: "sl_zigbee_incoming_message_type_t",
      type: "uint8_t",
      description: "Incoming message types.",
      items: [
        {
          name: "SL_ZIGBEE_INCOMING_UNICAST",
          value: "0x00",
          description: "Unicast.",
        },
        {
          name: "SL_ZIGBEE_INCOMING_UNICAST_REPLY",
          value: "0x01",
          description: "Unicast reply.",
        },
        {
          name: "SL_ZIGBEE_INCOMING_MULTICAST",
          value: "0x02",
          description: "Multicast.",
        },
        {
          name: "SL_ZIGBEE_INCOMING_MULTICAST_LOOPBACK",
          value: "0x03",
          description: "Multicast sent by the local device.",
        },
        {
          name: "SL_ZIGBEE_INCOMING_BROADCAST",
          value: "0x04",
          description: "Broadcast.",
        },
        {
          name: "SL_ZIGBEE_INCOMING_BROADCAST_LOOPBACK",
          value: "0x05",
          description: "Broadcast sent by the local device.",
        },
        {
          name: "EMBER_INCOMING_MANY_TO_ONE_ROUTE_REQUEST",
          value: "0x06",
          description: "Many to one route request.",
        },
      ],
    },
    {
      name: "sl_zigbee_outgoing_message_type_t",
      type: "uint8_t",
      description: "Outgoing message types.",
      items: [
        {
          name: "SL_ZIGBEE_OUTGOING_DIRECT",
          value: "0x00",
          description: "Unicast sent directly to an sl_802154_short_addr_t.",
        },
        {
          name: "SL_ZIGBEE_OUTGOING_VIA_ADDRESS_TABLE",
          value: "0x01",
          description: "Unicast sent using an entry in the address
                        table.",
        },
        {
          name: "SL_ZIGBEE_OUTGOING_VIA_BINDING",
          value: "0x02",
          description: "Unicast sent using an entry in the binding
                        table.",
        },
        {
          name: "SL_ZIGBEE_OUTGOING_MULTICAST",
          value: "0x03",
          description: "Multicast message. This value is passed to
                        sli_zigbee_stack_message_sent_handler() only. It may not be
                        passed to sli_zigbee_stack_send_unicast().",
        },
        {
          name: "SL_ZIGBEE_OUTGOING_BROADCAST",
          value: "0x04",
          description: "Broadcast message. This value is passed to
                        sli_zigbee_stack_message_sent_handler() only. It may not be
                        passed to sli_zigbee_stack_send_unicast().",
        },
      ],
    },
    {
      name: "sl_zigbee_mac_passthrough_type_t",
      type: "uint8_t",
      description: "MAC passthrough message type flags.",
      items: [
        {
          name: "SL_802154_PASSTHROUGH_NONE",
          value: "0x00",
          description: "No MAC passthrough messages.",
        },
        {
          name: "SL_802154_PASSTHROUGH_SE_INTERPAN",
          value: "0x01",
          description: "SE InterPAN messages.",
        },
        {
          name: "SL_802154_PASSTHROUGH_EMBERNET",
          value: "0x02",
          description: "Legacy EmberNet messages.",
        },
        {
          name: "SL_802154_PASSTHROUGH_EMBERNET_SOURCE",
          value: "0x04",
          description: "Legacy EmberNet messages filtered by their
                        source address.",
        },
      ],
    },
    {
      name: "sl_zigbee_binding_type_t",
      type: "uint8_t",
      description: "Binding types.",
      items: [
        {
          name: "SL_ZIGBEE_UNUSED_BINDING",
          value: "0x00",
          description: "A binding that is currently not in use.",
        },
        {
          name: "SL_ZIGBEE_UNICAST_BINDING",
          value: "0x01",
          description: "A unicast binding whose 64-bit identifier is
                        the destination EUI64.",
        },
        {
          name: "SL_ZIGBEE_MANY_TO_ONE_BINDING",
          value: "0x02",
          description: "A unicast binding whose 64-bit identifier is
                        the aggregator EUI64.",
        },
        {
          name: "SL_ZIGBEE_MULTICAST_BINDING",
          value: "0x03",
          description: "A multicast binding whose 64-bit identifier is
                        the group address. A multicast binding can be
                        used to send messages to the group and to
                        receive messages sent to the group.",
        },
      ],
    },
    {
      name: "sl_zigbee_aps_option_t",
      type: "uint16_t",
      description: "Options to use when sending a message.",
      items: [
        {
          name: "SL_ZIGBEE_APS_OPTION_NONE",
          value: "0x0000",
          description: "No options.",
        },
        {
          name: "SL_ZIGBEE_APS_OPTION_ENCRYPTION",
          value: "0x0020",
          description: "Send the message using APS Encryption, using
                        the Link Key shared with the destination node
                        to encrypt the data at the APS Level.",
        },
        {
          name: "SL_ZIGBEE_APS_OPTION_RETRY",
          value: "0x0040",
          description: "Resend the message using the APS retry
                        mechanism.",
        },
        {
          name: "SL_ZIGBEE_APS_OPTION_ENABLE_ROUTE_DISCOVERY",
          value: "0x0100",
          description: "Causes a route discovery to be initiated if no
                        route to the destination is known.",
        },
        {
          name: "SL_ZIGBEE_APS_OPTION_FORCE_ROUTE_DISCOVERY",
          value: "0x0200",
          description: "Causes a route discovery to be initiated even
                        if one is known.",
        },
        {
          name: "SL_ZIGBEE_APS_OPTION_SOURCE_EUI64",
          value: "0x0400",
          description: "Include the source EUI64 in the network frame.",
        },
        {
          name: "SL_ZIGBEE_APS_OPTION_DESTINATION_EUI64",
          value: "0x0800",
          description: "Include the destination EUI64 in the network
                        frame.",
        },
        {
          name: "SL_ZIGBEE_APS_OPTION_ENABLE_ADDRESS_DISCOVERY",
          value: "0x1000",
          description: "Send a ZDO request to discover the node ID of
                        the destination, if it is not already know.",
        },
        {
          name: "SL_ZIGBEE_APS_OPTION_POLL_RESPONSE",
          value: "0x2000",
          description: "Reserved.",
        },
        {
          name: "SL_ZIGBEE_APS_OPTION_ZDO_RESPONSE_REQUIRED",
          value: "0x4000",
          description: "This incoming message is a ZDO request not
                        handled by the EmberZNet stack, and the
                        application is responsible for sending a ZDO
                        response. This flag is used only when the ZDO
                        is configured to have requests handled by the
                        application. See the
                        EZSP_CONFIG_APPLICATION_ZDO_CONFIGURATION
                        configuration parameter for more information.",
        },
        {
          name: "SL_ZIGBEE_APS_OPTION_FRAGMENT",
          value: "0x8000",
          description: "This message is part of a fragmented message.
                        This option may only be set for unicasts. The
                        groupId field gives the index of this fragment
                        in the low-order byte. If the low-order byte is
                        zero this is the first fragment and the
                        high-order byte contains the number of fragments
                        in the message.",
        },
      ],
    },
    {
      name: "sl_zigbee_ezsp_network_scan_type_t",
      type: "uint8_t",
      description: "Network scan types.",
      items: [
        {
          name: "SL_ZIGBEE_EZSP_ENERGY_SCAN",
          value: "0x00",
          description: "An energy scan scans each channel for its RSSI
                        value.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ACTIVE_SCAN",
          value: "0x01",
          description: "An active scan scans each channel for available
                        networks.",
        },
      ],
    },
    {
      name: "sl_zigbee_join_decision_t",
      type: "uint8_t",
      description: "Decision made by the trust center when a node
                    attempts to join.",
      items: [
        {
          name: "SL_ZIGBEE_USE_PRECONFIGURED_KEY",
          value: "0x00",
          description: "Allow the node to join. The joining node
                        should have a pre-configured key. The security
                        data sent to it will be encrypted with that
                        key.",
        },
        {
          name: "SL_ZIGBEE_SEND_KEY_IN_THE_CLEAR",
          value: "0x01",
          description: "Allow the node to join. Send the network key
                        in-the-clear to the joining device.",
        },
        {
          name: "SL_ZIGBEE_DENY_JOIN",
          value: "0x02",
          description: "Deny join.",
        },
        {
          name: "SL_ZIGBEE_NO_ACTION",
          value: "0x03",
          description: "Take no action.",
        },
      ],
    },
    {
      name: "sl_zigbee_leave_network_option_t",
      type: "uint8_t",
      description: "Use in case zigbee leave network with options",
      items: [
        {
          name: "SL_ZIGBEE_LEAVE_NWK_WITH_NO_OPTION",
          value: "0x00",
          description: "Leave with no option.",
        },
        {
          name: "SL_ZIGBEE_LEAVE_NWK_WITH_OPTION_REJOIN",
          value: "0x20",
          description: "Leave with option rejoin.",
        },
        {
          name: "SL_ZIGBEE_LEAVE_NWK_IS_REQUESTED",
          value: "0x40",
          description: "Leave is requested.",
        },
      ],
    },
    {
      name: "sl_zigbee_initial_security_bitmask_t",
      type: "uint16_t",
      description: "This is the Initial Security Bitmask that controls
                    the use of various security features.",
      items: [
        {
          name: "SL_ZIGBEE_STANDARD_SECURITY_MODE",
          value: "0x0000",
          description: "This enables ZigBee Standard Security on the
                        node.",
        },
        {
          name: "SL_ZIGBEE_DISTRIBUTED_TRUST_CENTER_MODE",
          value: "0x0002",
          description: "This enables Distributed Trust Center Mode for
                        the device forming the network. (Previously known
                        as SL_ZIGBEE_NO_TRUST_CENTER_MODE)",
        },
        {
          name: "SL_ZIGBEE_TRUST_CENTER_GLOBAL_LINK_KEY",
          value: "0x0004",
          description: "This enables a Global Link Key for the Trust
                        Center. All nodes will share the same Trust
                        Center Link Key.",
        },
        {
          name: "SL_ZIGBEE_PRECONFIGURED_NETWORK_KEY_MODE",
          value: "0x0008",
          description: "This enables devices that perform MAC
                        Association with a pre-configured Network Key to
                        join the network. It is only set on the Trust
                        Center.",
        },
        {
          name: "SL_ZIGBEE_TRUST_CENTER_USES_HASHED_LINK_KEY",
          value: "0x0084",
          description: "This denotes that the preconfiguredKey is not
                        the actual Link Key but a Secret Key known
                        only to the Trust Center. It is hashed with
                        the IEEE Address of the destination device in
                        order to create the actual Link Key used in
                        encryption. This is bit is only used by the
                        Trust Center. The joining device need not set
                        this.",
        },
        {
          name: "SL_ZIGBEE_HAVE_PRECONFIGURED_KEY",
          value: "0x0100",
          description: "This denotes that the preconfiguredKey element
                        has valid data that should be used to configure
                        the initial security state.",
        },
        {
          name: "SL_ZIGBEE_HAVE_NETWORK_KEY",
          value: "0x0200",
          description: "This denotes that the networkKey element has
                        valid data that should be used to configure the
                        initial security state.",
        },
        {
          name: "SL_ZIGBEE_GET_LINK_KEY_WHEN_JOINING",
          value: "0x0400",
          description: "This denotes to a joining node that it should
                        attempt to acquire a Trust Center Link Key
                        during joining. This is only necessary if the
                        device does not have a pre-configured key.",
        },
        {
          name: "SL_ZIGBEE_REQUIRE_ENCRYPTED_KEY",
          value: "0x0800",
          description: "This denotes that a joining device should only
                        accept an encrypted network key from the Trust
                        Center (using its pre-configured key). A key
                        sent in-the-clear by the Trust Center will be
                        rejected and the join will fail. This option is
                        only valid when utilizing a pre-configured key.",
        },
        {
          name: "SL_ZIGBEE_NO_FRAME_COUNTER_RESET",
          value: "0x1000",
          description: "This denotes whether the device should NOT
                        reset its outgoing frame counters (both NWK and
                        APS) when ::sli_zigbee_stack_set_initial_security_state() is
                        called. Normally it is advised to reset the
                        frame counter before joining a new network.
                        However in cases where a device is joining to
                        the same network a again (but not using
                        ::emberRejoinNetwork()) it should keep the NWK
                        and APS frame counters stored in its tokens.",
        },
        {
          name: "SL_ZIGBEE_GET_PRECONFIGURED_KEY_FROM_INSTALL_CODE",
          value: "0x2000",
          description: "This denotes that the device should obtain its
                        preconfigured key from an installation code
                        stored in the manufacturing token. The token
                        contains a value that will be hashed to obtain
                        the actual preconfigured key. If that token is
                        not valid, then the call to
                        sli_zigbee_stack_set_initial_security_state() will fail.",
        },
        {
          name: "SL_ZIGBEE_HAVE_TRUST_CENTER_EUI64",
          value: "0x0040",
          description: "This denotes that the
                        ::sl_zigbee_initial_security_state_t::preconfiguredTrustCenterEui64
                        has a value in it containing the trust center
                        EUI64. The device will only join a network and
                        accept commands from a trust center with that
                        EUI64. Normally this bit is NOT set, and the
                        EUI64 of the trust center is learned during the
                        join process. When commissioning a device to
                        join onto an existing network, which is using a
                        trust center, and without sending any messages,
                        this bit must be set and the field
                        ::sl_zigbee_initial_security_state_t::preconfiguredTrustCenterEui64
                        must be populated with the appropriate EUI64.",
        },
      ],
    },
    {
      name: "sl_zigbee_current_security_bitmask_t",
      type: "uint16_t",
      description: "This is the Current Security Bitmask that details
                    the use of various security features.",
      items: [
        {
          name: "SL_ZIGBEE_STANDARD_SECURITY_MODE",
          value: "0x0000",
          description: "This denotes that the device is running in a
                        network with ZigBee Standard Security.",
        },
        {
          name: "SL_ZIGBEE_DISTRIBUTED_TRUST_CENTER_MODE",
          value: "0x0002",
          description: "This denotes that the device is running in a
                        network without a centralized Trust Center.",
        },
        {
          name: "SL_ZIGBEE_TRUST_CENTER_GLOBAL_LINK_KEY",
          value: "0x0004",
          description: "This denotes that the device has a Global Link
                        Key. The Trust Center Link Key is the same
                        across multiple nodes.",
        },
        {
          name: "SL_ZIGBEE_HAVE_TRUST_CENTER_LINK_KEY",
          value: "0x0010",
          description: "This denotes that the node has a Trust Center
                        Link Key.",
        },
        {
          name: "SL_ZIGBEE_TRUST_CENTER_USES_HASHED_LINK_KEY",
          value: "0x0084",
          description: "This denotes that the Trust Center is using a
                        Hashed Link Key.",
        },
      ],
    },
    {
      name: "sl_zigbee_key_type_t",
      type: "uint8_t",
      description: "Describes the type of ZigBee security key.",
      items: [
        {
          name: "SL_ZIGBEE_TRUST_CENTER_LINK_KEY",
          value: "0x01",
          description: "A shared key between the Trust Center and a
                        device.",
        },
        {
          name: "SL_ZIGBEE_CURRENT_NETWORK_KEY",
          value: "0x03",
          description: "The current active Network Key used by all
                        devices in the network.",
        },
        {
          name: "SL_ZIGBEE_NEXT_NETWORK_KEY",
          value: "0x04",
          description: "The alternate Network Key that was previously
                        in use, or the newer key that will be switched
                        to.",
        },
        {
          name: "SL_ZIGBEE_APPLICATION_LINK_KEY",
          value: "0x05",
          description: "An Application Link Key shared with another
                        (non-Trust Center) device.",
        },
      ],
    },
    {
      name: "sl_zigbee_key_struct_bitmask_t",
      type: "uint16_t",
      description: "Describes the presence of valid data within the
                    sl_zigbee_key_struct_t structure.",
      items: [
        {
          name: "SL_ZIGBEE_KEY_HAS_SEQUENCE_NUMBER",
          value: "0x0001",
          description: "The key has a sequence number associated with
                        it.",
        },
        {
          name: "SL_ZIGBEE_KEY_HAS_OUTGOING_FRAME_COUNTER",
          value: "0x0002",
          description: "The key has an outgoing frame counter
                        associated with it.",
        },
        {
          name: "SL_ZIGBEE_KEY_HAS_INCOMING_FRAME_COUNTER",
          value: "0x0004",
          description: "The key has an incoming frame counter
                        associated with it.",
        },
        {
          name: "SL_ZIGBEE_KEY_HAS_PARTNER_EUI64",
          value: "0x0008",
          description: "The key has a Partner IEEE address associated
                        with it.",
        },
      ],
    },
    {
      name: "sl_zigbee_device_update_t",
      type: "uint8_t",
      description: "The status of the device update.",
      items: [
        {
          name: "SL_ZIGBEE_STANDARD_SECURITY_SECURED_REJOIN",
          value: "0x0",
          description: "",
        },
        {
          name: "SL_ZIGBEE_STANDARD_SECURITY_UNSECURED_JOIN",
          value: "0x1",
          description: "",
        },
        {
          name: "SL_ZIGBEE_DEVICE_LEFT",
          value: "0x2",
          description: "",
        },
        {
          name: "SL_ZIGBEE_STANDARD_SECURITY_UNSECURED_REJOIN",
          value: "0x3",
          description: "",
        },
      ],
    },
    {
      name: "sl_zigbee_key_status_t",
      type: "uint8_t",
      description: "The status of the attempt to establish a key.",
      items: [
        {
          name: "SL_ZIGBEE_APP_LINK_KEY_ESTABLISHED",
          value: "0x01",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TRUST_CENTER_LINK_KEY_ESTABLISHED",
          value: "0x03",
          description: "",
        },
        {
          name: "SL_ZIGBEE_KEY_ESTABLISHMENT_TIMEOUT",
          value: "0x04",
          description: "",
        },
        {
          name: "SL_ZIGBEE_KEY_TABLE_FULL",
          value: "0x05",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_RESPONDED_TO_KEY_REQUEST",
          value: "0x06",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_APP_KEY_SENT_TO_REQUESTER",
          value: "0x07",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_RESPONSE_TO_KEY_REQUEST_FAILED",
          value: "0x08",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_REQUEST_KEY_TYPE_NOT_SUPPORTED",
          value: "0x09",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_NO_LINK_KEY_FOR_REQUESTER",
          value: "0x0A",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_REQUESTER_EUI64_UNKNOWN",
          value: "0x0B",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_RECEIVED_FIRST_APP_KEY_REQUEST",
          value: "0x0C",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_TIMEOUT_WAITING_FOR_SECOND_APP_KEY_REQUEST",
          value: "0x0D",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_NON_MATCHING_APP_KEY_REQUEST_RECEIVED",
          value: "0x0E",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_FAILED_TO_SEND_APP_KEYS",
          value: "0x0F",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_FAILED_TO_STORE_APP_KEY_REQUEST",
          value: "0x10",
          description: "",
        },
        {
          name: "SL_ZIGBEE_TC_REJECTED_APP_KEY_REQUEST",
          value: "0x11",
          description: "",
        },
      ],
    },
    {
      name: "sl_zigbee_counter_type_t",
      type: "uint8_t",
      description: "Defines the events reported to the application by
                    the <i>readAndClearCounters</i> command.",
      items: [
        {
          name: "SL_ZIGBEE_COUNTER_MAC_RX_BROADCAST",
          value: "0",
          description: "The MAC received a broadcast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_MAC_TX_BROADCAST",
          value: "1",
          description: "The MAC transmitted a broadcast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_MAC_RX_UNICAST",
          value: "2",
          description: "The MAC received a unicast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_MAC_TX_UNICAST_SUCCESS",
          value: "3",
          description: "The MAC successfully transmitted a unicast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_MAC_TX_UNICAST_RETRY",
          value: "4",
          description: "The MAC retried a unicast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_MAC_TX_UNICAST_FAILED",
          value: "5",
          description: "The MAC unsuccessfully transmitted a unicast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_APS_DATA_RX_BROADCAST",
          value: "6",
          description: "The APS layer received a data broadcast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_APS_DATA_TX_BROADCAST",
          value: "7",
          description: "The APS layer transmitted a data broadcast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_APS_DATA_RX_UNICAST",
          value: "8",
          description: "The APS layer received a data unicast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_APS_DATA_TX_UNICAST_SUCCESS",
          value: "9",
          description: "The APS layer successfully transmitted a data
                        unicast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_APS_DATA_TX_UNICAST_RETRY",
          value: "10",
          description: "The APS layer retried a data unicast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_APS_DATA_TX_UNICAST_FAILED",
          value: "11",
          description: "The APS layer unsuccessfully transmitted a data
                        unicast.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_ROUTE_DISCOVERY_INITIATED",
          value: "12",
          description: "The network layer successfully submitted a new
                        route discovery to the MAC.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_NEIGHBOR_ADDED",
          value: "13",
          description: "An entry was added to the neighbor table.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_NEIGHBOR_REMOVED",
          value: "14",
          description: "An entry was removed from the neighbor table.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_NEIGHBOR_STALE",
          value: "15",
          description: "A neighbor table entry became stale because it
                        had not been heard from.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_JOIN_INDICATION",
          value: "16",
          description: "A node joined or rejoined to the network via
                        this node.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_CHILD_REMOVED",
          value: "17",
          description: "An entry was removed from the child table.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_ASH_OVERFLOW_ERROR",
          value: "18",
          description: "EZSP-UART only. An overflow error occurred in
                        the UART.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_ASH_FRAMING_ERROR",
          value: "19",
          description: "EZSP-UART only. A framing error occurred in the
                        UART.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_ASH_OVERRUN_ERROR",
          value: "20",
          description: "EZSP-UART only. An overrun error occurred in
                        the UART.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_NWK_FRAME_COUNTER_FAILURE",
          value: "21",
          description: "A message was dropped at the network layer
                        because the NWK frame counter was not higher
                        than the last message seen from that source.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_APS_FRAME_COUNTER_FAILURE",
          value: "22",
          description: "A message was dropped at the APS layer because
                        the APS frame counter was not higher than the
                        last message seen from that source.",
        },
        {
          name: "EMBER_COUNTER_UTILITY",
          value: "23",
          description: "Utility counter for general debugging use.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_APS_LINK_KEY_NOT_AUTHORIZED",
          value: "24",
          description: "A message was dropped at the APS layer because
                        it had APS encryption but the key associated
                        with the sender has not been authenticated, and
                        thus the key is not authorized for use in APS
                        data messages.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_NWK_DECRYPTION_FAILURE",
          value: "25",
          description: "An NWK encrypted message was received but
                        dropped because decryption failed.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_APS_DECRYPTION_FAILURE",
          value: "26",
          description: "An APS encrypted message was received but
                        dropped because decryption failed.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_ALLOCATE_PACKET_BUFFER_FAILURE",
          value: "27",
          description: "The number of times we failed to allocate a
                        set of linked packet buffers. This doesn't
                        necessarily mean that the packet buffer count
                        was 0 at the time, but that the number
                        requested was greater than the number free.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_RELAYED_UNICAST",
          value: "28",
          description: "The number of relayed unicast packets.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_PHY_TO_MAC_QUEUE_LIMIT_REACHED",
          value: "29",
          description: "The number of times we dropped a packet due to reaching the preset PHY to MAC queue limit (sli_802154mac_max_phy_to_mac_queue_length).",
        },
        {
          name: "SL_ZIGBEE_COUNTER_PACKET_VALIDATE_LIBRARY_DROPPED_COUNT",
          value: "30",
          description: "The number of times we dropped a packet due to the packet-validate library checking a packet and rejecting it due to length or other formatting problems.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_TYPE_NWK_RETRY_OVERFLOW",
          value: "31",
          description: "The number of times the NWK retry queue is full and a new message failed to be added.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_PHY_CCA_FAIL_COUNT",
          value: "32",
          description: "The number of times the PHY layer was unable to transmit due to a failed CCA.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_BROADCAST_TABLE_FULL",
          value: "33",
          description: "The number of times an NWK broadcast was dropped because the broadcast table was full.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_PTA_LO_PRI_REQUESTED",
          value: "34",
          description: "The number of low priority packet traffic arbitration requests.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_PTA_HI_PRI_REQUESTED",
          value: "35",
          description: "The number of high priority packet traffic arbitration requests.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_PTA_LO_PRI_DENIED",
          value: "36",
          description: "The number of low priority packet traffic arbitration requests denied.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_PTA_HI_PRI_DENIED",
          value: "37",
          description: "The number of high priority packet traffic arbitration requests denied.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_PTA_LO_PRI_TX_ABORTED",
          value: "38",
          description: "The number of aborted low-priority packet traffic arbitration transmissions.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_PTA_HI_PRI_TX_ABORTED",
          value: "39",
          description: "The number of aborted high-priority packet traffic arbitration transmissions.",
        },
        {
          name: "SL_ZIGBEE_COUNTER_TYPE_COUNT",
          value: "40",
          description: "A placeholder giving the number of Ember
                        counter types.",
        },
      ],
    },
    {
      name: "sl_zigbee_join_method_t",
      type: "uint8_t",
      description: "The type of method used for joining.",
      items: [
        {
          name: "SL_ZIGBEE_USE_MAC_ASSOCIATION",
          value: "0x0",
          description: "Normally devices use MAC Association to join a
                        network, which respects the \"permit joining\" flag
                        in the MAC Beacon.
                        This value should be used by default.",
        },
        {
          name: "SL_ZIGBEE_USE_NWK_REJOIN",
          value: "0x1",
          description: "For those networks where the \"permit joining\" flag
                        is never turned on, they will need to use a ZigBee
                        NWK Rejoin.  This value causes the rejoin to be
                        sent without NWK security and the Trust Center
                        will be asked to send the NWK key to the device.
                        The NWK key sent to the device can be encrypted
                        with the device's corresponding Trust Center link
                        key.  That is determined by the ::sl_zigbee_join_decision_t
                        on the Trust Center returned by the
                        ::sl_zigbee_internal_trust_center_join_handler().",
        },
        {
          name: "SL_ZIGBEE_USE_NWK_REJOIN_HAVE_NWK_KEY",
          value: "0x2",
          description: "For those networks where the \"permit joining\" flag
                        is never turned on, they will need to use an NWK
                        Rejoin.  If those devices have been preconfigured
                        with the  NWK key (including sequence number)
                        they can use a secured rejoin.  This is only
                        necessary for end devices since they need a
                        parent.  Routers can simply use the
                        ::SL_ZIGBEE_USE_CONFIGURED_NWK_STATE join method below.",
        },
        {
          name: "SL_ZIGBEE_USE_CONFIGURED_NWK_STATE",
          value: "0x3",
          description: "For those networks where all network and
                        security information is known ahead of time,
                        a router device may be commissioned such that
                        it does not need to send any messages to begin
                        communicating on the network.",
        },
      ],
    },
    {
      name: "sl_zigbee_zdo_configuration_flags_t",
      type: "uint8_t",
      description: "Flags for controlling which incoming ZDO requests
                    are passed to the application. To see if the
                    application is required to send a ZDO response to
                    an incoming message, the application must check the
                    APS options bitfield within the incomingMessageHandler
                    callback to see if the
                    SL_ZIGBEE_APS_OPTION_ZDO_RESPONSE_REQUIRED flag is set.",
      items: [
        {
          name: "SL_ZIGBEE_APP_RECEIVES_SUPPORTED_ZDO_REQUESTS",
          value: "0x01",
          description: "Set this flag in order to receive supported
                        ZDO request messages via the
                        incomingMessageHandler callback. A supported ZDO
                        request is one that is handled by the EmberZNet
                        stack. The stack will continue to handle the
                        request and send the appropriate ZDO response
                        even if this configuration option is enabled.",
        },
        {
          name: "SL_ZIGBEE_APP_HANDLES_UNSUPPORTED_ZDO_REQUESTS",
          value: "0x02",
          description: "Set this flag in order to receive unsupported
                        ZDO request messages via the
                        incomingMessageHandler callback. An unsupported ZDO
                        request is one that is not handled by the
                        EmberZNet stack, other than to send a 'not
                        supported' ZDO response. If this configuration
                        option is enabled, the stack will no longer
                        send any ZDO response, and it is the
                        application's responsibility to do so.",
        },
        {
          name: "SL_ZIGBEE_APP_HANDLES_ZDO_ENDPOINT_REQUESTS",
          value: "0x04",
          description: "Set this flag in order to receive the
                        following ZDO request messages via the
                        incomingMessageHandler callback:
                        SIMPLE_DESCRIPTOR_REQUEST, MATCH_DESCRIPTORS_REQUEST,
                        and ACTIVE_ENDPOINTS_REQUEST. If this configuration
                        option is enabled, the stack will no longer
                        send any ZDO response for these requests, and
                        it is the application's responsibility to do so.",
        },
        {
          name: "SL_ZIGBEE_APP_HANDLES_ZDO_BINDING_REQUESTS",
          value: "0x08",
          description: "Set this flag in order to receive the
                        following ZDO request messages via the
                        incomingMessageHandler callback:
                        BINDING_TABLE_REQUEST, BIND_REQUEST, and
                        UNBIND_REQUEST. If this configuration option is
                        enabled, the stack will no longer send any ZDO
                        response for these requests, and it is the
                        application's responsibility to do so.",
        },
      ],
    },
    {
      name: "EmberConcentratorType",
      type: "uint16_t",
      description: "Type of concentrator.",
      items: [
        {
          name: "SL_ZIGBEE_LOW_RAM_CONCENTRATOR",
          value: "0xFFF8",
          description: "A concentrator with insufficient memory to store
                        source routes for the entire network. Route
                        records are sent to the concentrator prior to
                        every inbound APS unicast.",
        },
        {
          name: "SL_ZIGBEE_HIGH_RAM_CONCENTRATOR",
          value: "0xFFF9",
          description: "A concentrator with sufficient memory to store
                        source routes for the entire network. Remote
                        nodes stop sending route records once the
                        concentrator has successfully received one.",
        },
      ],
    },
    {
      name: "sl_zigbee_zll_state_t",
      type: "uint16_t",
      description: "ZLL device state identifier",
      items: [
        {
          name: "SL_ZIGBEE_ZLL_STATE_NONE",
          value: "0x0000",
          description: "No state.",
        },
        {
          name: "SL_ZIGBEE_ZLL_STATE_FACTORY_NEW",
          value: "0x0001",
          description: "The device is factory new.",
        },
        {
          name: "SL_ZIGBEE_ZLL_STATE_ADDRESS_ASSIGNMENT_CAPABLE",
          value: "0x0002",
          description: "The device is capable of assigning addresses to
                        other devices.",
        },
        {
          name: "SL_ZIGBEE_ZLL_STATE_LINK_INITIATOR",
          value: "0x0010",
          description: "The device is initiating a link operation.",
        },
        {
          name: "SL_ZIGBEE_ZLL_STATE_LINK_PRIORITY_REQUEST",
          value: "0x0020",
          description: "The device is requesting link priority.",
        },
        {
          name: "SL_ZIGBEE_ZLL_STATE_NON_ZLL_NETWORK",
          value: "0x0100",
          description: "The device is on a non-ZLL network.",
        },
      ],
    },
    {
      name: "sl_zigbee_zll_key_index_t",
      type: "uint8_t",
      description: "ZLL key encryption algorithm enumeration.",
      items: [
        {
          name: "SL_ZIGBEE_ZLL_KEY_INDEX_DEVELOPMENT",
          value: "0x00",
          description: "Key encryption algorithm for use during
                        development.",
        },
        {
          name: "SL_ZIGBEE_ZLL_KEY_INDEX_MASTER",
          value: "0x04",
          description: "Key encryption algorithm shared by all certified
                        devices.",
        },
        {
          name: "SL_ZIGBEE_ZLL_KEY_INDEX_CERTIFICATION",
          value: "0x0F",
          description: "Key encryption algorithm for use during
                        development and certification.",
        },
      ],
    },
    {
      name: "sl_zigbee_ezsp_zll_network_operation_t",
      type: "uint8_t",
      description: "Differentiates among ZLL network operations.",
      items: [
        {
          name: "SL_ZIGBEE_EZSP_ZLL_FORM_NETWORK",
          value: "0x00",
          description: "ZLL form network command.",
        },
        {
          name: "SL_ZIGBEE_EZSP_ZLL_JOIN_TARGET",
          value: "0x01",
          description: "ZLL join target command.",
        },
      ],
    },
    {
      name: "sl_zigbee_network_init_bitmask_t",
      type: "uint16_t",
      description: "Bitmask options for sli_zigbee_stack_network_init()",
      items: [
        {
          name: "SL_ZIGBEE_NETWORK_INIT_NO_OPTIONS",
          value: "0x0000",
          description: "No options for Network Init",
        },
        {
          name: "SL_ZIGBEE_NETWORK_INIT_PARENT_INFO_IN_TOKEN",
          value: "0x0001",
          description: "Save parent info (node ID and EUI64) in a
                        token during joining/rejoin, and restore on
                        reboot.",
        },
        {
          name: "SL_ZIGBEE_NETWORK_INIT_END_DEVICE_REJOIN_ON_REBOOT",
          value: "0x0002",
          description: "Send a rejoin request as an end device on
                        reboot if parent information is persisted.",
        },
      ],
    },
    {
      name: "sl_zigbee_multi_phy_nwk_config_t",
      type: "uint8_t",
      description: "Network configuration for the desired radio interface
                    for multi phy network.",
      items: [
        {
          name: "SL_ZIGBEE_BROADCAST_SUPPORT",
          value: "0x01",
          description: "Enable broadcast support on Routers",
        },
      ],
    },
    {
      name: "sl_zigbee_duty_cycle_state_t",
      type: "uint8_t",
      description: "Duty cycle states.",
      items: [
        {
          name: "SL_ZIGBEE_DUTY_CYCLE_TRACKING_OFF",
          value: "0",
          description: "No Duty cycle tracking or metrics are taking
                        place.",
        },
        {
          name: "SL_ZIGBEE_DUTY_CYCLE_LBT_NORMAL",
          value: "1",
          description: "Duty Cycle is tracked and has not exceeded
                        any thresholds.",
        },
        {
          name: "SL_ZIGBEE_DUTY_CYCLE_LBT_LIMITED_THRESHOLD_REACHED",
          value: "2",
          description: "We have exceeded the limited threshold of our
                        total duty cycle allotment.",
        },
        {
          name: "SL_ZIGBEE_DUTY_CYCLE_LBT_CRITICAL_THRESHOLD_REACHED",
          value: "3",
          description: "We have exceeded the critical threshold of our
                        total duty cycle allotment",
        },
        {
          name: "SL_ZIGBEE_DUTY_CYCLE_LBT_SUSPEND_LIMIT_REACHED",
          value: "4",
          description: "We have reached the suspend limit and are blocking
                        all outbound transmissions.",
        },
      ],
    },
    {
      name: "sl_zigbee_radio_power_mode_t",
      type: "uint8_t",
      description: "Radio power modes.",
      items: [
        {
          name: "SL_ZIGBEE_RADIO_POWER_MODE_RX_ON",
          value: "0",
          description: "The radio receiver is switched on.",
        },
        {
          name: "SL_ZIGBEE_RADIO_POWER_MODE_OFF",
          value: "1",
          description: "The radio receiver is switched off.",
        },
      ],
    },
    {
      name: "sl_zigbee_entropy_source_t",
      type: "uint8_t",
      description: "Entropy sources.",
      items: [
        {
          name: "SL_ZIGBEE_ENTROPY_SOURCE_ERROR",
          value: "0",
          description: "Entropy source error.",
        },
        {
          name: "SL_ZIGBEE_ENTROPY_SOURCE_RADIO",
          value: "1",
          description: "Entropy source is the radio.",
        },
        {
          name: "SL_ZIGBEE_ENTROPY_SOURCE_MBEDTLS_TRNG",
          value: "2",
          description: "Entropy source is the TRNG powered by mbed TLS.",
        },
        {
          name: "SL_ZIGBEE_ENTROPY_SOURCE_MBEDTLS",
          value: "3",
          description: "Entropy source is powered by mbed TLS, the source is
                        not TRNG.",
        },
      ],
    },
    {
      name: "sl_zigbee_sec_man_key_type_t",
      type: "uint8_t",
      description: "Key types recognized by Zigbee Security Manager.",
      items: [
        {
          name: "SL_ZB_SEC_MAN_KEY_TYPE_NONE",
          value: "0",
          description: "No key type.",
        },
        {
          name: "SL_ZB_SEC_MAN_KEY_TYPE_NETWORK",
          value: "1",
          description: "Network Key (either current or alternate).",
        },
        {
          name: "SL_ZB_SEC_MAN_KEY_TYPE_TC_LINK",
          value: "2",
          description: "Preconfigured Trust Center Link Key.",
        },
        {
          name: "SL_ZB_SEC_MAN_KEY_TYPE_TC_LINK_WITH_TIMEOUT",
          value: "3",
          description: "Transient key.",
        },
        {
          name: "SL_ZB_SEC_MAN_KEY_TYPE_APP_LINK",
          value: "4",
          description: "Link key in table.",
        },
        {
          name: "SL_ZB_SEC_MAN_KEY_TYPE_ZLL_ENCRYPTION_KEY",
          value: "6",
          description: "Encryption key in ZLL.",
        },
        {
          name: "SL_ZB_SEC_MAN_KEY_TYPE_ZLL_PRECONFIGURED_KEY",
          value: "7",
          description: "Preconfigured key in ZLL.",
        },
        {
          name: "SL_ZB_SEC_MAN_KEY_TYPE_GREEN_POWER_PROXY_TABLE_KEY",
          value: "8",
          description: "GP Proxy table key.",
        },
        {
          name: "SL_ZB_SEC_MAN_KEY_TYPE_GREEN_POWER_SINK_TABLE_KEY",
          value: "9",
          description: "GP Sink table key.",
        },
        {
          name: "SL_ZB_SEC_MAN_KEY_TYPE_INTERNAL",
          value: "10",
          description: "Generic key type available to use for crypto operations.",
        },
      ]
    },
    {
      name: "sl_zigbee_sec_man_derived_key_type_t",
      type: "uint16_t",
      description: "Derived key types recognized by Zigbee Security Manager.",
      items: [
        {
          name: "SL_ZB_SEC_MAN_DERIVED_KEY_TYPE_NONE",
          value: "0",
          description: "No derivation (use core key type directly).",
        },
        {
          name: "SL_ZB_SEC_MAN_DERIVED_KEY_TYPE_KEY_TRANSPORT_KEY",
          value: "1",
          description: "Hash core key with Key Transport Key hash.",
        },
        {
          name: "SL_ZB_SEC_MAN_DERIVED_KEY_TYPE_KEY_LOAD_KEY",
          value: "2",
          description: "Hash core key with Key Load Key hash.",
        },
        {
          name: "SL_ZB_SEC_MAN_DERIVED_KEY_TYPE_VERIFY_KEY",
          value: "3",
          description: "Perform Verify Key hash.",
        },
        {
          name: "SL_ZB_SEC_MAN_DERIVED_KEY_TYPE_TC_SWAP_OUT_KEY",
          value: "4",
          description: "Perform a simple AES hash of the key for TC backup.",
        },
        {
          name: "SL_ZB_SEC_MAN_DERIVED_KEY_TYPE_TC_HASHED_LINK_KEY",
          value: "5",
          description: "For a TC using hashed link keys, hashed the root key against the supplied EUI in context.",
        },
      ]
    },
    {
      name: "sl_zigbee_sec_man_flags_t",
      type: "uint8_t",
      description: "Flags for key operations.",
      items: [
        {
          name: "ZB_SEC_MAN_FLAG_NONE",
          value: "0",
          description: "No flags on operation.",
        },
        {
          name: "ZB_SEC_MAN_FLAG_KEY_INDEX_IS_VALID",
          value: "1",
          description: "Context has a valid key index.",
        },
        {
          name: "ZB_SEC_MAN_FLAG_EUI_IS_VALID",
          value: "2",
          description: "Context has a valid EUI64.",
        },
        {
          name: "ZB_SEC_MAN_FLAG_UNCONFIRMED_TRANSIENT_KEY",
          value: "4",
          description: "Transient key being added hasn't yet been verified.",
        },
      ],
    },
    {
      name: "sl_zigbee_leave_request_flags_t",
      type: "uint8_t",
      description: "Flags for NWK leave request command.",
      items: [
        {
          name: "SL_ZIGBEE_ZIGBEE_LEAVE_AND_REJOIN",
          value: "0x80",
          description: "Leave and rejoin the network.",
        },
        {
          name: "SL_ZIGBEE_ZIGBEE_LEAVE_WITHOUT_REJOIN",
          value: "0x00",
          description: "Leave the network and do not rejoin.",
        },
      ],
    }
  ],

  frames: ~,

}
# END Common

################################################################################
- {
  section: Configuration Frames,

  ncpCpps: ~,

  typedefs: ~,

  enums: ~,

  frames: [
    ## VERSION
    {
      value: "0x0000",
      needGeneratedHandler : "no",
      commandName: "version",
      description: "The command allows the Host to specify the desired
                    EZSP version and must be sent before any other
                    command. The response provides information about the
                    firmware running on the NCP.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "desiredProtocolVersion",
          description: "The EZSP version the Host wishes to use. To
                        successfully set the version and allow other
                        commands, this must be same as EZSP_PROTOCOL_VERSION.",
        },
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "protocolVersion",
          description: "The EZSP version the NCP is using.",
        },
        {
          type: "uint8_t",
          name: "stackType",
          description: "The type of stack running on the NCP (2).",
        },
        {
          type: "uint16_t",
          name: "stackVersion",
          description: "The version number of the stack.",
        },
      ],
    },
    ## GET_CONFIGURATION_VALUE
    {
      value: "0x0052",
      needGeneratedHandler : "no",
      commandName: "getConfigurationValue",
      description: "Reads a configuration value from the NCP.",
      commandArguments: [
        {
          type: "sl_zigbee_ezsp_config_id_t",
          name: "configId",
          description: "Identifies which configuration value to read.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the value was read successfully,
                        SL_STATUS_ZIGBEE_EZSP_ERROR (for SL_ZIGBEE_EZSP_ERROR_INVALID_ID) if the NCP
                        does not recognize <i>configId</i>.",
        },
        {
          type: "uint16_t",
          name: "value",
          description: "The configuration value.",
        },
      ],
    },
    ## SET_CONFIGURATION_VALUE
    {
      value: "0x0053",
      needGeneratedHandler : "no",
      commandName: "setConfigurationValue",
      description: "Writes a configuration value to the NCP.
                    Configuration values can be modified by the Host
                    after the NCP has reset. Once the status of the
                    stack changes to SL_STATUS_NETWORK_UP, configuration
                    values can no longer be modified and this command
                    will respond with SL_ZIGBEE_EZSP_ERROR_INVALID_CALL.",
      commandArguments: [
        {
          type: "sl_zigbee_ezsp_config_id_t",
          name: "configId",
          description: "Identifies which configuration value to change.",
        },
        {
          type: "uint16_t",
          name: "value",
          description: "The new configuration value.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the configuration value was
                        changed, SL_STATUS_ZIGBEE_EZSP_ERROR if there was an error.
                        Retrievable EZSP errors can be SL_ZIGBEE_EZSP_ERROR_OUT_OF_MEMORY
                        if the new value exceeded the available memory,
                        SL_ZIGBEE_EZSP_ERROR_INVALID_VALUE if the new value was out
                        of bounds, SL_ZIGBEE_EZSP_ERROR_INVALID_ID if the NCP does
                        not recognize <i>configId</i>,
                        SL_ZIGBEE_EZSP_ERROR_INVALID_CALL if configuration values can
                        no longer be modified.",
        },
      ],
    },
    ## READ_ATTRIBUTE
    {
      value: "0x0108",
      needGeneratedHandler : "no",
      commandName: "readAttribute",
      description: "Read attribute data on NCP endpoints.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "endpoint",
          description: "Endpoint",
        },
        {
          type: "uint16_t",
          name: "cluster",
          description: "Cluster.",
        },
        {
          type: "uint16_t",
          name: "attributeId",
          description: "Attribute ID.",
        },
        {
          type: "uint8_t",
          name: "mask",
          description: "Mask.",
        },
        {
          type: "uint16_t",
          name: "manufacturerCode",
          description: "Manufacturer code.",
        },
      ],
      responseArguments: [
        {
          type: "sl_zigbee_af_status_t",
          name: "af_status",
          description: "An sl_zigbee_af_status_t value indicating success or the
                        reason for failure, handled by the EZSP layer as
                        a uint8_t. 255 indicates an EZSP-specific error.",
        },
        {
          type: "uint8_t",
          name: "dataType",
          description: "Attribute data type.",
        },
        {
          type: "uint8_t",
          name: "readLength",
          description: "Length of attribute data.",
        },
        {
          type: "uint8_t[readLength]",
          name: "dataPtr",
          description: "Attribute data.",
        },
      ],
    },
    ## WRITE_ATTRIBUTE
    {
      value: "0x0109",
      needGeneratedHandler : "no",
      commandName: "writeAttribute",
      description: "Write attribute data on NCP endpoints.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "endpoint",
          description: "Endpoint",
        },
        {
          type: "uint16_t",
          name: "cluster",
          description: "Cluster.",
        },
        {
          type: "uint16_t",
          name: "attributeId",
          description: "Attribute ID.",
        },
        {
          type: "uint8_t",
          name: "mask",
          description: "Mask.",
        },
        {
          type: "uint16_t",
          name: "manufacturerCode",
          description: "Manufacturer code.",
        },
        {
          type: "bool",
          name: "overrideReadOnlyAndDataType",
          description: "Override read only and data type.",
        },
        {
          type: "bool",
          name: "justTest",
          description: "Override read only and data type.",
        },
        {
          type: "uint8_t",
          name: "dataType",
          description: "Attribute data type.",
        },
        {
          type: "uint8_t",
          name: "dataLength",
          description: "Attribute data length.",
        },
        {
          type: "uint8_t[dataLength]",
          name: "data",
          description: "Attribute data.",
        },
      ],
      responseArguments: [
        {
          type: "sl_zigbee_af_status_t",
          name: "af_status",
          description: "An sl_zigbee_af_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## ADD_ENDPOINT
    {
      value: "0x0002",
      needGeneratedHandler : "no",
      commandName: "addEndpoint",
      description: "Configures endpoint information on the NCP. The NCP
                    does not remember these settings after a reset.
                    Endpoints can be added by the Host after the NCP
                    has reset. Once the status of the stack changes to
                    SL_STATUS_NETWORK_UP, endpoints can no longer be added
                    and this command will respond with
                    SL_ZIGBEE_EZSP_ERROR_INVALID_CALL.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "endpoint",
          description: "The application endpoint to be added.",
        },
        {
          type: "uint16_t",
          name: "profileId",
          description: "The endpoint's application profile.",
        },
        {
          type: "uint16_t",
          name: "deviceId",
          description: "The endpoint's device ID within the application
                        profile.",
        },
        {
          type: "uint8_t",
          name: "deviceVersion",
          description: "The endpoint's device version.",
        },
        {
          type: "uint8_t",
          name: "inputClusterCount",
          description: "The number of cluster IDs in
                        <i>inputClusterList</i>.",
        },
        {
          type: "uint8_t",
          name: "outputClusterCount",
          description: "The number of cluster IDs in
                        <i>outputClusterList</i>.",
        },
        {
          type: "uint16_t[inputClusterCount]",
          name: "inputClusterList",
          description: "Input cluster IDs the endpoint will accept.",
        },
        {
          type: "uint16_t[outputClusterCount]",
          name: "outputClusterList",
          description: "Output cluster IDs the endpoint may send.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the endpoint was added,
                        SL_STATUS_ZIGBEE_EZSP_ERROR if there was an error.
                        Errors could be SL_ZIGBEE_EZSP_ERROR_OUT_OF_MEMORY if there is not enough
                        memory available to add the endpoint,
                        SL_ZIGBEE_EZSP_ERROR_INVALID_VALUE if the endpoint already
                        exists, SL_ZIGBEE_EZSP_ERROR_INVALID_CALL if endpoints can
                        no longer be added.",
        },
      ],
    },
    ## SET_POLICY
    {
      value: "0x0055",
      needGeneratedHandler : "no",
      commandName: "setPolicy",
      description: "Allows the Host to change the policies used by
                    the NCP to make fast decisions.",
      commandArguments: [
        {
          type: "sl_zigbee_ezsp_policy_id_t",
          name: "policyId",
          description: "Identifies which policy to modify.",
        },
        {
          type: "sl_zigbee_ezsp_decision_id_t",
          name: "decisionId",
          description: "The new decision for the specified policy.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the policy was changed,
                        SL_STATUS_ZIGBEE_EZSP_ERROR (for SL_ZIGBEE_EZSP_ERROR_INVALID_ID) if the NCP does not
                        recognize <i>policyId</i>.",
        },
      ],
    },
    ## GET_POLICY
    {
      value: "0x0056",
      needGeneratedHandler : "no",
      commandName: "getPolicy",
      description: "Allows the Host to read the policies used by the
                    NCP to make fast decisions.",
      commandArguments: [
        {
          type: "sl_zigbee_ezsp_policy_id_t",
          name: "policyId",
          description: "Identifies which policy to read.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the policy was read
                        successfully, SL_STATUS_ZIGBEE_EZSP_ERROR (for SL_ZIGBEE_EZSP_ERROR_INVALID_ID)
                        if the NCP does not recognize <i>policyId</i>.",
        },
        {
          type: "sl_zigbee_ezsp_decision_id_t",
          name: "decisionId",
          description: "The current decision for the specified policy.",
        },
      ],
    },
    ## SEND_PAN_ID_UPDATE
    {
      value: "0x0057",
      needGeneratedHandler : "no",
      commandName: "sendPanIdUpdate",
      description: "Triggers a pan id update message.",
      commandArguments: [
      {
      type: "sl_802154_pan_id_t",
      name: "newPan",
      description: "The new Pan Id",
      },
      ],
    responseArguments: [
    {
    type: "bool",
    name: "status",
    description: "true if the request was successfully handed to the stack, false otherwise",
    },

    ],
    },
    ## GET_VALUE
    {
      value: "0x00AA",
      needGeneratedHandler : "no",
      commandName: "getValue",
      description: "Reads a value from the NCP.",
      commandArguments: [
        {
          type: "sl_zigbee_ezsp_value_id_t",
          name: "valueId",
          description: "Identifies which value to read.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the value was read successfully,
                        SL_STATUS_ZIGBEE_EZSP_ERROR otherwise.  Errors could be
                        SL_ZIGBEE_EZSP_ERROR_INVALID_ID if the NCP does not
                        recognize <i>valueId</i>,
                        SL_ZIGBEE_EZSP_ERROR_INVALID_VALUE if the length of the
                        returned <i>value</i> exceeds the size of local
                        storage allocated to receive it.",
        },
        {
          type: "uint8_t",
          name: "valueLength",
          description: "Both a command and response parameter. On command,
                        the maximum size in bytes of local storage allocated
                        to receive the returned <i>value</i>. On response,
                        the actual length in bytes of the returned <i>value</i>.",
        },
        {
          type: "uint8_t[valueLength]",
          name: "value",
          description: "The value.",
        },
      ],
    },
    ## GET_EXTENDED_VALUE
    {
      value: "0x0003",
      needGeneratedHandler : "no",
      commandName: "getExtendedValue",
      description: "Reads a value from the NCP but passes an extra
                    argument specific to the value being retrieved.",
      commandArguments: [
        {
          type: "sl_zigbee_ezsp_extended_value_id_t",
          name: "valueId",
          description: "Identifies which extended value ID to read.",
        },
        {
          type: "uint32_t",
          name: "characteristics",
          description: "Identifies which characteristics of the extended
                        value ID to read. These are specific to the
                        value being read.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the value was read successfully,
                        SL_STATUS_ZIGBEE_EZSP_ERROR otherwise.  Errors could be
                        SL_ZIGBEE_EZSP_ERROR_INVALID_ID if the NCP does not
                        recognize <i>valueId</i>,
                        SL_ZIGBEE_EZSP_ERROR_INVALID_VALUE if the length of the
                        returned <i>value</i> exceeds the size of local
                        storage allocated to receive it.",
        },
        {
          type: "uint8_t",
          name: "valueLength",
          description: "Both a command and response parameter. On command,
                        the maximum size in bytes of local storage allocated
                        to receive the returned <i>value</i>. On response,
                        the actual length in bytes of the returned <i>value</i>.",
        },
        {
          type: "uint8_t[valueLength]",
          name: "value",
          description: "The value.",
        },
      ],
    },
    ## SET_VALUE
    {
      value: "0x00AB",
      needGeneratedHandler : "no",
      commandName: "setValue",
      description: "Writes a value to the NCP.",
      commandArguments: [
        {
          type: "sl_zigbee_ezsp_value_id_t",
          name: "valueId",
          description: "Identifies which value to change.",
        },
        {
          type: "uint8_t",
          name: "valueLength",
          description: "The length of the <i>value</i> parameter in
                        bytes.",
        },
        {
          type: "uint8_t[valueLength]",
          name: "value",
          description: "The new value.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the value was changed,
                        SL_STATUS_ZIGBEE_EZSP_ERROR otherwise.  Errors could be
                        SL_ZIGBEE_EZSP_ERROR_INVALID_VALUE if the new value was out
                        of bounds, SL_ZIGBEE_EZSP_ERROR_INVALID_ID if the NCP does
                        not recognize <i>valueId</i>,
                        SL_ZIGBEE_EZSP_ERROR_INVALID_CALL if the value could not be
                        modified.",
        },
      ],
    },
    ## SET_PASSIVE_ACK_CONFIG
    {
      value: "0x0105",
      needGeneratedHandler : "no",
      commandName: "setPassiveAckConfig",
      description: "Allows the Host to control the broadcast behaviour of a routing device used by
                    the NCP.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "config",
          description: "Passive ack config enum.",
        },
        {
          type: "uint8_t",
          name: "minAcksNeeded",
          description: "The minimum number of acknowledgments (re-broadcasts) to wait
                        for until deeming the broadcast transmission complete.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ##SET_PENDING_NETWORK_UPDATE_PAN_ID
    {
      value: "0x011E",
      needGeneratedHandler: "yes",
      commandName: "setPendingNetworkUpdatePanId",
      description: "Set the PAN ID to be accepted by the device in a NLME
                    Network Update command.  If this is set to a different
                    value than its default 0xFFFF, NLME network update
                    messages will be ignored if they do not match this PAN ID.",
      commandArguments: [
        {
          type: "uint16_t",
          name: "panId",
          description: "PAN ID to be accepted in a network update.",
        },
      ],
      responseArguments: [
      ],
    },
    ##GET_ENDPOINT
    {
      value: "0x012E",
      needGeneratedHandler: "yes",
      commandName: "getEndpoint",
      description: "Retrieve the endpoint number located at the specified index.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "Index to retrieve the endpoint number for.",
        },
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "endpoint",
          description: "Endpoint number at the index.",
        },
      ]
    },
    ##GET_ENDPOINT_COUNT
    {
      value: "0x012F",
      needGeneratedHandler: "yes",
      commandName: "getEndpointCount",
      description: "Get the number of configured endpoints.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "count",
          description: "Number of configured endpoints.",
        },
      ]
    },
    ##GET_ENDPOINT_DESCRIPTION
    {
      value: "0x0130",
      needGeneratedHandler: "yes",
      commandName: "getEndpointDescription",
      description: "Retrieve the endpoint description for the given endpoint number.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "endpoint",
          description: "Endpoint number to get the description of.",
        },
      ],
      responseArguments: [
        {
          type: "sl_zigbee_endpoint_description_t",
          name: "result",
          description: "Description of this endpoint."
        },
      ],
    },
    ##GET_ENDPOINT_CLUSTER
    {
      value: "0x0131",
      needGeneratedHandler: "yes",
      commandName: "getEndpointCluster",
      description: "Retrieve one of the cluster IDs associated with the given endpoint.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "endpoint",
          description: "Endpoint number to get a cluster ID for."
        },
        {
          type: "uint8_t",
          name: "listId",
          description: "Which list to get the cluster ID from.  (0 for input, 1 for output)."
        },
        {
          type: "uint8_t",
          name: "listIndex",
          description: "Index from requested list to look at the cluster ID of."
        },
      ],
      responseArguments: [
        {
          type: "uint16_t",
          name: "endpoint_cluster",
          description: "ID of the requested cluster.",
        },
      ],
    }
  ],

}
# END Configuration Frames

################################################################################
- {
  section: Utilities Frames,

  ncpCpps: ~,

  typedefs: [
    {
      name: "sl_zigbee_library_status_t",
      description: "The presence and status of the Ember library.",
      definition: "uint8_t"
    },
  ],

  enums: ~,

  frames: [
    ## NOP
    {
      value: "0x0005",
      needGeneratedHandler : "no",
      commandName: "nop",
      description: "A command which does nothing. The Host can use
                    this to set the sleep mode or to check the status
                    of the NCP.",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    ## ECHO
    {
      value: "0x0081",
      needGeneratedHandler : "no",
      commandName: "echo",
      description: "Variable length data from the Host is echoed back
                    by the NCP. This command has no other effects and
                    is designed for testing the link between the Host
                    and NCP.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "dataLength",
          description: "The length of the <i>data</i> parameter in
                        bytes.",
        },
        {
          type: "uint8_t[dataLength]",
          name: "data",
          description: "The data to be echoed back.",
        },
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "echoLength",
          description: "The length of the <i>echo</i> parameter in
                        bytes.",
        },
        {
          type: "uint8_t[echoLength]",
          name: "echo",
          description: "The echo of the data.",
        },
      ],
    },
    ## INVALID_COMMAND
    {
      value: "0x0058",
      needGeneratedHandler : "no",
      commandName: "invalidCommand",
      description: "Indicates that the NCP received an invalid command.",
      responseArguments: [
        {
          type: "sl_zigbee_ezsp_status_t",
          name: "reason",
          description: "The reason why the command was invalid.",
        },
      ],
    },
    ## CALLBACK
    {
      value: "0x0006",
      needGeneratedHandler : "no",
      commandName: "callback",
      description: "Allows the NCP to respond with a pending callback.",
      commandArguments: [
      ],
    },
    ## NO_CALLBACKS
    {
      value: "0x0007",
      needGeneratedHandler : "no",
      commandName: "noCallbacks",
      description: "Indicates that there are currently no pending
                    callbacks.",
      responseArguments: [
      ],
    },
    ## SET_TOKEN
    {
      value: "0x0009",
      needGeneratedHandler : "no",
      commandName: "setToken",
      description: "Sets a token (8 bytes of non-volatile storage) in
                    the Simulated EEPROM of the NCP.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "tokenId",
          description: "Which token to set",
        },
        {
          type: "uint8_t[8]",
          name: "tokenData",
          description: "The data to write to the token.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## GET_TOKEN
    {
      value: "0x000A",
      needGeneratedHandler : "no",
      commandName: "getToken",
      description: "Retrieves a token (8 bytes of non-volatile storage)
                    from the Simulated EEPROM of the NCP.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "tokenId",
          description: "Which token to read",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "uint8_t[8]",
          name: "tokenData",
          description: "The contents of the token.",
        },
      ],
    },
    ## GET_MFG_TOKEN
    {
      value: "0x000B",
      needGeneratedHandler : "no",
      commandName: "getMfgToken",
      description: "Retrieves a manufacturing token from the Flash
                    Information Area of the NCP (except for
                    SL_ZIGBEE_EZSP_STACK_CAL_DATA which is managed by the stack).",
      commandArguments: [
        {
          type: "sl_zigbee_ezsp_mfg_token_id_t",
          name: "tokenId",
          description: "Which manufacturing token to read.",
        },
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "tokenDataLength",
          description: "The length of the <i>tokenData</i> parameter in
                        bytes.",
        },
        {
          type: "uint8_t[tokenDataLength]",
          name: "tokenData",
          description: "The manufacturing token data.",
        },
      ],
    },
    ## SET_MFG_TOKEN
    {
      value: "0x000C",
      needGeneratedHandler : "no",
      commandName: "setMfgToken",
      description: "Sets a manufacturing token in the Customer
                    Information Block (CIB) area of the NCP if that
                    token currently unset (fully erased). Cannot be used
                    with SL_ZIGBEE_EZSP_STACK_CAL_DATA, SL_ZIGBEE_EZSP_STACK_CAL_FILTER,
                    SL_ZIGBEE_EZSP_MFG_ASH_CONFIG, or SL_ZIGBEE_EZSP_MFG_CBKE_DATA token.",
      commandArguments: [
        {
          type: "sl_zigbee_ezsp_mfg_token_id_t",
          name: "tokenId",
          description: "Which manufacturing token to set.",
        },
        {
          type: "uint8_t",
          name: "tokenDataLength",
          description: "The length of the <i>tokenData</i> parameter in
                        bytes.",
        },
        {
          type: "uint8_t[tokenDataLength]",
          name: "tokenData",
          description: "The manufacturing token data.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## STACK_TOKEN_CHANGED_HANDLER
    {
      value: "0x000D",
      needGeneratedHandler : "no",
      commandName: "stackTokenChangedHandler",
      description: "A callback invoked to inform the application that
                    a stack token has changed.",
      responseArguments: [
        {
          type: "uint16_t",
          name: "tokenAddress",
          description: "The address of the stack token that has
                        changed.",
        },
      ],
    },
    ## GET_RANDOM_NUMBER
    {
      value: "0x0049",
      needGeneratedHandler : "no",
      commandName: "getRandomNumber",
      description: "Returns a pseudorandom number.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Always returns SL_STATUS_OK.",
        },
        {
          type: "uint16_t",
          name: "value",
          description: "A pseudorandom number.",
        },
      ],
    },
    ## SET_TIMER
    {
      value: "0x000E",
      needGeneratedHandler : "no",
      commandName: "setTimer",
      description: "Sets a timer on the NCP. There are 2 independent
                    timers available for use by the Host. A timer can
                    be cancelled by setting <i>time</i> to 0 or
                    <i>units</i> to SL_ZIGBEE_EVENT_INACTIVE.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "timerId",
          description: "Which timer to set (0 or 1).",
        },
        {
          type: "uint16_t",
          name: "time",
          description: "The delay before the <i>timerHandler</i> callback
                        will be generated. Note that the timer clock is
                        free running and is not synchronized with this
                        command. This means that the actual delay will
                        be between <i>time</i> and (<i>time</i> - 1).
                        The maximum delay is 32767.",
        },
        {
          type: "sl_zigbee_event_units_t",
          name: "units",
          description: "The units for <i>time</i>.",
        },
        {
          type: "bool",
          name: "repeat",
          description: "If true, a <i>timerHandler</i> callback will be
                        generated repeatedly. If false, only a single
                        <i>timerHandler</i> callback will be generated.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## GET_TIMER
    {
      value: "0x004E",
      needGeneratedHandler : "no",
      commandName: "getTimer",
      description: "Gets information about a timer. The Host can use
                    this command to find out how much longer it will
                    be before a previously set timer will generate a
                    callback.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "timerId",
          description: "Which timer to get information about (0 or 1).",
        },
      ],
      responseArguments: [
        {
          type: "uint16_t",
          name: "time",
          description: "The delay before the <i>timerHandler</i> callback
                        will be generated.",
        },
        {
          type: "sl_zigbee_event_units_t",
          name: "units",
          description: "The units for <i>time</i>.",
        },
        {
          type: "bool",
          name: "repeat",
          description: "True if a <i>timerHandler</i> callback will be
                        generated repeatedly. False if only a single
                        <i>timerHandler</i> callback will be generated.",
        },
      ],
    },
    ## TIMER_HANDLER
    {
      value: "0x000F",
      needGeneratedHandler : "no",
      commandName: "timerHandler",
      description: "A callback from the timer.",
      responseArguments: [
        {
          type: "uint8_t",
          name: "timerId",
          description: "Which timer generated the callback (0 or 1).",
        },
      ],
    },
    ## DEBUG_WRITE
    {
      value: "0x0012",
      needGeneratedHandler : "no",
      commandName: "debugWrite",
      description: "Sends a debug message from the Host to the
                    Network Analyzer utility via the NCP.",
      commandArguments: [
        {
          type: "bool",
          name: "binaryMessage",
          description: "true if the message should be interpreted as
                        binary data, false if the message should be
                        interpreted as ASCII text.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The binary message.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## READ_AND_CLEAR_COUNTERS
    {
      value: "0x0065",
      needGeneratedHandler : "no",
      commandName: "readAndClearCounters",
      description: "Retrieves and clears Ember counters. See the
                    sl_zigbee_counter_type_t enumeration for the counter types.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint16_t[SL_ZIGBEE_COUNTER_TYPE_COUNT]",
          name: "values",
          description: "A list of all counter values ordered according
                        to the sl_zigbee_counter_type_t enumeration.",
        },
      ],
    },
    ## READ_COUNTERS
    {
      value: "0x00F1",
      needGeneratedHandler : "no",
      commandName: "readCounters",
      description: "Retrieves Ember counters. See the sl_zigbee_counter_type_t
                    enumeration for the counter types.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint16_t[SL_ZIGBEE_COUNTER_TYPE_COUNT]",
          name: "values",
          description: "A list of all counter values ordered according
                        to the sl_zigbee_counter_type_t enumeration.",
        },
      ],
    },
    ## COUNTER_ROLLOVER_HANDLER
    {
      value: "0x00F2",
      needGeneratedHandler : "no",
      commandName: "counterRolloverHandler",
      description: "This call is fired when a counter exceeds its
                    threshold",
      responseArguments: [
        {
          type: "sl_zigbee_counter_type_t",
          name: "type",
          description: "Type of Counter",
        },
      ],
    },
    ## DELAY_TEST
    {
      value: "0x009D",
      needGeneratedHandler : "no",
      commandName: "delayTest",
      description: "Used to test that UART flow control is working
                    correctly.",
      commandArguments: [
        {
          type: "uint16_t",
          name: "delay",
          description: "Data will not be read from the host for this
                        many milliseconds.",
        },
      ],
      responseArguments: [
      ],
    },
    ## GET_LIBRARY_STATUS
    {
      value: "0x0001",
      needGeneratedHandler : "no",
      commandName: "getLibraryStatus",
      description: "This retrieves the status of the passed library ID
                    to determine if it is compiled into the stack.",
      commandArguments: [
        {
          type: "sl_zigbee_library_id_t",
          name: "libraryId",
          description: "The ID of the library being queried.",
        },
      ],
      responseArguments: [
        {
          type: "sl_zigbee_library_status_t",
          name: "status",
          description: "The status of the library being queried.",
        },
      ],
    },
    ## GET_XNCP_INFO
    {
      value: "0x0013",
      needGeneratedHandler : "no",
      commandName: "getXncpInfo",
      description: "Allows the HOST to know whether the NCP is
                    running the XNCP library. If so, the response
                    contains also the manufacturer ID and the version
                    number of the XNCP application that is running on
                    the NCP.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the NCP is running the XNCP
                        library. SL_STATUS_INVALID_STATE otherwise.",
        },
        {
          type: "uint16_t",
          name: "manufacturerId",
          description: "The manufactured ID the user has defined in
                        the XNCP application.",
        },
        {
          type: "uint16_t",
          name: "versionNumber",
          description: "The version number of the XNCP application.",
        },
      ],
    },
    ## CUSTOM_FRAME
    {
      value: "0x0047",
      needGeneratedHandler : "no",
      commandName: "customFrame",
      description: "Provides the customer a custom EZSP frame. On the
                    NCP, these frames are only handled if the XNCP
                    library is included. On the NCP side these frames
                    are handled in the
                    sl_zigbee_xncp_incoming_custom_ezsp_message_cb() callback
                    function.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "payloadLength",
          description: "The length of the custom frame payload (maximum 119 bytes).",
        },
        {
          type: "uint8_t[payloadLength]",
          name: "payload",
          description: "The payload of the custom frame.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The status returned by the custom command.",
        },
        {
          type: "uint8_t",
          name: "replyLength",
          description: "The length of the response.",
        },
        {
          type: "uint8_t[replyLength]",
          name: "reply",
          description: "The response.",
        },
      ],
    },
    ## CUSTOM_FRAME_HANDLER
    {
      value: "0x0054",
      needGeneratedHandler : "no",
      commandName: "customFrameHandler",
      description: "A callback indicating a custom EZSP message has
                    been received.",
      responseArguments: [
        {
          type: "uint8_t",
          name: "payloadLength",
          description: "The length of the custom frame payload.",
        },
        {
          type: "uint8_t[payloadLength]",
          name: "payload",
          description: "The payload of the custom frame.",
        },
      ],
    },
    ## GET_EUI64
    {
      value: "0x0026",
      needGeneratedHandler : "no",
      commandName: "getEui64",
      description: "Returns the EUI64 ID of the local node.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "The 64-bit ID.",
        },
      ],
    },
    ## GET_NODE_ID
    {
      value: "0x0027",
      needGeneratedHandler : "no",
      commandName: "getNodeId",
      description: "Returns the 16-bit node ID of the local node.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "nodeId",
          description: "The 16-bit ID.",
        },
      ],
    },
    ## GET_PHY_INTERFACE_COUNT
    {
      value: "0x00FC",
      needGeneratedHandler : "no",
      commandName: "getPhyInterfaceCount",
      description: "Returns number of phy interfaces present.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "interfaceCount",
          description: "Value indicate how many phy interfaces present.",
        },
      ],
    },
    ## GET_TRUE_RANDOM_ENTROPY_SOURCE
    {
      value: "0x004F",
      needGeneratedHandler : "no",
      commandName: "getTrueRandomEntropySource",
      description: "Returns the entropy source used for true random number
                    generation.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_zigbee_entropy_source_t",
          name: "entropySource",
          description: "Value indicates the used entropy source.",
        },
      ],
    },
    ## SETUP_DELAYED_JOIN
    {
      value: "0x003A",
      needGeneratedHandler: "yes",
      commandName: "setupDelayedJoin",
      description: "Extend a joiner's timeout to wait for the network key 
                    on the joiner default key timeout is 3 sec, and only 
                    values greater equal to 3 sec are accepted.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "networkKeyTimeoutS",
          description: "Network key timeout",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ##RADIO_GET_SCHEDULER_PRIORITIES
    {
      value: "0x012A",
      needGeneratedHandler: "yes",
      commandName: "radioGetSchedulerPriorities",
      description: "Get the current scheduler priorities for radio operations",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_802154_radio_priorities_t",
          name: "priorities",
          description: "The current priorities."
        }
      ],
    },
    ##RADIO_SET_SCHEDULER_PRIORITIES
    {
      value: "0x012B",
      needGeneratedHandler: "yes",
      commandName: "radioSetSchedulerPriorities",
      description: "Set the current scheduler priorities for radio operations",
      commandArguments: [
        {
          type: "sl_802154_radio_priorities_t",
          name: "priorities",
          description: "The current priorities."
        }
      ],
      responseArguments: [
      ],
    },
    ##RADIO_GET_SCHEDULER_SLIPTIME
    {
      value: "0x012C",
      needGeneratedHandler: "yes",
      commandName: "radioGetSchedulerSliptime",
      description: "Get the current multiprotocol sliptime",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint32_t[1]",
          name: "slipTime",
          description: "Value of the current slip time."
        }
      ],
    },
    ##RADIO_SET_SCHEDULER_SLIPTIME
    {
      value: "0x012D",
      needGeneratedHandler: "yes",
      commandName: "radioSetSchedulerSliptime",
      description: "Set the current multiprotocol sliptime",   
      commandArguments: [
        {
          type: "uint32_t",
          name: "slipTime",
          description: "Value of the current slip time."
        }
      ],
      responseArguments: [
      ],
    },
    ##COUNTER_REQUIRES_PHY_INDEX
    {
      value: "0x0132",
      needGeneratedHandler: "yes",
      commandName: "counterRequiresPhyIndex",
      description: "Check if a particular counter is one that could report from either a 2.4GHz or sub-GHz interface.",
      commandArguments: [
        {
          type: "sl_zigbee_counter_type_t",
          name: "counter",
          description: "The counter to be checked.",
        },
      ],
      responseArguments: [
        {
          type: "bool",
          name: "requires",
          description: "Whether this counter requires a PHY index when operating on a dual-PHY system."
        }
      ],
    },
    ##COUNTER_REQUIRES_DESTINATION_NODE_ID
    {
      value: "0x0133",
      needGeneratedHandler: "yes",
      commandName: "counterRequiresDestinationNodeId",
      description: "Check if a particular counter can report on the destination node ID they have been triggered from.",
      commandArguments: [
        {
          type: "sl_zigbee_counter_type_t",
          name: "counter",
          description: "The counter to be checked.",
        },
      ],
      responseArguments: [
        {
          type: "bool",
          name: "requires",
          description: "Whether this counter requires the destination node ID."
        }
      ],
    },
  ],

}
# END Utilities Frames

################################################################################
- {
  section: Networking Frames,

  ncpCpps: ~,

  typedefs: ~,

  enums: ~,

  frames: [
    ## SET_MANUFACTURER_CODE
    {
      value: "0x0015",
      needGeneratedHandler : "yes",
      commandName: "setManufacturerCode",
      description: "Sets the manufacturer code to the specified value.
                    The manufacturer code is one of the fields of the
                    node descriptor.",
      commandArguments: [
        {
          type: "uint16_t",
          name: "code",
          description: "The manufacturer code for the local node.",
        },
      ],
      responseArguments: [
          {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## GET_MANUFACTURER_CODE
    {
      value: "0x00CA",
      needGeneratedHandler : "yes",
      commandName: "getManufacturerCode",
      description: "Gets the manufacturer code to the specified value.
                    The manufacturer code is one of the fields of the
                    node descriptor.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint16_t",
          name: "code",
          description: "The manufacturer code for the local node.",
        },
      ],
    },
    ## SET_POWER_DESCRIPTOR
    {
      value: "0x0016",
      needGeneratedHandler : "yes",
      commandName: "setPowerDescriptor",
      description: "Sets the power descriptor to the specified value.
                    The power descriptor is a dynamic value. Therefore,
                    you should call this function whenever the value
                    changes.",
      commandArguments: [
          {
          type: "uint16_t",
          name: "descriptor",
          description: "The new power descriptor for the local node.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## NETWORK_INIT
    {
      value: "0x0017",
      needGeneratedHandler : "yes",
      commandName: "networkInit",
      description: "Resume network operation after a reboot. The node
                    retains its original type. This should be called on
                    startup whether or not the node was previously part
                    of a network. SL_STATUS_NOT_JOINED is returned if the
                    node is not part of a network. This command accepts
                    options to control the network initialization.",
      commandArguments: [
        {
          type: "sl_zigbee_network_init_struct_t",
          name: "networkInitStruct",
          description: "An sl_zigbee_network_init_struct_t containing the options
                        for initialization.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value that indicates one of the
                        following: successful initialization,
                        SL_STATUS_NOT_JOINED if the node is not part of a
                        network, or the reason for failure.",
        },
      ],
    },
    ## NETWORK_STATE
    {
      value: "0x0018",
      needGeneratedHandler : "yes",
      commandName: "networkState",
      description: "Returns a value indicating whether the node is
                    joining, joined to, or leaving a network.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_zigbee_network_status_t",
          name: "status",
          description: "An sl_zigbee_network_status_t value indicating the
                        current join status.",
        },
      ],
    },
    ## STACK_STATUS_HANDLER
    {
      value: "0x0019",
      needGeneratedHandler : "no",
      commandName: "stackStatusHandler",
      description: "A callback invoked when the status of the stack
                    changes. If the status parameter equals
                    SL_STATUS_NETWORK_UP, then the <i>getNetworkParameters</i>
                    command can be called to obtain the new network
                    parameters. If any of the parameters are being
                    stored in nonvolatile memory by the Host, the
                    stored values should be updated.",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Stack status",
        },
      ],
    },
    ## START_SCAN
    {
      value: "0x001A",
      needGeneratedHandler : "yes",
      commandName: "startScan",
      description: "This function will start a scan.",
      commandArguments: [
        {
          type: "sl_zigbee_ezsp_network_scan_type_t",
          name: "scanType",
          description: "Indicates the type of scan to be performed.
                        Possible values are: SL_ZIGBEE_EZSP_ENERGY_SCAN and
                        SL_ZIGBEE_EZSP_ACTIVE_SCAN. For each type, the respective
                        callback for reporting results is:
                        energyScanResultHandler and networkFoundHandler. The
                        energy scan and active scan report errors and
                        completion via the scanCompleteHandler.",
        },
        {
          type: "uint32_t",
          name: "channelMask",
          description: "Bits set as 1 indicate that this particular
                        channel should be scanned. Bits set to 0
                        indicate that this particular channel should not
                        be scanned. For example, a channelMask value of
                        0x00000001 would indicate that only channel 0
                        should be scanned. Valid channels range from 11
                        to 26 inclusive. This translates to a channel
                        mask value of 0x07FFF800. As a convenience, a
                        value of 0 is reinterpreted as the mask for
                        the current channel.",
        },
        {
          type: "uint8_t",
          name: "duration",
          description: "Sets the exponent of the number of scan
                        periods, where a scan period is 960 symbols.
                        The scan will occur for ((2^duration) + 1) scan
                        periods.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK signals that the scan successfully
                        started. Possible error responses and their
                        meanings: SL_STATUS_MAC_SCANNING, we are already
                        scanning; SL_STATUS_BAD_SCAN_DURATION, we have set
                        a duration value that is not 0..14 inclusive;
                        SL_STATUS_MAC_INCORRECT_SCAN_TYPE, we have requested an
                        undefined scanning type;
                        SL_STATUS_INVALID_CHANNEL_MASK, our channel mask
                        did not specify any valid channels.",
        },
      ],
    },
    ## ENERGY_SCAN_RESULT_HANDLER
    {
      value: "0x0048",
      needGeneratedHandler : "no",
      commandName: "energyScanResultHandler",
      description: "Reports the result of an energy scan for a single
                    channel. The scan is not complete until the
                    <i>scanCompleteHandler</i> callback is called.",
      responseArguments: [
        {
          type: "uint8_t",
          name: "channel",
          description: "The 802.15.4 channel number that was scanned.",
        },
        {
          type: "int8_t",
          name: "maxRssiValue",
          description: "The maximum RSSI value found on the channel.",
        },
      ],
    },
    ## NETWORK_FOUND_HANDLER
    {
      value: "0x001B",
      needGeneratedHandler : "no",
      commandName: "networkFoundHandler",
      description: "Reports that a network was found as a result of
                    a prior call to startScan. Gives the network
                    parameters useful for deciding which network to
                    join.",
      responseArguments: [
        {
          type: "sl_zigbee_zigbee_network_t",
          name: "networkFound",
          description: "The parameters associated with the network
                        found.",
        },
        {
          type: "uint8_t",
          name: "lastHopLqi",
          description: "Link quality of incoming packet from network.",
        },
        {
          type: "int8_t",
          name: "lastHopRssi",
          description: "Power (in dBm) of incoming packet."
        },
      ],
    },
    ## SCAN_COMPLETE_HANDLER
    {
      value: "0x001C",
      needGeneratedHandler : "no",
      commandName: "scanCompleteHandler",
      description: "Returns the status of the current scan of type
                    SL_ZIGBEE_EZSP_ENERGY_SCAN or SL_ZIGBEE_EZSP_ACTIVE_SCAN. SL_STATUS_OK
                    signals that the scan has completed. Other error
                    conditions signify a failure to scan on the channel
                    specified.",
      responseArguments: [
        {
          type: "uint8_t",
          name: "channel",
          description: "The channel on which the current error
                        occurred. Undefined for the case of
                        SL_STATUS_OK.",
        },
        {
          type: "sl_status_t",
          name: "status",
          description: "The error condition that occurred on the
                        current channel. Value will be SL_STATUS_OK when
                        the scan has completed.",
        },
      ],
    },
    ## UNUSED_PAN_ID_FOUND_HANDLER
    {
      value: "0x00D2",
      needGeneratedHandler : "no",
      commandName: "unusedPanIdFoundHandler",
      description: "This function returns an unused panID and channel pair
                    found via the find unused panId scan procedure.",
      responseArguments: [
        {
          type: "sl_802154_pan_id_t",
          name: "panId",
          description: "The unused panID which has been found.",
        },
        {
          type: "uint8_t",
          name: "channel",
          description: "The channel that the unused panID was found on.",
        },
      ],
    },
    ## FIND_UNUSED_PAN_ID
    {
      value: "0x00D3",
      needGeneratedHandler : "yes",
      commandName: "findUnusedPanId",
      description: "This function starts a series of scans which will return
                    an available panId.",
      commandArguments: [
        {
          type: "uint32_t",
          name: "channelMask",
          description: "The channels that will be scanned for available panIds.",
        },
        {
          type: "uint8_t",
          name: "duration",
          description: "The duration of the procedure.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The error condition that occurred during the scan. Value
                        will be SL_STATUS_OK if there are no errors."
        },
      ],
    },
    ## STOP_SCAN
    {
      value: "0x001D",
      needGeneratedHandler : "yes",
      commandName: "stopScan",
      description: "Terminates a scan in progress.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## FORM_NETWORK
    {
      value: "0x001E",
      needGeneratedHandler : "yes",
      commandName: "formNetwork",
      description: "Forms a new network by becoming the coordinator.",
      commandArguments: [
        {
          type: "sl_zigbee_network_parameters_t",
          name: "parameters",
          description: "Specification of the new network.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## JOIN_NETWORK
    {
      value: "0x001F",
      needGeneratedHandler : "yes",
      commandName: "joinNetwork",
      description: "Causes the stack to associate with the network
                    using the specified network parameters. It can take
                    several seconds for the stack to associate with the
                    local network. Do not send messages until the
                    <i>stackStatusHandler</i> callback informs you that
                    the stack is up.",
      commandArguments: [
        {
          type: "sl_zigbee_node_type_t",
          name: "nodeType",
          description: "Specification of the role that this node will
                        have in the network. This role must not be
                        SL_ZIGBEE_COORDINATOR. To be a coordinator, use the
                        <i>formNetwork</i> command.",
        },
        {
          type: "sl_zigbee_network_parameters_t",
          name: "parameters",
          description: "Specification of the network with which the
                        node should associate.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## JOIN_NETWORK_DIRECTLY
    {
      value: "0x003B",
      needGeneratedHandler : "yes",
      commandName: "joinNetworkDirectly",
      description: "Causes the stack to associate with the network
                    using the specified network parameters in the beacon
                    parameter. It can take several seconds for the stack to
                    associate with the local network. Do not send messages until
                    the <i>stackStatusHandler</i> callback informs you that the
                    stack is up. Unlike ::sli_zigbee_stack_join_network(), this function
                    does not issue an active scan before joining. Instead, it
                    will cause the local node to issue a MAC
                    Association Request directly to the specified target node.
                    It is assumed that the beacon parameter is an artifact after
                    issuing an active scan. (For more information, see
                    <i>sli_zigbee_stack_get_stored_beacon</i>.)",
      commandArguments: [
        {
          type: "sl_zigbee_node_type_t",
          name: "localNodeType",
          description: "Specifies the role that this node will
                        have in the network. This role must not be
                        SL_ZIGBEE_COORDINATOR. To be a coordinator, use the
                        <i>formNetwork</i> command.",
        },
        {
          type: "sl_zigbee_beacon_data_t",
          name: "beacon",
          description: "Specifies the network with which the node should
                        associate.",
        },
        {
          type: "int8_t",
          name: "radioTxPower",
          description: "The radio transmit power to use, specified in dBm.",
        },
        {
          type: "bool",
          name: "clearBeaconsAfterNetworkUp",
          description: "If true, clear beacons in cache upon join success. If join fail, do
          nothing.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## LEAVE_NETWORK
    {
      value: "0x0020",
      needGeneratedHandler : "yes",
      commandName: "leaveNetwork",
      description: "Causes the stack to leave the current network.
                    This generates a <i>stackStatusHandler</i> callback to
                    indicate that the network is down. The radio will
                    not be used until after sending a <i>formNetwork</i>
                    or <i>joinNetwork</i> command.",
      commandArguments: [
        {
          type: "sl_zigbee_leave_network_option_t",
          name: "options",
          description: "This parameter gives options when leave network",
        }
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## FIND_AND_REJOIN_NETWORK
    {
      value: "0x0021",
      needGeneratedHandler : "ezspyes",
      commandName: "findAndRejoinNetwork",
      description: "The application may call this function when contact
                    with the network has been lost. The most common
                    usage case is when an end device can no longer
                    communicate with its parent and wishes to find a
                    new one. Another case is when a device has missed
                    a Network Key update and no longer has the current
                    Network Key. <p> The stack will call
                    <i>sl_zigbee_ezsp_stack_status_handler</i> to indicate that the
                    network is down, then try to re-establish contact
                    with the network by performing an active scan,
                    choosing a network with matching extended pan id,
                    and sending a ZigBee network rejoin request. A
                    second call to the <i>sl_zigbee_ezsp_stack_status_handler</i>
                    callback indicates either the success or the failure
                    of the attempt. The process takes approximately 150
                    milliseconds per channel to complete. <p>",
      commandArguments: [
        {
          type: "bool",
          name: "haveCurrentNetworkKey",
          description: "This parameter tells the stack whether to try
                        to use the current network key. If it has the
                        current network key it will perform a secure
                        rejoin (encrypted). If this fails the device
                        should try an unsecure rejoin. If the Trust
                        Center allows the rejoin then the current
                        Network Key will be sent encrypted using the
                        device's Link Key.",
        },
        {
          type: "uint32_t",
          name: "channelMask",
          description: "A mask indicating the channels to be scanned.
                        See <i>sli_zigbee_stack_start_scan</i> for format details. A
                        value of 0 is reinterpreted as the mask for the
                        current channel.",
        },
        {
          type: "uint8_t",
          name: "reason",
          description: "A sl_zigbee_rejoin_reason_t variable which 
          could be passed in if there is actually a reason for rejoin, or could be left at 0xFF",
        },
        {
          type: "uint8_t",
          name: "nodeType",
          description: "The rejoin could be triggered with a different nodeType. 
          This value could be set to 0 or SL_ZIGBEE_DEVICE_TYPE_UNCHANGED if not needed.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## PERMIT_JOINING
    {
      value: "0x0022",
      needGeneratedHandler : "yes",
      commandName: "permitJoining",
      description: "Tells the stack to allow other nodes to join the
                    network with this node as their parent. Joining is
                    initially disabled by default.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "duration",
          description: "A value of 0x00 disables joining. A value of
                        0xFF enables joining. Any other value enables
                        joining for that number of seconds.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## CHILD_JOIN_HANDLER
    {
      value: "0x0023",
      needGeneratedHandler : "no",
      commandName: "childJoinHandler",
      description: "Indicates that a child has joined or left.",
      responseArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of the child of interest.",
        },
        {
          type: "bool",
          name: "joining",
          description: "True if the child is joining. False the child
                        is leaving.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "childId",
          description: "The node ID of the child.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "childEui64",
          description: "The EUI64 of the child.",
        },
        {
          type: "sl_zigbee_node_type_t",
          name: "childType",
          description: "The node type of the child.",
        },
      ],
    },
    ## ENERGY_SCAN_REQUEST
    {
      value: "0x009C",
      needGeneratedHandler : "yes",
      commandName: "energyScanRequest",
      description: "Sends a ZDO energy scan request. This request may
                    only be sent by the current network manager and
                    must be unicast, not broadcast. See ezsp-utils.h for
                    related macros sli_zigbee_stack_set_network_manager_request() and
                    sl_zigbee_change_channel_request().",
      commandArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "target",
          description: "The network address of the node to perform the
                        scan.",
        },
        {
          type: "uint32_t",
          name: "scanChannels",
          description: "A mask of the channels to be scanned",
        },
        {
          type: "uint8_t",
          name: "scanDuration",
          description: "How long to scan on each channel. Allowed
                        values are 0..5, with the scan times as
                        specified by 802.15.4 (0 = 31ms, 1 = 46ms, 2
                        = 77ms, 3 = 138ms, 4 = 261ms, 5 = 507ms).",
        },
        {
          type: "uint16_t",
          name: "scanCount",
          description: "The number of scans to be performed on each
                        channel (1..8).",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## GET_NETWORK_PARAMETERS
    {
      value: "0x0028",
      needGeneratedHandler : "ezspyes",
      commandName: "getNetworkParameters",
      description: "Returns the current network parameters.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "sl_zigbee_node_type_t",
          name: "nodeType",
          description: "An sl_zigbee_node_type_t value indicating the current
                        node type.",
        },
        {
          type: "sl_zigbee_network_parameters_t",
          name: "parameters",
          description: "The current network parameters.",
        },
      ],
    },
    ## GET_RADIO_PARAMETERS
    {
      value: "0x00FD",
      needGeneratedHandler : "yes",
      commandName: "getRadioParameters",
      description: "Returns the current radio parameters based on phy index.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "phyIndex",
          description: "Desired index of phy interface for radio
                        parameters.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "sl_zigbee_multi_phy_radio_parameters_t",
          name: "parameters",
          description: "The current radio parameters based on provided
                        phy index.",
        },
      ]
    },
    ## GET_PARENT_CHILD_PARAMETERS
    {
      value: "0x0029",
      needGeneratedHandler : "ezspyes",
      commandName: "getParentChildParameters",
      description: "Returns information about the children of the local
                    node and the parent of the local node.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "childCount",
          description: "The number of children the node currently has.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "parentEui64",
          description: "The parent's EUI64. The value is undefined for
                        nodes without parents (coordinators and nodes
                        that are not joined to a network).",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "parentNodeId",
          description: "The parent's node ID. The value is undefined
                        for nodes without parents (coordinators and nodes
                        that are not joined to a network).",
        },
      ],
    },
    ## ROUTER_CHILD_COUNT
    {
      value: "0x013B",
      needGeneratedHandler : "yes",
      commandName: "routerChildCount",
      description: "Return the number of router children that the node currently has.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "routerChildCount",
          description: "The number of router children.",
        },
      ],
    },
    ## MAX_CHILD_COUNT
    {
      value: "0x013C",
      needGeneratedHandler : "yes",
      commandName: "maxChildCount",
      description: "Return the maximum number of children for this node.
                    The return value is undefined for nodes that are not joined to a network.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "maxChildCount",
          description: "The maximum number of children.",
        },
      ],
    },
    ## MAX_ROUTER_CHILD_COUNT
    {
      value: "0x013D",
      needGeneratedHandler : "yes",
      commandName: "maxRouterChildCount",
      description: "Return the maximum number of router children for this node.
                    The return value is undefined for nodes that are not joined to a network.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "maxRouterChildCount",
          description: "The maximum number of router children.",
        },
      ],
    },
    ## GET_PARENT_INCOMING_NWK_FRAME_COUNTER
    {
      value: "0x013E",
      needGeneratedHandler : "yes",
      commandName: "getParentIncomingNwkFrameCounter",
      description: "",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint32_t",
          name: "parentIncomingNwkFrameCounter",
          description: "",
        },
      ],
    },
    ## SETS_PARENT_INCOMING_NWK_FRAME_COUNTER
    {
      value: "0x013F",
      needGeneratedHandler : "yes",
      commandName: "setParentIncomingNwkFrameCounter",
      description: "",
      commandArguments: [
        {
          type: "uint32_t",
          name: "value",
          description: ""
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## CURRENT_STACK_TASKS
    {
      value: "0x0145",
      needGeneratedHandler : "yes",
      commandName: "currentStackTasks",
      description: "Return a bitmask indicating the stack's current tasks.
                    The mask ::SL_ZIGBEE_HIGH_PRIORITY_TASKS defines which tasks are high
                    priority.  Devices should not sleep if any high priority tasks are active.
                    Active tasks that are not high priority are waiting for
                    messages to arrive from other devices.  If there are active tasks,
                    but no high priority ones, the device may sleep but should periodically
                    wake up and call ::emberPollForData() in order to receive messages.  Parents
                    will hold messages for ::SL_ZIGBEE_INDIRECT_TRANSMISSION_TIMEOUT milliseconds
                    before discarding them.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint16_t",
          name: "activeTasks",
          description: "A bitmask of the stack's active tasks.",
        },
      ],
    },
    ## OK_TO_NAP
    {
      value: "0x0146",
      needGeneratedHandler : "yes",
      commandName: "okToNap",
      description: "Indicate whether the stack is currently in a state where
                    there are no high-priority tasks, allowing the device to sleep.

                    There may be tasks expecting incoming messages, in which case the device should
                    periodically wake up and call ::emberPollForData() in order to receive messages.
                    This function can only be called when the node type is
                    ::SL_ZIGBEE_SLEEPY_END_DEVICE",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "bool",
          name: "value",
          description: "True if the application may sleep but the stack may be expecting
                        incoming messages.",
        },
      ],
    },
    ## PARENT_TOKEN_SET
    {
      value: "0x0140",
      needGeneratedHandler : "yes",
      commandName: "parentTokenSet",
      description: "Indicate whether the parent token has been set by association.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "bool",
          name: "indicator",
          description: "True if the parent token has been set.",
        },
      ],
    },
    ## OK_TO_HIBERNATE
    {
      value: "0x0141",
      needGeneratedHandler : "yes",
      commandName: "okToHibernate",
      description: "Indicate whether the stack currently has any tasks pending.
                    If no tasks are pending, ::emberTick() does not need to be called until
                    the next time a stack API function is called. This function can only be
                    called when the node type is ::SL_ZIGBEE_SLEEPY_END_DEVICE.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "bool",
          name: "indicator",
          description: "True if the application may sleep for as long as it wishes.",
        },
      ],
    },
    ## OK_TO_LONG_POLL
    {
      value: "0x0142",
      needGeneratedHandler : "yes",
      commandName: "okToLongPoll",
      description: "Indicate whether the stack is currently in a state that does not
                    require the application to periodically poll.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "bool",
          name: "indicator",
          description: "True if the device may poll less frequently.",
        },
      ],
    },
    ## STACK_POWER_DOWN
   {
      value: "0x0143",
      needGeneratedHandler : "yes",
      commandName: "stackPowerDown",
      description: "Calling this function will render all other stack functions except
                    sli_zigbee_stack_stack_power_up() non-functional until the radio is powered back on.",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    ## STACK_POWER_UP
    {
      value: "0x0144",
      needGeneratedHandler : "yes",
      commandName: "stackPowerUp",
      description: "Initialize the radio.  Typically called coming out of deep sleep.
                    For non-sleepy devices, also turns the radio on and leaves it in RX mode.",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    ## GET_CHILD_DATA
    {
      value: "0x004A",
      needGeneratedHandler : "yes",
      commandName: "getChildData",
      description: "Returns information about a child of the local
                    node.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of the child of interest in the
                        child table. Possible indexes range from zero to
                        SL_ZIGBEE_CHILD_TABLE_SIZE.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if there is a child at
                        <i>index</i>. SL_STATUS_NOT_JOINED if there is no
                        child at <i>index</i>.",
        },
        {
          type: "sl_zigbee_child_data_t",
          name: "childData",
          description: "The data of the child.",
        },
      ],
    },
    ## SET_CHILD_DATA
    {
      value: "0x00AC",
      needGeneratedHandler : "yes",
      commandName: "setChildData",
      description: "Sets child data to the child table token.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of the child of interest in the
                        child table. Possible indexes range from zero to
                        (SL_ZIGBEE_CHILD_TABLE_SIZE - 1).",
        },
        {
          type: "sl_zigbee_child_data_t",
          name: "childData",
          description: "The data of the child.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the child data is set successfully at
                        <i>index</i>. SL_STATUS_INVALID_INDEX if provided
                        <i>index</i> is out of range.",
        },
      ],
    },
    ## CHILD_ID
    {
      value: "0x0106",
      needGeneratedHandler : "yes",
      commandName: "childId",
      description: "Convert a child index to a node ID",
      commandArguments: [
        {
          type: "uint8_t",
          name: "childIndex",
          description: "The index of the child of interest in the
                        child table. Possible indexes range from zero to
                        SL_ZIGBEE_CHILD_TABLE_SIZE.",
        },
      ],
      responseArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "childId",
          description: "The node ID of the child or SL_ZIGBEE_NULL_NODE_ID if
                        there isn't a child at the childIndex specified",
        },
      ],
    },
    ## CHILD_POWER
    {
      value: "0x0134",
      needGeneratedHandler : "yes",
      commandName: "childPower",
      description: "Return radio power value of the child from the given childIndex",
      commandArguments: [
        {
          type: "uint8_t",
          name: "childIndex",
          description: "The index of the child of interest in the
                        child table. Possible indexes range from zero to
                        SL_ZIGBEE_CHILD_TABLE_SIZE.",
        },
      ],
      responseArguments: [
        {
          type: "int8_t",
          name: "childPower",
          description: "The power of the child or maximum radio power, which is the power value
                        provided by the user while forming/joining a network if there isn't a
                        child at the childIndex specified",
        },
      ],
    },
    ## SET_CHILD_POWER
    {
      value: "0x0135",
      needGeneratedHandler : "yes",
      commandName: "setChildPower",
      description: "Set the radio power value for a given child index.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "childIndex",
          description: "The index.",
        },
        {
          type: "int8_t",
          name: "newPower",
          description: "The new power value.",
        }
      ],
      responseArguments: [
      ],
    },
    ## CHILD_INDEX
    {
      value: "0x0107",
      needGeneratedHandler : "yes",
      commandName: "childIndex",
      description: "Convert a node ID to a child index",
      commandArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "childId",
          description: "The node ID of the child",
        },
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "childIndex",
          description: "The child index or 0xFF if the node ID doesn't
                        belong to a child",
        },
      ],
    },

    ## GET_SOURCE_ROUTE_TABLE_TOTAL_SIZE
    {
        value: "0x00C3",
        needGeneratedHandler : "ezspyes",
      commandName: "getSourceRouteTableTotalSize",
        description: "Returns the source route table total size.",
        commandArguments: [
        ],
        responseArguments: [
            {
            type: "uint8_t",
            name: "sourceRouteTableTotalSize",
            description: "Total size of source route table.",
            },
        ],
    },

    ## GET_SOURCE_ROUTE_TABLE_FILLED_SIZE
    {
        value: "0x00C2",
        needGeneratedHandler : "ezspyes",
      commandName: "getSourceRouteTableFilledSize",
        description: "Returns the number of filled entries in source route table.",
        commandArguments: [
        ],
        responseArguments: [
            {
            type: "uint8_t",
            name: "sourceRouteTableFilledSize",
            description: "The number of filled entries in source route table.",
            },
        ],
    },

    ## GET_SOURCE_ROUTE_TABLE_ENTRY
    {

        value: "0x00C1",

        needGeneratedHandler : "ezspyes",
        commandName: "getSourceRouteTableEntry",

        description: "Returns information about a source route table entry",

        commandArguments: [

            {

            type: "uint8_t",

            name: "index",

            description: "The index of the entry of interest in the

            source route table. Possible indexes range from zero to

            SOURCE_ROUTE_TABLE_FILLED_SIZE.",

            },

        ],

        responseArguments: [

            {

            type: "sl_status_t",

            name: "status",

            description: "SL_STATUS_OK if there is source route entry at

            <i>index</i>. SL_STATUS_NOT_FOUND if there is no

            source route at <i>index</i>.",

            },

            {

            type: "sl_802154_short_addr_t",

            name: "destination",

            description: "The node ID of the destination in that entry.",

            },

            {

            type: "uint8_t",

            name: "closerIndex",

            description: "The closer node index for this source route table entry",

            },
        ],
    },


    ## GET_NEIGHBOR
    {
      value: "0x0079",
      needGeneratedHandler : "yes",
      commandName: "getNeighbor",
      description: "Returns the neighbor table entry at the given
                    index. The number of active neighbors can be
                    obtained using the neighborCount command.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of the neighbor of interest.
                        Neighbors are stored in ascending order by node
                        id, with all unused entries at the end of the
                        table.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_FAIL if the index is greater or
                        equal to the number of active neighbors, or if
                        the device is an end device. Returns
                        SL_STATUS_OK otherwise.",
        },
        {
          type: "sl_zigbee_neighbor_table_entry_t",
          name: "value",
          description: "The contents of the neighbor table entry.",
        },
      ],
    },

    ## GET_NEIGHBOR_FRAME_COUNTER
    {
      value: "0x003E",
      needGeneratedHandler : "yes",
      commandName: "getNeighborFrameCounter",
      description: "Return sl_status_t depending on whether the frame counter of the node is found in the
                    neighbor or child table. This function gets the last received frame counter
                    as found in the Network Auxiliary header for the specified neighbor or child",
      commandArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "eui64 of the node"
        }
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Return SL_STATUS_NOT_FOUND if the node is not found in the
                        neighbor or child table. Returns SL_STATUS_OK otherwise",
        },
        {
          type: "uint32_t",
          name: "returnFrameCounter",
          description: "Return the frame counter of the node from the neighbor or child table",
        },
      ],
    },
    ## SET_NEIGHBOR_FRAME_COUNTER
    {
      value: "0x00AD",
      needGeneratedHandler : "yes",
      commandName: "setNeighborFrameCounter",
      description: "Sets the frame counter for the neighbour or child.",
      commandArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "eui64 of the node"
        },
        {
          type: "uint32_t",
          name: "frameCounter",
          description: "Return the frame counter of the node from the neighbor or child table",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Return SL_STATUS_NOT_FOUND if the node is not found in the
                        neighbor or child table. Returns SL_STATUS_OK otherwise",
        },
      ],
    },
    ## SET_ROUTING_SHORTCUT_THRESHOLD
    {
      value: "0x00D0",
      needGeneratedHandler : "ezspyes",
      commandName: "setRoutingShortcutThreshold",
        description: "Sets the routing shortcut threshold to directly use a neighbor instead of performing routing.",
        commandArguments: [
          {
            type: "uint8_t",
            name: "costThresh",
            description: "The routing shortcut threshold to configure.",
          },
        ],
        responseArguments: [
          {
            type: "sl_status_t",
            name: "status",
            description: "An sl_status_t value indicating success or the
            reason for failure.",
          },
        ],
    },
    ## GET_ROUTING_SHORTCUT_THRESHOLD
    {
    value: "0x00D1",
    needGeneratedHandler : "ezspyes",
    commandName: "getRoutingShortcutThreshold",
    description: "Gets the routing shortcut threshold used to differentiate between directly using a neighbor vs. performing routing.",
    commandArguments: [
    ],
    responseArguments: [
    {
    type: "uint8_t",
    name: "routingShortcutThresh",
    description: "The routing shortcut threshold",
    },
    ],
    },

    ## NEIGHBOR_COUNT
    {
      value: "0x007A",
      needGeneratedHandler : "yes",
      commandName: "neighborCount",
      description: "Returns the number of active entries in the
                    neighbor table.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "value",
          description: "The number of active entries in the neighbor
                        table.",
        },
      ],
    },
    ## GET_ROUTE_TABLE_ENTRY
    {
      value: "0x007B",
      needGeneratedHandler : "yes",
      commandName: "getRouteTableEntry",
      description: "Returns the route table entry at the given index.
                    The route table size can be obtained using the
                    getConfigurationValue command.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of the route table entry of
                        interest.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_FAIL if the index is out of range
                        or the device is an end device, and
                        SL_STATUS_OK otherwise.",
        },
        {
          type: "sl_zigbee_route_table_entry_t",
          name: "value",
          description: "The contents of the route table entry.",
        },
      ],
    },
    ## SET_RADIO_POWER
    {
      value: "0x0099",
      needGeneratedHandler : "yes",
      commandName: "setRadioPower",
      description: "Sets the radio output power at which a node is
                    operating. Ember radios have discrete power settings.
                    For a list of available power settings, see the
                    technical specification for the RF communication
                    module in your Developer Kit. Note: Care should be
                    taken when using this API on a running network, as
                    it will directly impact the established link
                    qualities neighboring nodes have with the node on
                    which it is called. This can lead to disruption of
                    existing routes and erratic network behavior.",
      commandArguments: [
        {
          type: "int8_t",
          name: "power",
          description: "Desired radio output power, in dBm.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating the success or
                        failure of the command.",
        },
      ],
    },
    ## SET_RADIO_CHANNEL
    {
      value: "0x009A",
      needGeneratedHandler : "yes",
      commandName: "setRadioChannel",
      description: "Sets the channel to use for sending and receiving
                    messages. For a list of available radio channels,
                    see the technical specification for the RF
                    communication module in your Developer Kit. Note:
                    Care should be taken when using this API, as all
                    devices on a network must use the same channel.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "channel",
          description: "Desired radio channel.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating the success or
                        failure of the command.",
        },
      ],
    },
    ## GET_RADIO_CHANNEL
    {
      value: "0x00FF",
      needGeneratedHandler : "yes",
      commandName: "getRadioChannel",
      description: "Gets the channel in use for sending and receiving
                    messages.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "channel",
          description: "Current radio channel.",
        },
      ],
    },
    ## SET_RADIO_IEEE_802154_CCA_MODE
    {
      value: "0x0095",
      needGeneratedHandler : "yes",
      commandName: "setRadioIeee802154CcaMode",
      description: "Set the configured 802.15.4 CCA mode in the radio.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "ccaMode",
          description: "A RAIL_IEEE802154_CcaMode_t value.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating the success or
                        failure of the command.",
        },
      ],
    },
    ## SET_CONCENTRATOR
    {
      value: "0x0010",
      needGeneratedHandler : "ezspyes",
      commandName: "setConcentrator",
      description: "Enable/disable concentrator support.",
      commandArguments: [
        {
          type: "bool",
          name: "on",
          description: "If this bool is true the concentrator
                        support is enabled. Otherwise is disabled. If
                        this bool is false all the other arguments
                        are ignored.",
        },
        {
          type: "uint16_t",
          name: "concentratorType",
          description: "Must be either SL_ZIGBEE_HIGH_RAM_CONCENTRATOR or
                        SL_ZIGBEE_LOW_RAM_CONCENTRATOR. The former is used
                        when the caller has enough memory to store
                        source routes for the whole network. In that
                        case, remote nodes stop sending route records
                        once the concentrator has successfully received
                        one. The latter is used when the concentrator
                        has insufficient RAM to store all outbound
                        source routes. In that case, route records are
                        sent to the concentrator prior to every inbound
                        APS unicast.",
        },
        {
          type: "uint16_t",
          name: "minTime",
          description: "The minimum amount of time that must pass
                        between MTORR broadcasts.",
        },
        {
          type: "uint16_t",
          name: "maxTime",
          description: "The maximum amount of time that can pass
                        between MTORR broadcasts.",
        },
        {
          type: "uint8_t",
          name: "routeErrorThreshold",
          description: "The number of route errors that will trigger a
                        re-broadcast of the MTORR.",
        },
        {
          type: "uint8_t",
          name: "deliveryFailureThreshold",
          description: "The number of APS delivery failures that will
                        trigger a re-broadcast of the MTORR.",
        },
        {
          type: "uint8_t",
          name: "maxHops",
          description: "The maximum number of hops that the MTORR
                        broadcast will be allowed to have. A value of
                        0 will be converted to the SL_ZIGBEE_MAX_HOPS value
                        set by the stack.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## CONCENTRATOR_START_DISCOVERY
    {
      value: "0x014F",
      needGeneratedHandler : "yes",
      commandName: "concentratorStartDiscovery",
      description: "Starts periodic many-to-one route discovery.
                    Periodic discovery is started by default on bootup,
                    but this function may be used if discovery has been
                    stopped by a call to ::emberConcentratorStopDiscovery().",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    ## CONCENTRATOR_STOP_DISCOVERY
    {
      value: "0x0150",
      needGeneratedHandler : "yes",
      commandName: "concentratorStopDiscovery",
      description: "Stops periodic many-to-one route discovery.",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    ## CONCENTRATOR_NOTE_ROUTE_ERROR
    {
      value: "0x0151",
      needGeneratedHandler : "yes",
      commandName: "concentratorNoteRouteError",
      description: "Notes when a route error has occurred.",
      commandArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "nodeId",
          description: "",
        },
      ],
      responseArguments: [
      ],
    },
    ## SET_BROKEN_ROUTE_ERROR_CODE
        {
          value: "0x0011",
          needGeneratedHandler : "ezspyes",
      commandName: "setBrokenRouteErrorCode",
          description: "Sets the error code that is sent back from a router with a broken route. ",
          commandArguments: [
            {
            type: "uint8_t",
            name: "errorCode",
            description: "Desired error code.",
            },
          ],
          responseArguments: [
          {
            type: "sl_status_t",
            name: "status",
            description: "An sl_status_t value indicating the success or
            failure of the command.",
          },
        ],
    },

    ## MULTI_PHY_START
    {
      value: "0x00F8",
      needGeneratedHandler : "yes",
      commandName: "multiPhyStart",
      description: "This causes to initialize the desired radio interface other
                    than native and form a new network by becoming the coordinator
                    with same panId as native radio network.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "phyIndex",
          description: "Index of phy interface. The native phy index would
                        be always zero hence valid phy index starts from one.",
        },
        {
          type: "uint8_t",
          name: "page",
          description: "Desired radio channel page.",
        },
        {
          type: "uint8_t",
          name: "channel",
          description: "Desired radio channel.",
        },
        {
          type: "int8_t",
          name: "power",
          description: "Desired radio output power, in dBm.",
        },
        {
          type: "sl_zigbee_multi_phy_nwk_config_t",
          name: "bitmask",
          description: "Network configuration bitmask.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MULTI_PHY_STOP
    {
      value: "0x00F9",
      needGeneratedHandler : "yes",
      commandName: "multiPhyStop",
      description: "This causes to bring down the radio interface other than native.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "phyIndex",
          description: "Index of phy interface. The native phy index would
                        be always zero hence valid phy index starts from one.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MULTI_PHY_SET_RADIO_POWER
    {
      value: "0x00FA",
      needGeneratedHandler : "yes",
      commandName: "multiPhySetRadioPower",
      description: "Sets the radio output power for desired phy interface
                    at which a node is operating. Ember radios have discrete
                    power settings. For a list of available power settings,
                    see the technical specification for the RF communication
                    module in your Developer Kit. Note: Care should be
                    taken when using this api on a running network, as
                    it will directly impact the established link
                    qualities neighboring nodes have with the node on
                    which it is called. This can lead to disruption of
                    existing routes and erratic network behavior.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "phyIndex",
          description: "Index of phy interface. The native phy index would
                        be always zero hence valid phy index starts from one.",
        },
        {
          type: "int8_t",
          name: "power",
          description: "Desired radio output power, in dBm.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating the success or
                        failure of the command.",
        },
      ],
    },
    ## SEND_LINK_POWER_DELTA_REQUEST
    {
      value: "0x00F7",
      needGeneratedHandler : "yes",
      commandName: "sendLinkPowerDeltaRequest",
      description: "Send Link Power Delta Request from a child to its parent",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating the success or
          failure of sending the request.",
        },
      ],
    },

    ## MULTI_PHY_SET_RADIO_CHANNEL
    {
      value: "0x00FB",
      needGeneratedHandler : "yes",
      commandName: "multiPhySetRadioChannel",
      description: "Sets the channel for desired phy interface to use
                    for sending and receiving messages. For a list of
                    available radio pages and channels, see the technical
                    specification for the RF communication module in your
                    Developer Kit. Note: Care should be taken when using
                    this API, as all devices on a network must use the same
                    page and channel.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "phyIndex",
          description: "Index of phy interface. The native phy index would
                        be always zero hence valid phy index starts from one.",
        },
        {
          type: "uint8_t",
          name: "page",
          description: "Desired radio channel page.",
        },
        {
          type: "uint8_t",
          name: "channel",
          description: "Desired radio channel.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating the success or
                        failure of the command.",
        },
      ],
    },
    ## GET_DUTY_CYCLE_STATE
    {
      value: "0x0035",
      needGeneratedHandler : "yes",
      commandName: "getDutyCycleState",
      description: "Obtains the current duty cycle state.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating the success or
                        failure of the command.",
        },
        {
          type: "sl_zigbee_duty_cycle_state_t",
          name: "returnedState",
          description: "The current duty cycle state in effect.",
        },
      ],
    },
    ## SET_DUTY_CYCLE_LIMITS_IN_STACK
    {
      value: "0x0040",
      needGeneratedHandler : "yes",
      commandName: "setDutyCycleLimitsInStack",
      description: "Set the current duty cycle limits configuration.
                    The Default limits set by stack if this call is
                    not made.",
      commandArguments: [
      {
          type: "sl_zigbee_duty_cycle_limits_t",
          name: "limits",
          description: "The duty cycle limits configuration to utilize.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK  if the duty cycle limit configurations
                        set successfully, SL_STATUS_INVALID_PARAMETER if set illegal
                        value such as setting only one of the limits to default
                        or violates constraints Susp > Crit > Limi,
                        SL_STATUS_INVALID_STATE if device is operating on 2.4Ghz",
        },
      ],
    },
    ## GET_DUTY_CYCLE_LIMITS
    {
      value: "0x004B",
      needGeneratedHandler : "yes",
      commandName: "getDutyCycleLimits",
      description: "Obtains the current duty cycle limits that were previously
                    set by a call to sli_zigbee_stack_set_duty_cycle_limits_in_stack(), or
                    the defaults set by the stack if no set call was made.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating the success or
                        failure of the command.",
        },
        {
          type: "sl_zigbee_duty_cycle_limits_t",
          name: "returnedLimits",
          description: "Return current duty cycle limits if returnedLimits
                        is not NULL",
        },
      ],
    },
    ## GET_CURRENT_DUTY_CYCLE
    {
      value: "0x004C",
      needGeneratedHandler : "ezspyes",
      commandName: "getCurrentDutyCycle",
      description: "Returns the duty cycle of the stack's connected children
                    that are being monitored, up to maxDevices. It indicates the
                    amount of overall duty cycle they have consumed (up to the
                    suspend limit). The first entry is always the local stack's
                    nodeId, and thus the total aggregate duty cycle for the device.
                    The passed pointer arrayOfDeviceDutyCycles MUST have space
                    for maxDevices.",
      commandArguments: [
      {
          type: "uint8_t",
          name: "maxDevices",
          description: "Number of devices to retrieve consumed duty cycle.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK  if the duty cycles were read
                        successfully, SL_STATUS_INVALID_PARAMETER maxDevices is
                        greater than SL_ZIGBEE_MAX_END_DEVICE_CHILDREN + 1.",
        },
        {
          type: "uint8_t[134]",
          name: "arrayOfDeviceDutyCycles",
          description: "Consumed duty cycles up to maxDevices.
                        When the number of children that are being
                        monitored is less than maxDevices, the sl_802154_short_addr_t
                        element in the sl_zigbee_per_device_duty_cycle_t will be 0xFFFF.",
        },
      ],
    },
    ## DUTY_CYCLE_HANDLER
    {
      value: "0x004D",
      needGeneratedHandler : "no",
      commandName: "dutyCycleHandler",
      description: "Callback fires when the duty cycle state has changed",
      responseArguments: [
        {
          type: "uint8_t",
          name: "channelPage",
          description: "The channel page whose duty cycle state has changed.",
        },
        {
          type: "uint8_t",
          name: "channel",
          description: "The channel number whose duty cycle state has changed.",
        },
        {
          type: "sl_zigbee_duty_cycle_state_t",
          name: "state",
          description: "The current duty cycle state.",
        },
        {
          type: "uint8_t",
          name: "totalDevices",
          description: "The total number of connected end devices that are being
                        monitored for duty cycle.",
        },
        {
          type: "sl_zigbee_per_device_duty_cycle_t",
          name: "arrayOfDeviceDutyCycles",
          description: "Consumed duty cycles of end devices that are being monitored.
                        The first entry always be the local stack's nodeId,
                        and thus the total aggregate duty cycle for the device.",
        },
      ],
    },
    ## SET_NUM_BEACONS_TO_STORE
    {
      value: "0x0037",
      needGeneratedHandler : "yes",
      commandName: "setNumBeaconsToStore",
      description: "Configure the number of beacons to store when issuing active scans 
                    for networks.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "numBeacons",
          description: "The number of beacons to cache when scanning.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_INVALID_PARAMETER if numBeacons is greater than 
                        SL_ZIGBEE_MAX_BEACONS_TO_STORE, otherwise SL_STATUS_OK",
        },
      ],
    },
    ## GET_STORED_BEACON
    {
      value: "0x0004",
      needGeneratedHandler : "yes",
      commandName: "getStoredBeacon",
      description: "Fetches the specified beacon in the cache. Beacons are stored in cache
      after issuing an active scan.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "beacon_number",
          description: "The beacon index to fetch. Valid values range from 0 to
          <i>sli_zigbee_stack_get_num_stored_beacons</i>-1.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An appropriate sl_status_t status code.",
        },
        {
          type: "sl_zigbee_beacon_data_t",
          name: "beacon",
          description: "The beacon to populate upon success.",
        },
      ],
    },
    ## GET_NUM_STORED_BEACONS
    {
      value: "0x0008",
      needGeneratedHandler : "yes",
      commandName: "getNumStoredBeacons",
      description: "Returns the number of cached beacons that have been
      collected from a scan.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "numBeacons",
          description: "The number of cached beacons that have been collected
          from a scan.",
        },
      ],
    },
    ## CLEAR_STORED_BEACONS
    {
      value: "0x003C",
      needGeneratedHandler : "yes",
      commandName: "clearStoredBeacons",
      description: "Clears all cached beacons that have been collected from a
      scan.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## SET_LOGICAL_AND_RADIO_CHANNEL
    {
      value: "0x00B9",
      needGeneratedHandler : "yes",
      commandName: "setLogicalAndRadioChannel",
      description: "This call sets the radio channel in the stack and
                    propagates the information to the hardware.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "radioChannel",
          description: "The radio channel to be set.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## SLEEPY_TO_SLEEPY_NETWORK_START
    {
      value: "0x0119",
      needGeneratedHandler: "yes",
      commandName: "sleepyToSleepyNetworkStart",
      description: "Form a new sleepy-to-sleepy network.  If the network is using security, 
                    the device must call sli_zigbee_stack_set_initial_security_state() first.",
      commandArguments: [
        {
          type: "sl_zigbee_network_parameters_t",
          name: "parameters",
          description: "Specification of the new network.",
        },
        {
          type: "bool",
          name: "initiator",
          description: "Whether this device is initiating or joining the network.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or a reason for failure.",
        },
      ],
    },
    ## SEND_ZIGBEE_LEAVE
    {
      value:  "0x011A",
      needGeneratedHandler: "yes",
      commandName: "sendZigbeeLeave",
      description: "Send a Zigbee NWK Leave command to the destination.",
      commandArguments:
      [
        {
          type: "sl_802154_pan_id_t",
          name: "destination",
          description: "Node ID of the device being told to leave.",
        },
        {
          type: "sl_zigbee_leave_request_flags_t",
          name: "flags",
          description:  "Bitmask indicating additional considerations for the leave request.",
        },
      ],
      responseArguments:
      [
        {
          type: "sl_status_t",
          name: "status",
          description: "Status indicating success or a reason for failure.
          Call is invalid if destination is on network or is the local node.",
        }
      ],
    },
    ## GET_PERMIT_JOINING
    {
      value: "0x011F",
      needGeneratedHandler: "yes",
      commandName: "getPermitJoining",
      description: "Indicate the state of permit joining in MAC.",
      commandArguments:
      [
      ],
      responseArguments:
      [
        {
          type:  "bool",
          name:  "joiningPermitted",
          description: "Whether the current network permits joining."
        },
      ],
    },
    ## GET_EXTENDED_PAN_ID
    {
      value: "0x0127",
      needGeneratedHandler: "yes",
      commandName: "getExtendedPanId",
      description: "Get the 8-byte extended PAN ID of this node.",
      commandArguments:
      [
      ],
      responseArguments:
      [
        {
          type:  "uint8_t[8]",
          name:  "extendedPanId",
          description: "Extended PAN ID of this node.  Valid only if it is currently on a network."
        },
      ],
    },
    ## GET_CURRENT_NETWORK
    {
      value: "0x014E",
      needGeneratedHandler: "yes",
      commandName: "getCurrentNetwork",
      description: "Get the current network.",
      commandArguments:
      [
      ],
      responseArguments:
      [
        {
          type: "uint8_t",
          name: "index",
          description: "Return the current network index.",
        },
      ],
    },
    ## SET_INITIAL_NEIGHBOR_OUTGOING_COST
    {
      value: "0x0122",
      needGeneratedHandler: "yes",
      commandName: "setInitialNeighborOutgoingCost",
      description: "Set initial outgoing link cost for neighbor.",
      commandArguments:
      [
        {
          type:  "uint8_t",
          name:  "cost",
          description:  "The new default cost. Valid values are 0, 1, 3, 5, and 7."
        },
      ],
      responseArguments:
      [
        {
          type:  "sl_status_t",
          name:  "status",
          description: "Whether or not initial cost was successfully set."
        },
      ],
    },
    ## GET_INITIAL_NEIGHBOR_OUTGOING_COST
    {
      value: "0x0123",
      needGeneratedHandler: "yes",
      commandName: "getInitialNeighborOutgoingCost",
      description: "Get initial outgoing link cost for neighbor.",
      commandArguments:
      [
      ],
      responseArguments:
      [
        {
          type:  "uint8_t",
          name:  "cost",
          description: "The default cost associated with new neighbor's outgoing links."
        },
      ],
    },
    ## RESET_REJOINING_NEIGHBORS_FRAME_COUNTER
    {
      value: "0x0124",
      needGeneratedHandler: "yes",
      commandName: "resetRejoiningNeighborsFrameCounter",
      description: "Indicate whether a rejoining neighbor should have its incoming frame counter reset.",
      commandArguments:
      [
        {
          type:  "bool",
          name:  "reset",
          description: "Whether or not a neighbor's incoming FC should be reset upon rejoining (true or false)."
        },
      ],
      responseArguments:
      [
      ],
    },
    ## IS_RESET_REJOINING_NEIGHBORS_FRAME_COUNTER_ENABLED
    {
      value: "0x0125",
      needGeneratedHandler: "yes",
      commandName: "isResetRejoiningNeighborsFrameCounterEnabled",
      description: "Check whether a rejoining neighbor will have its incoming frame counter reset based on the currently set policy.",
      commandArguments:
      [
      ],
      responseArguments:
      [
        {
          type:  "bool",
          name:  "getsReset",
          description: "Whether or not a rejoining neighbor's incoming FC gets reset (true or false)."
        },
      ],
    },
  ],

}
# END Networking Frames

################################################################################
- {
  section: Binding Frames,

  ncpCpps: ~,

  typedefs: ~,

  enums: ~,

  frames: [
    ## CLEAR_BINDING_TABLE
    {
      value: "0x002A",
      needGeneratedHandler : "yes",
      commandName: "clearBindingTable",
      description: "Deletes all binding table entries.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## SET_BINDING
    {
      value: "0x002B",
      needGeneratedHandler : "ezspyes",
      commandName: "setBinding",
      description: "Sets an entry in the binding table.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of a binding table entry.",
        },
        {
          type: "sl_zigbee_binding_table_entry_t",
          name: "value",
          description: "The contents of the binding entry.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## GET_BINDING
    {
      value: "0x002C",
      needGeneratedHandler : "yes",
      commandName: "getBinding",
      description: "Gets an entry from the binding table.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of a binding table entry.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "sl_zigbee_binding_table_entry_t",
          name: "value",
          description: "The contents of the binding entry.",
        },
      ],
    },
    ## DELETE_BINDING
    {
      value: "0x002D",
      needGeneratedHandler : "ezspyes",
      commandName: "deleteBinding",
      description: "Deletes a binding table entry.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of a binding table entry.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## BINDING_IS_ACTIVE
    {
      value: "0x002E",
      needGeneratedHandler : "yes",
      commandName: "bindingIsActive",
      description: "Indicates whether any messages are currently being
                    sent using this binding table entry. Note that this
                    command does not indicate whether a binding is
                    clear. To determine whether a binding is clear,
                    check whether the type field of the
                    sl_zigbee_binding_table_entry_t has the value
                    SL_ZIGBEE_UNUSED_BINDING.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of a binding table entry.",
        },
      ],
      responseArguments: [
        {
          type: "bool",
          name: "active",
          description: "True if the binding table entry is active,
                        false otherwise.",
        },
      ],
    },
    ## GET_BINDING_REMOTE_NODE_ID
    {
      value: "0x002F",
      needGeneratedHandler : "yes",
      commandName: "getBindingRemoteNodeId",
      description: "Returns the node ID for the binding's destination,
                    if the ID is known. If a message is sent using
                    the binding and the destination's ID is not known,
                    the stack will discover the ID by broadcasting a
                    ZDO address request. The application can avoid the
                    need for this discovery by using
                    <i>setBindingRemoteNodeId</i> when it knows the
                    correct ID via some other means. The destination's
                    node ID is forgotten when the binding is changed,
                    when the local node reboots or, much more rarely,
                    when the destination node changes its ID in
                    response to an ID conflict.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of a binding table entry.",
        },
      ],
      responseArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "nodeId",
          description: "The short ID of the destination node or
                        SL_ZIGBEE_NULL_NODE_ID if no destination is known.",
        },
      ],
    },
    ## SET_BINDING_REMOTE_NODE_ID
    {
      value: "0x0030",
      needGeneratedHandler : "yes",
      commandName: "setBindingRemoteNodeId",
      description: "Set the node ID for the binding's destination. See
                    <i>getBindingRemoteNodeId</i> for a description.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of a binding table entry.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "nodeId",
          description: "The short ID of the destination node.",
        },
      ],
      responseArguments: [
      ],
    },
    ## REMOTE_SET_BINDING_HANDLER
    {
      value: "0x0031",
      needGeneratedHandler : "no",
      commandName: "remoteSetBindingHandler",
      description: "The NCP used the external binding modification
                    policy to decide how to handle a remote set
                    binding request. The Host cannot change the current
                    decision, but it can change the policy for future
                    decisions using the <i>setPolicy</i> command.",
      responseArguments: [
        {
          type: "sl_zigbee_binding_table_entry_t",
          name: "entry",
          description: "The requested binding.",
        },
        {
          type: "uint8_t",
          name: "index",
          description: "The index at which the binding was added.",
        },
        {
          type: "sl_status_t",
          name: "policyDecision",
          description: "SL_STATUS_OK if the binding was added to the
                        table and any other status if not.",
        },
      ],
    },
    ## REMOTE_DELETE_BINDING_HANDLER
    {
      value: "0x0032",
      needGeneratedHandler : "no",
      commandName: "remoteDeleteBindingHandler",
      description: "The NCP used the external binding modification
                    policy to decide how to handle a remote delete
                    binding request. The Host cannot change the current
                    decision, but it can change the policy for future
                    decisions using the <i>setPolicy</i> command.",
      responseArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of the binding whose deletion was
                        requested.",
        },
        {
          type: "sl_status_t",
          name: "policyDecision",
          description: "SL_STATUS_OK if the binding was removed from
                        the table and any other status if not.",
        },
      ],
    },
    ## ALT_MAC_INIT
    # {
    #   value: "0x0214",
    #   needGeneratedHandler: "no",
    #   commandName: "altMacInit",
    #   description: "Initializes alternate MAC interface for communication. This should be called from main initialization.",
    #   commandArguments:
    #   [
    #     {
    #       type:  "sl_zigbee_alt_mac_config_t",
    #       name:  "config",
    #       description: "*config Pointer to alternate MAC configuration(s).
    #                     - ::scanDuration scan duration in milliseconds for alternate MAC.
    #                     - ::macTransmit Register the transmit callback. It gets called
    #                     when there is a packet to transmit over alternate
    #                     MAC interface.",
    #     },
    #   ],
    #   responseArguments:
    #   [
    #     {
    #       type: "sl_zigbee_mac_interface_id_t",
    #       name: "interfaceId",
    #       description: "sl_zigbee_mac_interface_id_t Returns MAC interface Id. This needs
    #                     to provide with other MAC APIs to communicate
    #                     with Zigbee stack.",
    #     },
    #   ],
    # },
  ],

}
# END Binding Frames

################################################################################
- {
  section: Messaging Frames,

  ncpCpps: ~,

  typedefs: ~,

  enums: ~,

  frames: [
    ## MAXIMUM_PAYLOAD_LENGTH
    {
      value: "0x0033",
      needGeneratedHandler : "yes",
      commandName: "maximumPayloadLength",
      description: "Returns the maximum size of the payload. The size
                    depends on the security level in use.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "apsLength",
          description: "The maximum APS payload length.",
        },
      ],
    },
    ## SEND_UNICAST
    {
      value: "0x0034",
      needGeneratedHandler : "ezspyes",
      commandName: "sendUnicast",
      description: "Sends a unicast message as per the ZigBee
                    specification. The message will arrive at its
                    destination only if there is a known route to the
                    destination node. Setting the ENABLE_ROUTE_DISCOVERY
                    option will cause a route to be discovered if none
                    is known. Setting the FORCE_ROUTE_DISCOVERY option
                    will force route discovery. Routes to end-device
                    children of the local node are always known.
                    Setting the APS_RETRY option will cause the message
                    to be retransmitted until either a matching
                    acknowledgement is received or three transmissions
                    have been made. <b>Note:</b> Using the
                    FORCE_ROUTE_DISCOVERY option will cause the first
                    transmission to be consumed by a route request as
                    part of discovery, so the application payload of
                    this packet will not reach its destination on the
                    first attempt. If you want the packet to reach its
                    destination, the APS_RETRY option must be set so
                    that another attempt is made to transmit the
                    message with its application payload after the route
                    has been constructed. <b>Note:</b> When sending
                    fragmented messages, the stack will only assign a
                    new APS sequence number for the first fragment of
                    the message (i.e., SL_ZIGBEE_APS_OPTION_FRAGMENT is set
                    and the low-order byte of the groupId field in the
                    APS frame is zero). For all subsequent fragments of
                    the same message, the application must set the
                    sequence number field in the APS frame to the
                    sequence number assigned by the stack to the first
                    fragment.",
      commandArguments: [
        {
          type: "sl_zigbee_outgoing_message_type_t",
          name: "type",
          description: "Specifies the outgoing message type. Must be
                        one of SL_ZIGBEE_OUTGOING_DIRECT,
                        SL_ZIGBEE_OUTGOING_VIA_ADDRESS_TABLE, or
                        SL_ZIGBEE_OUTGOING_VIA_BINDING.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "indexOrDestination",
          description: "Depending on the type of addressing used, this
                        is either the sl_802154_short_addr_t of the destination, an
                        index into the address table, or an index into
                        the binding table.",
        },
        {
          type: "sl_zigbee_aps_frame_t",
          name: "apsFrame",
          description: "The APS frame which is to be added to the
                        message.",
        },
        {
          type: "uint16_t",
          name: "messageTag",
          description: "A value chosen by the Host. This value is
                        used in the <i>sl_zigbee_ezsp_message_sent_handler</i> response
                        to refer to this message.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "Content of the message.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "uint8_t",
          name: "sequence",
          description: "The sequence number that will be used when
                        this message is transmitted.",
        },
      ],
    },
    ## SEND_BROADCAST
    {
      value: "0x0036",
      needGeneratedHandler : "ezspyes",
      commandName: "sendBroadcast",
      description: "Sends a broadcast message as per the ZigBee
                    specification.",
      commandArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "alias",
          description: "The aliased source from which we send the broadcast.
                        This must be SL_ZIGBEE_NULL_NODE_ID if we do not need an aliased source",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "destination",
          description: "The destination to which to send the broadcast.
                        This must be one of the three ZigBee broadcast
                        addresses.",
        },
        {
          type: "uint8_t",
          name: "nwkSequence",
          description: "The alias nwk sequence number. this won't be used if there is no aliased source.",
        },
        {
          type: "sl_zigbee_aps_frame_t",
          name: "apsFrame",
          description: "The APS frame for the message.",
        },
        {
          type: "uint8_t",
          name: "radius",
          description: "The message will be delivered to all nodes
                        within <i>radius</i> hops of the sender. A
                        radius of zero is converted to SL_ZIGBEE_MAX_HOPS.",
        },
        {
          type: "uint16_t",
          name: "messageTag",
          description: "A value chosen by the Host. This value is
                        used in the <i>sl_zigbee_ezsp_message_sent_handler</i> response
                        to refer to this message.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The broadcast message.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "uint8_t",
          name: "apsSequence",
          description: "The APS sequence number that will be used when
                        this message is transmitted.",
        },
      ],
    },
    ## PROXY_NEXT_BROADCAST_FROM_LONG
    {
      value: "0x0066",
      needGeneratedHandler : "yes",
      commandName: "proxyNextBroadcastFromLong",
      description: "Sends proxied broadcast message for another node 
                    in conjunction with sl_zigbee_proxy_broadcast where a long
                    source is also specified in the NWK frame control.",
      commandArguments: [
        {
          type: "uint8_t[8]",
          name: "euiSource",
          description: "The long source from which to send the broadcast",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## SEND_MULTICAST
    {
      value: "0x0038",
      needGeneratedHandler : "ezspyes",
      commandName: "sendMulticast",
      description: "Sends a multicast message to all endpoints that
                    share a specific multicast ID and are within a
                    specified number of hops of the sender.",
      commandArguments: [
        {
          type: "sl_zigbee_aps_frame_t",
          name: "apsFrame",
          description: "The APS frame for the message. The multicast
                        will be sent to the groupId in this frame.",
        },
        {
          type: "uint8_t",
          name: "hops",
          description: "The message will be delivered to all nodes
                        within this number of hops of the sender. A
                        value of zero is converted to SL_ZIGBEE_MAX_HOPS.",
        },
        {
          type: "uint16_t",
          name: "broadcastAddr",
          description: "The number of hops that the message will be
                        forwarded by devices that are not members of
                        the group. A value of 7 or greater is treated
                        as infinite.",
        },
        {
          type: "uint16_t",
          name: "alias",
          description: "The alias source address",
        },
        {
          type: "uint8_t",
          name: "nwkSequence",
          description: "the alias sequence number",
        },
        {
          type: "uint16_t",
          name: "messageTag",
          description: "A value chosen by the Host. This value is
                        used in the <i>sl_zigbee_ezsp_message_sent_handler</i> response
                        to refer to this message.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The multicast message.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value. For any result other than
                        SL_STATUS_OK, the message will not be sent.
                        SL_STATUS_OK - The message has been submitted
                        for transmission. SL_STATUS_INVALID_INDEX - The
                        bindingTableIndex refers to a non-multicast
                        binding. SL_STATUS_NETWORK_DOWN - The node is not
                        part of a network. SL_STATUS_MESSAGE_TOO_LONG - The
                        message is too large to fit in a MAC layer
                        frame. SL_STATUS_ALLOCATION_FAILED - The free packet buffer
                        pool is empty. SL_STATUS_BUSY - Insufficient
                        resources available in Network or MAC layers to
                        send message.",
        },
        {
          type: "uint8_t",
          name: "sequence",
          description: "The sequence number that will be used when
                        this message is transmitted.",
        },
      ],
    },
    ## SEND_REPLY
    {
      value: "0x0039",
      needGeneratedHandler : "ezspyes",
      commandName: "sendReply",
      description: "Sends a reply to a received unicast message. The
                    <i>incomingMessageHandler</i> callback for the unicast
                    being replied to supplies the values for all the
                    parameters except the reply itself.",
      commandArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "sender",
          description: "Value supplied by incoming unicast.",
        },
        {
          type: "sl_zigbee_aps_frame_t",
          name: "apsFrame",
          description: "Value supplied by incoming unicast.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The reply message.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value. SL_STATUS_INVALID_STATE - The
                        SL_ZIGBEE_EZSP_UNICAST_REPLIES_POLICY is set to
                        SL_ZIGBEE_EZSP_HOST_WILL_NOT_SUPPLY_REPLY. This means the NCP
                        will automatically send an empty reply. The Host
                        must change the policy to
                        SL_ZIGBEE_EZSP_HOST_WILL_SUPPLY_REPLY before it can supply
                        the reply. There is one exception to this rule:
                        In the case of responses to message fragments,
                        the host must call sendReply when a message
                        fragment is received. In this case, the policy
                        set on the NCP does not matter. The NCP
                        expects a sendReply call from the Host for
                        message fragments regardless of the current
                        policy settings. SL_STATUS_ALLOCATION_FAILED - Not enough
                        memory was available to send the reply.
                        SL_STATUS_BUSY - Either no route or
                        insufficient resources available. SL_STATUS_OK -
                        The reply was successfully queued for
                        transmission.",
        },
      ],
    },
    ## MESSAGE_SENT_HANDLER
    {
      value: "0x003F",
      needGeneratedHandler : "no",
      commandName: "messageSentHandler",
      description: "A callback indicating the stack has completed
                    sending a message.",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value of SL_STATUS_OK if an ACK
                        was received from the destination or
                        SL_STATUS_ZIGBEE_DELIVERY_FAILED if no ACK was received.",
        },
        {
          type: "sl_zigbee_outgoing_message_type_t",
          name: "type",
          description: "The type of message sent.",
        },
        {
          type: "uint16_t",
          name: "indexOrDestination",
          description: "The destination to which the message was sent,
                        for direct unicasts, or the address table or
                        binding index for other unicasts. The value is
                        unspecified for multicasts and broadcasts.",
        },
        {
          type: "sl_zigbee_aps_frame_t",
          name: "apsFrame",
          description: "The APS frame for the message.",
        },
        {
          type: "uint16_t",
          name: "messageTag",
          description: "The value supplied by the Host in the
                        <i>sl_zigbee_ezsp_send_unicast</i>, <i>sl_zigbee_ezsp_send_broadcast</i> or
                        <i>sl_zigbee_ezsp_send_multicast</i> command.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The unicast message supplied by the Host. The
                        message contents are only included here if the
                        decision for the messageContentsInCallback policy
                        is messageTagAndContentsInCallback.",
        },
      ],
    },
    ## SEND_MANY_TO_ONE_ROUTE_REQUEST
    {
      value: "0x0041",
      needGeneratedHandler : "yes",
      commandName: "sendManyToOneRouteRequest",
      description: "Sends a route request packet that creates routes
                    from every node in the network back to this node.
                    This function should be called by an application
                    that wishes to communicate with many nodes, for
                    example, a gateway, central monitor, or controller.
                    A device using this function was referred to as an
                    'aggregator' in EmberZNet 2.x and earlier, and is
                    referred to as a 'concentrator' in the ZigBee
                    specification and EmberZNet 3. <p> This function
                    enables large scale networks, because the other
                    devices do not have to individually perform
                    bandwidth-intensive route discoveries. Instead, when a
                    remote node sends an APS unicast to a concentrator,
                    its network layer automatically delivers a special
                    route record packet first, which lists the network
                    ids of all the intermediate relays. The concentrator
                    can then use source routing to send outbound APS
                    unicasts. (A source routed message is one in which
                    the entire route is listed in the network layer
                    header.) This allows the concentrator to communicate
                    with thousands of devices without requiring large
                    route tables on neighboring nodes. <p> This function
                    is only available in ZigBee Pro (stack profile 2),
                    and cannot be called on end devices. Any router
                    can be a concentrator (not just the coordinator),
                    and there can be multiple concentrators on a
                    network. <p> Note that a concentrator does not
                    automatically obtain routes to all network nodes
                    after calling this function. Remote applications must
                    first initiate an inbound APS unicast. <p>
                    Many-to-one routes are not repaired automatically.
                    Instead, the concentrator application must call this
                    function to rediscover the routes as necessary, for
                    example, upon failure of a retried APS message. The
                    reason for this is that there is no scalable
                    one-size-fits-all route repair strategy. A common and
                    recommended strategy is for the concentrator
                    application to refresh the routes by calling this
                    function periodically.",
      commandArguments: [
        {
          type: "uint16_t",
          name: "concentratorType",
          description: "Must be either SL_ZIGBEE_HIGH_RAM_CONCENTRATOR or
                        SL_ZIGBEE_LOW_RAM_CONCENTRATOR. The former is used
                        when the caller has enough memory to store
                        source routes for the whole network. In that
                        case, remote nodes stop sending route records
                        once the concentrator has successfully received
                        one. The latter is used when the concentrator
                        has insufficient RAM to store all outbound
                        source routes. In that case, route records are
                        sent to the concentrator prior to every inbound
                        APS unicast.",
        },
        {
          type: "uint8_t",
          name: "radius",
          description: "The maximum number of hops the route request
                        will be relayed. A radius of zero is converted
                        to SL_ZIGBEE_MAX_HOPS",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the route request was
                        successfully submitted to the transmit queue, and
                        SL_STATUS_FAIL otherwise.",
        },
      ],
    },
    ## POLL_FOR_DATA
    {
      value: "0x0042",
      needGeneratedHandler : "ezspyes",
      commandName: "pollForData",
      description: "Periodically request any pending data from our
                    parent. Setting <i>interval</i> to 0 or <i>units</i>
                    to SL_ZIGBEE_EVENT_INACTIVE will generate a single poll.",
      commandArguments: [
        {
          type: "uint16_t",
          name: "interval",
          description: "The time between polls. Note that the timer
                        clock is free running and is not synchronized
                        with this command. This means that the time
                        will be between <i>interval</i> and
                        (<i>interval</i> - 1). The maximum interval is
                        32767.",
        },
        {
          type: "sl_zigbee_event_units_t",
          name: "units",
          description: "The units for <i>interval</i>.",
        },
        {
          type: "uint8_t",
          name: "failureLimit",
          description: "The number of poll failures that will be
                        tolerated before a <i>pollCompleteHandler</i>
                        callback is generated. A value of zero will
                        result in a callback for every poll. Any status
                        value apart from SL_STATUS_OK and
                        SL_STATUS_MAC_NO_DATA is counted as a failure.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The result of sending the first poll.",
        },
      ],
    },
    ## POLL_COMPLETE_HANDLER
    {
      value: "0x0043",
      needGeneratedHandler : "no",
      commandName: "pollCompleteHandler",
      description: "Indicates the result of a data poll to the parent
                    of the local node.",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value: SL_STATUS_OK - Data was
                        received in response to the poll.
                        SL_STATUS_MAC_NO_DATA - No data was pending.
                        SL_STATUS_ZIGBEE_DELIVERY_FAILED - The poll message could
                        not be sent. SL_STATUS_MAC_NO_ACK_RECEIVED - The poll
                        message was sent but not acknowledged by the
                        parent.",
        },
      ],
    },
    ## SET_MESSAGE_FLAG
    {
      value: "0x0136",
      needGeneratedHandler : "yes",
      commandName: "setMessageFlag",
      description: "Set a flag to indicate that a message is pending for a child.
                    The next time that the child polls, it will be informed that it has
                    a pending message. The message is sent from emberPollHandler, which is called
                    when the child requests data.",
      commandArguments: [
          {
          type: "sl_802154_short_addr_t",
          name: "childId",
          description: "The ID of the child that just polled for data."
          }
      ],
      responseArguments: [
          {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK - The next time that the child polls, it will be informed that it has pending data.
                        SL_STATUS_NOT_JOINED - The child identified by childId is not our child.",
          },
      ],
    },
    ## CLEAR_MESSAGE_FLAG
    {
      value: "0x0137",
      needGeneratedHandler : "yes",
      commandName: "clearMessageFlag",
      description: "Clear a flag to indicate that there are no more messages for a
                    child. The next time the child polls, it will be informed that it does not
                    have any pending messages.",
      commandArguments: [
          {
          type: "sl_802154_short_addr_t",
          name: "childId",
          description: "The ID of the child that no longer has pending messages."
          }
      ],
      responseArguments: [
          {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK - The next time that the child polls, it will be informed that it does not have any pending messages.
                        SL_STATUS_NOT_JOINED - The child identified by childId is not our child.",
          },
      ],
    },
    ## POLL_HANDLER
    {
      value: "0x0044",
      needGeneratedHandler : "no",
      commandName: "pollHandler",
      description: "Indicates that the local node received a data poll
                    from a child.",
      responseArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "childId",
          description: "The node ID of the child that is requesting
                        data.",
        },
        {
          type: "bool",
          name: "transmitExpected",
          description: "True if transmit is expected, false otherwise.",
        },
      ],
    },
    ## ADD_CHILD
    {
      value: "0x0138",
      needGeneratedHandler : "yes",
      commandName: "addChild",
      description: "Add a child to the child/neighbor table only on SoC,
                    allowing direct manipulation of these tables by the application.
                    This can affect the network functionality, and needs to be used wisely.
                    If used appropriately, the application can maintain more than the
                    maximum of children provided by the stack.",
      commandArguments: [
        {
        type: "sl_802154_short_addr_t",
        name: "shortId",
        description: "The preferred short ID of the node."
        },
        {
        type: "sl_802154_long_addr_t",
        name: "longId",
        description: "The long ID of the node."
        },
        {
        type: "sl_zigbee_node_type_t",
        name: "nodeType",
        description: "The nodetype e.g., SL_ZIGBEE_ROUTER defining, if this would be added to the child table or neighbor table."
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK - This node has been successfully added.
                        SL_STATUS_FAIL - The child was not added to the child/neighbor table.",
        },
      ],
    },
    ## REMOVE_CHILD
    {
      value: "0x0139",
      needGeneratedHandler : "yes",
      commandName: "removeChild",
      description: "Remove a node from child/neighbor table only on SoC,
                    allowing direct manipulation of these tables by the application.
                    This can affect the network functionality, and needs to be used wisely.",
      commandArguments: [
        {
        type: "sl_802154_long_addr_t",
        name: "childEui64",
        description: "The long ID of the node."
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK - This node has been successfully removed.
                        SL_STATUS_FAIL - The node was not found in either of the child or neighbor tables.",
        },
      ],
    },
    ## REMOVE_NEIGHBOR
    {
      value: "0x013A",
      needGeneratedHandler : "yes",
      commandName: "removeNeighbor",
      description: "Remove a neighbor from neighbor table only on SoC,
                    allowing direct manipulation of neighbor table by the application.
                    This can affect the network functionality, and needs to be used wisely.",
      commandArguments: [
        {
        type: "sl_802154_short_addr_t",
        name: "shortId",
        description: "The short ID of the neighbor."
        },
        {
        type: "sl_802154_long_addr_t",
        name: "longId",
        description: "The long ID of the neighbor."
        },
      ],
      responseArguments: [
      ],
    },
    ## INCOMING_MESSAGE_HANDLER
    {
      value: "0x0045",
      needGeneratedHandler : "no",
      commandName: "incomingMessageHandler",
      description: "A callback indicating a message has been received.",
      responseArguments: [
        {
          type: "sl_zigbee_incoming_message_type_t",
          name: "type",
          description: "The type of the incoming message. One of the
                        following: SL_ZIGBEE_INCOMING_UNICAST,
                        SL_ZIGBEE_INCOMING_UNICAST_REPLY,
                        SL_ZIGBEE_INCOMING_MULTICAST,
                        SL_ZIGBEE_INCOMING_MULTICAST_LOOPBACK,
                        SL_ZIGBEE_INCOMING_BROADCAST,
                        SL_ZIGBEE_INCOMING_BROADCAST_LOOPBACK",
        },
        {
          type: "sl_zigbee_aps_frame_t",
          name: "apsFrame",
          description: "The APS frame from the incoming message.",
        },
        {
          type: "sl_zigbee_rx_packet_info_t",
          name: "packetInfo",
          description: "Miscellanous message information.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>message</i> parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "message",
          description: "The incoming message.",
        },
      ],
    },
    ## SET_SOURCE_ROUTE_DISCOVERY_MODE
    {
      value: "0x005A",
      needGeneratedHandler : "ezspyes",
      commandName: "setSourceRouteDiscoveryMode",
      description: "Sets source route discovery(MTORR) mode to on, off, reschedule",
      commandArguments: [
        {
          type: "uint8_t",
          name: "mode",
          description: "Source route discovery mode: off:0, on:1, reschedule:2",
        },
      ],
      responseArguments: [
        {
          type: "uint32_t",
          name: "remainingTime",
          description: "Remaining time(ms) until next MTORR broadcast if the mode is on, MAX_INT32U_VALUE if the mode is off",
        },
      ],
    },

    ## INCOMING_MANY_TO_ONE_ROUTE_REQUEST_HANDLER
    {
      value: "0x007D",
      needGeneratedHandler : "no",
      commandName: "incomingManyToOneRouteRequestHandler",
      description: "A callback indicating that a many-to-one route to
                    the concentrator with the given short and long id
                    is available for use.",
      responseArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "source",
          description: "The short id of the concentrator.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "longId",
          description: "The EUI64 of the concentrator.",
        },
        {
          type: "uint8_t",
          name: "cost",
          description: "The path cost to the concentrator. The cost
                        may decrease as additional route request packets
                        for this discovery arrive, but the callback is
                        made only once.",
        },
      ],
    },
    ## INCOMING_ROUTE_ERROR_HANDLER
    {
      value: "0x0080",
      needGeneratedHandler : "no",
      commandName: "incomingRouteErrorHandler",
      description: "A callback invoked when a route error message is
                    received. The error indicates that a problem routing
                    to or from the target node was encountered.",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_ZIGBEE_SOURCE_ROUTE_FAILURE or
                        SL_STATUS_ZIGBEE_MANY_TO_ONE_ROUTE_FAILURE.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "target",
          description: "The short id of the remote node.",
        },
      ],
    },
    ## INCOMING_NETWORK_STATUS_HANDLER
    {
      value: "0x00C4",
      needGeneratedHandler : "no",
      commandName: "incomingNetworkStatusHandler",
      description: "A callback invoked when a network status/route error
                    message is received. The error
                    indicates that there was a problem sending/receiving
                    messages from the target node",
      responseArguments: [
        {
          type: "uint8_t",
          name: "errorCode",
          description: "One byte over-the-air error code from network status message",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "target",
          description: "The short ID of the remote node",
        },
      ],
    },
    ## INCOMING_ROUTE_RECORD_HANDLER
    {
      value: "0x0059",
      needGeneratedHandler : "no",
      commandName: "incomingRouteRecordHandler",
      description: "Reports the arrival of a route record command
                    frame.",
      responseArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "source",
          description: "The source of the route record.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "sourceEui",
          description: "The EUI64 of the source.",
        },
        {
          type: "uint8_t",
          name: "lastHopLqi",
          description: "The link quality from the node that last
                        relayed the route record.",
        },
        {
          type: "int8_t",
          name: "lastHopRssi",
          description: "The energy level (in units of dBm) observed
                        during the reception.",
        },
        {
          type: "uint8_t",
          name: "relayCount",
          description: "The number of relays in <i>relayList</i>.",
        },
        {
          type: "uint8_t[relayCount*2]",
          name: "relayList",
          description: "The route record. Each relay in the list is
                        an uint16_t node ID. The list is passed as uint8_t
                        * to avoid alignment problems.",
        },
      ],
    },
    ## SET_SOURCE_ROUTE
    {
      value: "0x00AE",
      needGeneratedHandler : "ezspyes",
      commandName: "setSourceRoute",
      description: "Supply a source route for the next outgoing
                    message.",
      commandArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "destination",
          description: "The destination of the source route.",
        },
        {
          type: "uint8_t",
          name: "relayCount",
          description: "The number of relays in <i>relayList</i>.",
        },
        {
          type: "uint16_t[relayCount]",
          name: "relayList",
          description: "The source route.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the source route was
                        successfully stored, and SL_STATUS_ALLOCATION_FAILED
                        otherwise.",
        },
      ],
    },

    ## UNICAST_CURRENT_NETWORK_KEY
    {
      value: "0x0050",
      needGeneratedHandler : "ezspyes",
      commandName: "unicastCurrentNetworkKey",
      description: "Send the network key to a destination.",
      commandArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "targetShort",
          description: "The destination node of the key.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "targetLong",
          description: "The long address of the destination node.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "parentShortId",
          description: "The parent node of the destination node.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if send was successful",
        },
      ],
    },
    ## ADDRESS_TABLE_ENTRY_IS_ACTIVE
    {
      value: "0x005B",
      needGeneratedHandler : "yes",
      commandName: "addressTableEntryIsActive",
      description: "Indicates whether any messages are currently being
                    sent using this address table entry. Note that this
                    function does not indicate whether the address table
                    entry is unused. To determine whether an address
                    table entry is unused, check the remote node ID.
                    The remote node ID will have the value
                    SL_ZIGBEE_TABLE_ENTRY_UNUSED_NODE_ID when the address table
                    entry is not in use.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "addressTableIndex",
          description: "The index of an address table entry.",
        },
      ],
      responseArguments: [
        {
          type: "bool",
          name: "active",
          description: "True if the address table entry is active,
                        false otherwise.",
        },
      ],
    },
    ## SET_ADDRESS_TABLE_INFO
    {
      value: "0x005C",
      needGeneratedHandler : "yes",
      commandName: "setAddressTableInfo",
      description: "Sets the EUI64 and short ID of an address table entry.
                    Usually the application will not need to set the
                    short ID in the address table. Once the remote
                    EUI64 is set the stack is capable of figuring out
                    the short ID on its own. However, in cases where
                    the application does set the short ID, the
                    application must set the remote EUI64 prior to
                    setting the short ID. This
                    function will also check other address table
                    entries, the child table and the neighbor table to
                    see if the node ID for the given EUI64 is already
                    known. If known then this function will set
                    node ID. If not known it will set the node ID to
                    SL_ZIGBEE_UNKNOWN_NODE_ID.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "addressTableIndex",
          description: "The index of an address table entry.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "The EUI64 to use for the address table entry.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "id",
          description: "The short ID corresponding to the remote node
                        whose EUI64 is stored in the address table at
                        the given index or SL_ZIGBEE_TABLE_ENTRY_UNUSED_NODE_ID
                        which indicates that the entry stored in the
                        address table at the given index is not in
                        use.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the information was successfully set,
                        and SL_STATUS_ZIGBEE_ADDRESS_TABLE_ENTRY_IS_ACTIVE otherwise.",
        },
      ],
    },
    ## GET_ADDRESS_TABLE_INFO
    {
      value: "0x005E",
      needGeneratedHandler : "yes",
      commandName: "getAddressTableInfo",
      description: "Gets the EUI64 and short ID of an address table entry.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "addressTableIndex",
          description: "The index of an address table entry.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "nodeId",
          description: "One of the following: The short ID
                        corresponding to the remote node whose EUI64 is
                        stored in the address table at the given index.
                        SL_ZIGBEE_UNKNOWN_NODE_ID - Indicates that the EUI64
                        stored in the address table at the given index
                        is valid but the short ID is currently unknown.
                        SL_ZIGBEE_DISCOVERY_ACTIVE_NODE_ID - Indicates that the
                        EUI64 stored in the address table at the given
                        location is valid and network address discovery
                        is underway. SL_ZIGBEE_TABLE_ENTRY_UNUSED_NODE_ID -
                        Indicates that the entry stored in the address
                        table at the given index is not in use.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "The EUI64 of the address table entry is copied
                        to this location.",
        },
      ],
    },
    ## SET_EXTENDED_TIMEOUT
    {
      value: "0x007E",
      needGeneratedHandler : "yes",
      commandName: "setExtendedTimeout",
      description: "Tells the stack whether or not the normal interval
                    between retransmissions of a retried unicast message
                    should be increased by
                    SL_ZIGBEE_INDIRECT_TRANSMISSION_TIMEOUT. The interval needs
                    to be increased when sending to a sleepy node so
                    that the message is not retransmitted until the
                    destination has had time to wake up and poll its
                    parent. The stack will automatically extend the
                    timeout: - For our own sleepy children. - When an
                    address response is received from a parent on
                    behalf of its child. - When an indirect transaction
                    expiry route error is received. - When an end
                    device announcement is received from a sleepy node.",
      commandArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "remoteEui64",
          description: "The address of the node for which the timeout
                        is to be set.",
        },
        {
          type: "bool",
          name: "extendedTimeout",
          description: "true if the retry interval should be increased
                        by SL_ZIGBEE_INDIRECT_TRANSMISSION_TIMEOUT. false if
                        the normal retry interval should be used.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure  "
        }
      ],
    },
    ## GET_EXTENDED_TIMEOUT
    {
      value: "0x007F",
      needGeneratedHandler : "yes",
      commandName: "getExtendedTimeout",
      description: "Indicates whether or not the stack will extend the
                    normal interval between retransmissions of a retried
                    unicast message by SL_ZIGBEE_INDIRECT_TRANSMISSION_TIMEOUT.",
      commandArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "remoteEui64",
          description: "The address of the node for which the timeout
                        is to be returned.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the retry interval will be increased
                        by SL_ZIGBEE_INDIRECT_TRANSMISSION_TIMEOUT and SL_STATUS_FAIL if
                        the normal retry interval will be used.",
        },
      ],
    },
    ## REPLACE_ADDRESS_TABLE_ENTRY
    {
      value: "0x0082",
      needGeneratedHandler : "ezspyes",
      commandName: "replaceAddressTableEntry",
      description: "Replaces the EUI64, short ID and extended timeout
                    setting of an address table entry. The previous
                    EUI64, short ID and extended timeout setting are
                    returned.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "addressTableIndex",
          description: "The index of the address table entry that will
                        be modified.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "newEui64",
          description: "The EUI64 to be written to the address table
                        entry.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "newId",
          description: "One of the following: The short ID
                        corresponding to the new EUI64.
                        SL_ZIGBEE_UNKNOWN_NODE_ID if the new EUI64 is valid
                        but the short ID is unknown and should be
                        discovered by the stack.
                        SL_ZIGBEE_TABLE_ENTRY_UNUSED_NODE_ID if the address
                        table entry is now unused.",
        },
        {
          type: "bool",
          name: "newExtendedTimeout",
          description: "true if the retry interval should be increased
                        by SL_ZIGBEE_INDIRECT_TRANSMISSION_TIMEOUT. false if
                        the normal retry interval should be used.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the EUI64, short ID and
                        extended timeout setting were successfully
                        modified, and SL_STATUS_ZIGBEE_ADDRESS_TABLE_ENTRY_IS_ACTIVE
                        otherwise.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "oldEui64",
          description: "The EUI64 of the address table entry before it
                        was modified.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "oldId",
          description: "One of the following: The short ID
                        corresponding to the EUI64 before it was
                        modified. SL_ZIGBEE_UNKNOWN_NODE_ID if the short ID
                        was unknown. SL_ZIGBEE_DISCOVERY_ACTIVE_NODE_ID if
                        discovery of the short ID was underway.
                        SL_ZIGBEE_TABLE_ENTRY_UNUSED_NODE_ID if the address
                        table entry was unused.",
        },
        {
          type: "bool",
          name: "oldExtendedTimeout",
          description: "true if the retry interval was being increased
                        by SL_ZIGBEE_INDIRECT_TRANSMISSION_TIMEOUT. false if
                        the normal retry interval was being used.",
        },
      ],
    },
    ## LOOKUP_NODE_ID_BY_EUI64
    {
      value: "0x0060",
      needGeneratedHandler : "yes",
      commandName: "lookupNodeIdByEui64",
      description: "Returns the node ID that corresponds to the
                    specified EUI64. The node ID is found by searching
                    through all stack tables for the specified EUI64.",
      commandArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "The EUI64 of the node to look up.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the short ID was found,
                        SL_STATUS_FAIL if the short ID is not known.",
        }, 
        {
          type: "sl_802154_short_addr_t",
          name: "nodeId",
          description: "The short ID of the node or SL_ZIGBEE_NULL_NODE_ID
                        if the short ID is not known.",
        },
      ],
    },
    ## LOOKUP_EUI64_BY_NODE_ID
    {
      value: "0x0061",
      needGeneratedHandler : "yes",
      commandName: "lookupEui64ByNodeId",
      description: "Returns the EUI64 that corresponds to the specified
                    node ID. The EUI64 is found by searching through
                    all stack tables for the specified node ID.",
      commandArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "nodeId",
          description: "The short ID of the node to look up.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the EUI64 was found,
                        SL_STATUS_FAIL if the EUI64 is not known.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "The EUI64 of the node.",
        },
      ],
    },
    ## GET_MULTICAST_TABLE_ENTRY
    {
      value: "0x0063",
      needGeneratedHandler : "ezspyes",
      commandName: "getMulticastTableEntry",
      description: "Gets an entry from the multicast table.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of a multicast table entry.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "sl_zigbee_multicast_table_entry_t",
          name: "value",
          description: "The contents of the multicast entry.",
        },
      ],
    },
    ## SET_MULTICAST_TABLE_ENTRY
    {
      value: "0x0064",
      needGeneratedHandler : "ezspyes",
      commandName: "setMulticastTableEntry",
      description: "Sets an entry in the multicast table.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index of a multicast table entry",
        },
        {
          type: "sl_zigbee_multicast_table_entry_t",
          name: "value",
          description: "The contents of the multicast entry.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## ID_CONFLICT_HANDLER
    {
      value: "0x007C",
      needGeneratedHandler : "no",
      commandName: "idConflictHandler",
      description: "A callback invoked by the EmberZNet stack when an
                    id conflict is discovered, that is, two different
                    nodes in the network were found to be using the
                    same short id. The stack automatically removes the
                    conflicting short id from its internal tables
                    (address, binding, route, neighbor, and child
                    tables). The application should discontinue any other
                    use of the id.",
      responseArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "id",
          description: "The short id for which a conflict was detected",
        },
      ],
    },
    ## WRITE_NODE_DATA
    {
      value: "0x00FE",
      needGeneratedHandler : "yes",
      commandName: "writeNodeData",
      description: "Write the current node Id, PAN ID, or Node type to the tokens",
      commandArguments: [
        {
          type: "bool",
          name: "erase",
          description: "Erase the node type or not",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
          reason for failure.",
        },
      ],
    },
    ## SEND_RAW_MESSAGE
    {
      value: "0x0051",
      needGeneratedHandler : "ezspyes",
      commandName: "sendRawMessage",
      description: "Transmits the given message without modification.
                    The MAC header is assumed to be configured in the
                    message at the time this function is called.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The raw message.",
        },
        {
          type: "uint8_t",
          name: "priority",
          description: "transmit priority.",
        },
        {
          type: "bool",
          name: "useCca",
          description: "Should we enable CCA or not.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MAC_PASSTHROUGH_MESSAGE_HANDLER
    {
      value: "0x0097",
      needGeneratedHandler : "no",
      commandName: "macPassthroughMessageHandler",
      description: "A callback invoked by the EmberZNet stack when a
                    MAC passthrough message is received.",
      responseArguments: [
        {
          type: "sl_zigbee_mac_passthrough_type_t",
          name: "messageType",
          description: "The type of MAC passthrough message received.",
        },
        {
          type: "sl_zigbee_rx_packet_info_t",
          name: "packetInfo",
          description: "Information about the incoming packet.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The raw message that was received.",
        },
      ],
    },
    ## MAC_FILTER_MATCH_MESSAGE_HANDLER
    {
      value: "0x0046",
      needGeneratedHandler : "no",
      commandName: "macFilterMatchMessageHandler",
      description: "A callback invoked by the EmberZNet stack when a
                    raw MAC message that has matched one of the
                    application's configured MAC filters.",
      responseArguments: [
        {
          type: "uint8_t",
          name: "filterIndexMatch",
          description: "The index of the filter that was matched.",
        },
        {
          type: "sl_zigbee_mac_passthrough_type_t",
          name: "legacyPassthroughType",
          description: "The type of MAC passthrough message received.",
        },
        {
          type: "sl_zigbee_rx_packet_info_t",
          name: "packetInfo",
          description: "Information about the incoming packet.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The raw message that was received.",
        },
      ],
    },
    ## RAW_TRANSMIT_COMPLETE_HANDLER
    {
      value: "0x0098",
      needGeneratedHandler : "no",
      commandName: "rawTransmitCompleteHandler",
      description: "A callback invoked by the EmberZNet stack when the
                    MAC has finished transmitting a raw message.",
      responseArguments: [
        {
          type: "uint8_t",
          name: "messageLength",
          description: "Length of the message that was transmitted.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The message that was transmitted.",
        },
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_OK if the transmission was successful,
                        or SL_STATUS_ZIGBEE_DELIVERY_FAILED if not",
        },
      ],
    },
    ## SET_MAC_POLL_FAILURE_WAIT_TIME
    {
      value: "0x00F4",
      needGeneratedHandler : "yes",
      commandName: "setMacPollFailureWaitTime",
      description: "This function is useful to sleepy end devices.
                    This function will set the retry interval
                    (in milliseconds) for mac data poll. This interval
                    is the time in milliseconds the device waits before
                    retrying a data poll when a MAC level data poll fails
                    for any reason.",
      commandArguments: [
        {
          type: "uint32_t",
          name: "waitBeforeRetryIntervalMs",
          description: "Time in milliseconds the device waits before
                        retrying a data poll when a MAC level data
                        poll fails for any reason.",
        },
      ],
      responseArguments: [
      ],
    },
    ## GET_MAX_MAC_RETRIES
    {
      value: "0x006A",
      needGeneratedHandler : "yes",
      commandName: "getMaxMacRetries",
      description: "Returns the maximum number of no-ack retries that will be attempted",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "retries",
          description: "Max MAC retries",
        },
      ],
    },
    ## SET_BEACON_CLASSIFICATION_PARAMS
    {
      value: "0x00EF",
      needGeneratedHandler : "yes",
      commandName: "setBeaconClassificationParams",
      description: "Sets the priority masks and related variables for choosing the best beacon.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The attempt to set the pramaters returns SL_STATUS_OK",
        },
        {
          type: "sl_zigbee_beacon_classification_params_t",
          name: "param",
          description: "Gets the beacon prioritization related variable",
        },
      ],
    },
    ## GET_BEACON_CLASSIFICATION_PARAMS
    {
      value: "0x00F3",
      needGeneratedHandler : "yes",
      commandName: "getBeaconClassificationParams",
      description: "Gets the priority masks and related variables for choosing the best beacon.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The attempt to get the pramaters returns SL_STATUS_OK",
        },
        {
          type: "sl_zigbee_beacon_classification_params_t",
          name: "param",
          description: "Gets the beacon prioritization related variable",
        },
      ],
    },
    ## PENDING_ACKED_MESSAGES
    {
      value: "0x0121",
      needGeneratedHandler : "yes",
      commandName: "pendingAckedMessages",
      description: "Indicate whether there are pending messages in the APS retry queue.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "bool",
          name: "pending_messages",
          description: "True if there is a pending message for this network in the APS retry queue, false if not.",
        },
      ],
    },
    ## RESCHEDULE_LINK_STATUS_MSG
    {
      value: "0x011B",
      needGeneratedHandler: "yes",
      commandName: "rescheduleLinkStatusMsg",
      description: "Reschedule sending link status message, with first one being sent immediately.",
      commandArguments: [
      ],
      responseArguments: [
            {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## SET_NWK_UPDATE_ID
    {
      value: "0x011D",
      needGeneratedHandler: "yes",
      commandName: "setNwkUpdateId",
      description: "Set the network update ID to the desired value. Must be
                   called before joining or forming the network.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "nwkUpdateId",
          description: "Desired value of the network update ID.",
        },
        {
          type: "bool",
          name: "set_when_on_network",
          description: "Set to true in case change should also apply when on network."
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Status of set operation for the network update ID.",
        },
      ],
    },
  ],

}
# END Messaging Frames

################################################################################
- {
  section: Security Frames,

  ncpCpps: ~,

  typedefs: ~,

  enums: ~,

  frames: [
    ## SET_INITIAL_SECURITY_STATE
    {
      value: "0x0068",
      needGeneratedHandler : "yes",
      commandName: "setInitialSecurityState",
      description: "Sets the security state that will be used by the
                    device when it forms or joins the network. This
                    call <b>should not</b> be used when restoring saved
                    network state via networkInit as this will result
                    in a loss of security data and will cause
                    communication problems when the device re-enters the
                    network.",
      commandArguments: [
        {
          type: "sl_zigbee_initial_security_state_t",
          name: "state",
          description: "The security configuration to be set.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "success",
          description: "The success or failure code of the operation.",
        },
      ],
    },
    ## GET_CURRENT_SECURITY_STATE
    {
      value: "0x0069",
      needGeneratedHandler : "yes",
      commandName: "getCurrentSecurityState",
      description: "Gets the current security state that is being used
                    by a device that is joined in the network.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The success or failure code of the operation.",
        },
        {
          type: "sl_zigbee_current_security_state_t",
          name: "state",
          description: "The security configuration in use by the stack.",
        },
      ],
    },
    ## SEC_MAN_EXPORT_KEY
    {
      value: "0x0114",
      needGeneratedHandler : "yes",
      commandName: "secManExportKey",
      description: "Exports a key from security manager based on passed context.",
      commandArguments: [
        {
          type: "sl_zigbee_sec_man_context_t",
          name: "context",
          description: "Metadata to identify the requested key.",
          combinedArg: "yes",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The success or failure code of the operation.",
        },
        {
          type: "sl_zigbee_sec_man_key_t",
          name: "key",
          description: "Data to store the exported key in."
        },
      ],
    },
    ## SEC_MAN_IMPORT_KEY
    {
      value: "0x0115",
      needGeneratedHandler : "yes",
      commandName: "secManImportKey",
      description: "Imports a key into security manager based on passed context.",
      commandArguments: [
        {
          type: "sl_zigbee_sec_man_context_t",
          name: "context",
          description: "Metadata to identify where the imported key should be stored.",
          combinedArg: "yes",
        },
        {
          type: "sl_zigbee_sec_man_key_t",
          name: "key",
          description: "The key to be imported."
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The success or failure code of the operation.",
        },
      ],
    },
    ## SWITCH_NETWORK_KEY_HANDLER
    {
      value: "0x006e",
      needGeneratedHandler : "no",
      commandName: "switchNetworkKeyHandler",
      description: "A callback to inform the application that the
                    Network Key has been updated and the node has been
                    switched over to use the new key. The actual key
                    being used is not passed up, but the sequence
                    number is.",
      responseArguments: [
        {
          type: "uint8_t",
          name: "sequenceNumber",
          description: "The sequence number of the new network key.",
        },
      ],
    },
    ## FIND_KEY_TABLE_ENTRY
    {
      value: "0x0075",
      needGeneratedHandler : "yes",
      commandName: "findKeyTableEntry",
      description: "This function searches through the Key Table and
                    tries to find the entry that matches the passed
                    search criteria.",
      commandArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "address",
          description: "The address to search for. Alternatively, all
                        zeros may be passed in to search for the first
                        empty entry.",
        },
        {
          type: "bool",
          name: "linkKey",
          description: "This indicates whether to search for an entry
                        that contains a link key or a master key. true
                        means to search for an entry with a Link Key.",
        },
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "This indicates the index of the entry that
                        matches the search criteria. A value of 0xFF is
                        returned if not matching entry is found.",
        },
      ],
    },
    ## SEND_TRUST_CENTER_LINK_KEY
    {
      value: "0x0067",
      needGeneratedHandler : "yes",
      commandName: "sendTrustCenterLinkKey",
      description: "This function sends an APS TransportKey command containing
                    the current trust center link key. The node to which the
                    command is sent is specified via the short and long address
                    arguments.",
      commandArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "destinationNodeId",
          description: "The short address of the node to which this command will
                        be sent",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "destinationEui64",
          description: "The long address of the node to which this command will
                        be sent",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success of failure of the
                        operation",
        },
      ],
    },
    ## ERASE_KEY_TABLE_ENTRY
    {
      value: "0x0076",
      needGeneratedHandler : "yes",
      commandName: "eraseKeyTableEntry",
      description: "This function erases the data in the key table
                    entry at the specified index. If the index is
                    invalid, false is returned.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "This indicates the index of entry to erase.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The success or failure of the operation.",
        },
      ],
    },
    ## CLEAR_KEY_TABLE
    {
      value: "0x00B1",
      needGeneratedHandler : "yes",
      commandName: "clearKeyTable",
      description: "This function clears the key table of the current
                    network.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The success or failure of the operation.",
        },
      ],
    },
    ## REQUEST_LINK_KEY
    {
      value: "0x0014",
      needGeneratedHandler : "yes",
      commandName: "requestLinkKey",
      description: "A function to request a Link Key from the Trust
                    Center with another device on the Network
                    (which could be the Trust Center). A Link Key with
                    the Trust Center is possible but the requesting
                    device cannot be the Trust Center. Link Keys are
                    optional in ZigBee Standard Security and thus the
                    stack cannot know whether the other device supports
                    them. If SL_ZIGBEE_REQUEST_KEY_TIMEOUT is non-zero on the
                    Trust Center and the partner device is not the
                    Trust Center, both devices must request keys with
                    their partner device within the time period. The
                    Trust Center only supports one outstanding key
                    request at a time and therefore will ignore other
                    requests. If the timeout is zero then the Trust
                    Center will immediately respond and not wait for
                    the second request. The Trust Center will always
                    immediately respond to requests for a Link Key with
                    it. Sleepy devices should poll at a higher rate
                    until a response is received or the request times
                    out. The success or failure of the request is
                    returned via sl_zigbee_ezsp_zigbee_key_establishment_handler(...)",
      commandArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "partner",
          description: "This is the IEEE address of the partner device
                        that will share the link key.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The success or failure of sending the request.
                        This is not the final result of the attempt.
                        sl_zigbee_ezsp_zigbee_key_establishment_handler(...) will return
                        that.",
        },
      ],
    },
    ## UPDATE_TC_LINK_KEY
    {
      value: "0x006C",
      needGeneratedHandler : "yes",
      commandName: "updateTcLinkKey",
      description: "Requests a new link key from the Trust Center. This
                    function starts by sending a Node Descriptor request to the
                    Trust Center to verify its R21+ stack version compliance. A
                    Request Key message will then be sent, followed by a Verify
                    Key Confirm message.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "maxAttempts",
          description: "The maximum number of attempts a node should make when
                        sending the Node Descriptor, Request Key, and Verify Key
                        Confirm messages. The number of attempts resets for each
                        message type sent (e.g., if maxAttempts is 3, up to 3
                        Node Descriptors are sent, up to 3 Request Keys, and up
                        to 3 Verify Key Confirm messages are sent).",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The success or failure of sending the request.
                        If the Node Descriptor is successfully transmitted,
                        sl_zigbee_ezsp_zigbee_key_establishment_handler(...) will be called at
                        a later time with a final status result.",
        },
      ],
    },
    ## ZIGBEE_KEY_ESTABLISHMENT_HANDLER
    {
      value: "0x009B",
      needGeneratedHandler : "no",
      commandName: "zigbeeKeyEstablishmentHandler",
      description: "This is a callback that indicates the success or
                    failure of an attempt to establish a key with a
                    partner device.",
      responseArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "partner",
          description: "This is the IEEE address of the partner that
                        the device successfully established a key with.
                        This value is all zeros on a failure.",
        },
        {
          type: "sl_zigbee_key_status_t",
          name: "status",
          description: "This is the status indicating what was
                        established or why the key establishment failed.",
        },
      ],
    },
    ## CLEAR_TRANSIENT_LINK_KEYS
    {
      value: "0x006B",
      needGeneratedHandler : "yes",
      commandName: "clearTransientLinkKeys",
      description: "Clear all of the transient link keys from RAM.",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    ## SEC_MAN_GET_NETWORK_KEY_INFO
    {
      value: "0x0116",
      needGeneratedHandler : "yes",
      commandName: "secManGetNetworkKeyInfo",
      description: "Retrieve information about the current and alternate network key,
                    excluding their contents.",
      commandArguments: [],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Success or failure of retrieving network key info.",
        },
        {
          type: "sl_zigbee_sec_man_network_key_info_t",
          name: "network_key_info",
          description: "Information about current and alternate network keys.",
        },
      ],
    },
    ## SEC_MAN_GET_APS_KEY_INFO
    {
      value: "0x010C",
      needGeneratedHandler : "yes",
      commandName: "secManGetApsKeyInfo",
      description: "Retrieve metadata about an APS link key.  Does not retrieve contents.",
      commandArguments: [
        {
          type: "sl_zigbee_sec_man_context_t",
          name: "context",
          description: "Context used to input information about key.",
          combinedArg: "yes",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Status of metadata retrieval operation.",
        },
        {
          type: "sl_zigbee_sec_man_aps_key_metadata_t",
          name: "key_data",
          description: "Metadata about the referenced key.",
        },
      ],
    },
    ##SEC_MAN_IMPORT_LINK_KEY
    {
      value: "0x010E",
      needGeneratedHandler : "yes",
      commandName: "secManImportLinkKey",
      description: "Import an application link key into the key table.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "Index where this key is to be imported to.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "address",
          description: "EUI64 this key is associated with."
        },
        {
          type: "sl_zigbee_sec_man_key_t",
          name: "plaintext_key",
          description: "The key data to be imported.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Status of key import operation.",
        },
      ],
    },
    ##SEC_MAN_EXPORT_LINK_KEY_BY_INDEX
    {
      value: "0x010F",
      needGeneratedHandler : "yes",
      commandName: "secManExportLinkKeyByIndex",
      description: "Export the link key at given index from the key table.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "Index of key to export.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Status of key export operation.",
        },
        {
          type: "sl_zigbee_sec_man_context_t",
          name: "context",
          description: "Context referencing the exported key.  Contains information like the EUI64 address it is associated with."
        },
        {
          type: "sl_zigbee_sec_man_key_t",
          name: "plaintext_key",
          description: "The exported key.",
        },
        {
          type: "sl_zigbee_sec_man_aps_key_metadata_t",
          name: "key_data",
          description: "Metadata about the key.",
        },
      ],
    },
    ##SEC_MAN_EXPORT_LINK_KEY_BY_EUI
    {
      value: "0x010D",
      needGeneratedHandler : "yes",
      commandName: "secManExportLinkKeyByEui",
      description: "Export the link key associated with the given EUI from the key table.",
      commandArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "eui",
          description: "EUI64 associated with the key to export.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Status of key export operation.",
        },
        {
          type: "sl_zigbee_sec_man_context_t",
          name: "context",
          description: "Context referring to the exported key, containing the table index that this key is located in.",
        },
        {
          type: "sl_zigbee_sec_man_key_t",
          name: "plaintext_key",
          description: "The exported key.",
        },      
        {
          type: "sl_zigbee_sec_man_aps_key_metadata_t",
          name: "key_data",
          description: "Metadata about the key.",
        },
      ],
    },
    ##SEC_MAN_CHECK_KEY_CONTEXT
    {
      value: "0x0110",
      needGeneratedHandler : "yes",
      commandName: "secManCheckKeyContext",
      description: "Check whether a key context can be used to load a valid key.",
      commandArguments: [
        {
          type: "sl_zigbee_sec_man_context_t",
          name: "context",
          description: "Context struct to check the validity of.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Validity of the checked context.",
        },
      ],
    },
    ##SEC_MAN_IMPORT_TRANSIENT_KEY
    {
      value: "0x0111",
      needGeneratedHandler: "yes",
      commandName: "secManImportTransientKey",
      description: "Import a transient link key.",
      commandArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "eui64",
          description: "EUI64 associated with this transient key.",
        },
        {
          type: "sl_zigbee_sec_man_key_t",
          name: "plaintext_key",
          description: "The key to import.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Status of key import operation.",
        },
      ],
    },
    ##SEC_MAN_EXPORT_TRANSIENT_KEY_BY_INDEX
    {
      value: "0x0112",
      needGeneratedHandler: "yes",
      commandName: "secManExportTransientKeyByIndex",
      description: "Export a transient link key from a given table index.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "Index to export from.",
        },
      ],
      responseArguments:[
        {
          type: "sl_status_t",
          name: "status",
          description: "Status of key export operation.",
        },
        {
          type: "sl_zigbee_sec_man_context_t",
          name: "context",
          description: "Context struct for export operation.",
        },
        {
          type: "sl_zigbee_sec_man_key_t",
          name: "plaintext_key",
          description: "The exported key.",
        },
        {
          type: "sl_zigbee_sec_man_aps_key_metadata_t",
          name: "key_data",
          description: "Metadata about the key.",
        },
      ]
    },
    ##SEC_MAN_EXPORT_TRANSIENT_KEY_BY_EUI
    {
      value: "0x0113",
      needGeneratedHandler: "yes",
      commandName: "secManExportTransientKeyByEui",
      description: "Export a transient link key associated with a given EUI64",
      commandArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "eui",
          description: "Index to export from.",
        },
      ],
      responseArguments:[
        {
          type: "sl_status_t",
          name: "status",
          description: "Status of key export operation.",
        },
        {
          type: "sl_zigbee_sec_man_context_t",
          name: "context",
          description: "Context struct for export operation.",
        },
        {
          type: "sl_zigbee_sec_man_key_t",
          name: "plaintext_key",
          description: "The exported key.",
        },
        {
          type: "sl_zigbee_sec_man_aps_key_metadata_t",
          name: "key_data",
          description: "Metadata about the key.",
        },
      ],
    },
    ##SET_INCOMING_TC_LINK_KEY_FRAME_COUNTER
    {
      value: "0x0128",
      needGeneratedHandler: "yes",
      commandName: "setIncomingTcLinkKeyFrameCounter",
      description: "Set the incoming TC link key frame counter to desired value.",
      commandArguments:[
        {
          type: "uint32_t",
          name: "frameCounter",
          description: "Value to set the frame counter to."
        }
      ],
      responseArguments:[
      ]
    },
    ##APS_CRYPT_MESSAGE
    {
      value: "0x0129",
      needGeneratedHandler: "yes",
      commandName: "apsCryptMessage",
      description: "Encrypt/decrypt a message in-place using APS.",
      commandArguments:[
        {
          type: "bool",
          name: "encrypt",
          description: "Encrypt (true) or decrypt (false) the message."
        },
        {
          type: "uint8_t",
          name: "length_combined_arg",
          description: "Length of the array containing message, needs to be long enough to include the auxiliary header and MIC."
        },
        {
          type: "uint8_t[length_combined_arg]",
          name: "message",
          description: "The message to be en/de-crypted.",
          combinedArg: "yes",
        },
        {
          type: "uint8_t",
          name: "apsHeaderEndIndex",
          description: "Index just past the APS frame.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "remoteEui64",
          description: "IEEE address of the device this message is associated with.",
        }
      ],
      responseArguments:[
        {
          type: "sl_status_t",
          name: "status",
          description: "Status of the encryption/decryption call."
        },
      ],
    },
  ],
}
# END Security Frames

################################################################################
- {
  section: Trust Center Frames,

  ncpCpps: ~,

  typedefs: ~,

  enums: ~,

  frames: [
    ## TRUST_CENTER_POST_JOIN_HANDLER
    {
      value: "0x0024",
      needGeneratedHandler : "no",
      commandName: "trustCenterPostJoinHandler",
      description: "The NCP uses the trust center behavior policy to
                    decide whether to allow a new node to join the
                    network (part of the trust center pre-join handler).
                    The Host cannot change the current
                    decision in this post-join callback, but it can change
                    the policy for future decisions using the <i>setPolicy</i>
                    command.",
      responseArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "newNodeId",
          description: "The Node Id of the node whose status changed",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "newNodeEui64",
          description: "The EUI64 of the node whose status changed.",
        },
        {
          type: "sl_zigbee_device_update_t",
          name: "status",
          description: "The status of the node: Secure Join/Rejoin,
                        Unsecure Join/Rejoin, Device left.",
        },
        {
          type: "sl_zigbee_join_decision_t",
          name: "policyDecision",
          description: "An sl_zigbee_join_decision_t reflecting the decision
                        made.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "parentOfNewNodeId",
          description: "The parent of the node whose status has
                        changed.",
        },
      ],
    },
    ## BROADCAST_NEXT_NETWORK_KEY
    {
      value: "0x0073",
      needGeneratedHandler : "yes",
      commandName: "broadcastNextNetworkKey",
      description: "This function broadcasts a new encryption key, but
                    does not tell the nodes in the network to start
                    using it. To tell nodes to switch to the new key,
                    use sl_zigbee_send_network_key_switch(). This is only valid
                    for the Trust Center/Coordinator. It is up to the
                    application to determine how quickly to send the
                    Switch Key after sending the alternate encryption
                    key.",
      commandArguments: [
        {
          type: "sl_zigbee_key_data_t",
          name: "key",
          description: "An optional pointer to a 16-byte encryption key
                        (SL_ZIGBEE_ENCRYPTION_KEY_SIZE). An all zero key may
                        be passed in, which will cause the stack to
                        randomly generate a new key.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "sl_status_t value that indicates the success or
                        failure of the command.",
        },
      ],
    },
    ## BROADCAST_NETWORK_KEY_SWITCH
    {
      value: "0x0074",
      needGeneratedHandler : "yes",
      commandName: "broadcastNetworkKeySwitch",
      description: "This function broadcasts a switch key message to
                    tell all nodes to change to the sequence number of
                    the previously sent Alternate Encryption Key.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "sl_status_t value that indicates the success or
                        failure of the command.",
        },
      ],
    },
    ## AES_MMO_HASH
    {
      value: "0x006F",
      needGeneratedHandler : "ezspyes",
      commandName: "aesMmoHash",
      description: "This routine processes the passed chunk of data
                    and updates the hash context based on it. If the
                    'finalize' parameter is not set, then the length of
                    the data passed in must be a multiple of 16. If
                    the 'finalize' parameter is set then the length can
                    be any value up 1-16, and the final hash value
                    will be calculated.",
      commandArguments: [
        {
          type: "sl_zigbee_aes_mmo_hash_context_t",
          name: "context",
          description: "The hash context to update.",
        },
        {
          type: "bool",
          name: "finalize",
          description: "This indicates whether the final hash value
                        should be calculated",
        },
        {
          type: "uint8_t",
          name: "length",
          description: "The length of the data to hash.",
        },
        {
          type: "uint8_t[length]",
          name: "data",
          description: "The data to hash.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The result of the operation",
        },
        {
          type: "sl_zigbee_aes_mmo_hash_context_t",
          name: "returnContext",
          description: "The updated hash context.",
        },
      ],
    },
    ## REMOVE_DEVICE
    {
      value: "0x00A8",
      needGeneratedHandler : "yes",
      commandName: "removeDevice",
      description: "This command sends an APS remove device using APS
                    encryption to the destination indicating either to
                    remove itself from the network, or one of its
                    children.",
      commandArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "destShort",
          description: "The node ID of the device that will receive
                        the message",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "destLong",
          description: "The long address (EUI64) of the device that
                        will receive the message.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "targetLong",
          description: "The long address (EUI64) of the device to be
                        removed.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success, or the
                        reason for failure",
        },
      ],
    },
    ## UNICAST_NWK_KEY_UPDATE
    {
      value: "0x00A9",
      needGeneratedHandler : "yes",
      commandName: "unicastNwkKeyUpdate",
      description: "This command will send a unicast transport key
                    message with a new NWK key to the specified
                    device. APS encryption using the device's existing
                    link key will be used.",
      commandArguments: [
        {
          type: "sl_802154_short_addr_t",
          name: "destShort",
          description: "The node ID of the device that will receive
                        the message",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "destLong",
          description: "The long address (EUI64) of the device that
                        will receive the message.",
        },
        {
          type: "sl_zigbee_key_data_t",
          name: "key",
          description: "The NWK key to send to the new device.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success, or the
                        reason for failure",
        },
      ],
    },
  ],

}
# END Trust Center Frames

################################################################################
- {
  section: Certificate Based Key Exchange (CBKE) Frames,

  ncpCpps: ~,

  typedefs: ~,

  enums: ~,

  frames: [
    ## GENERATE_CBKE_KEYS
    {
      value: "0x00A4",
      needGeneratedHandler : "yes",
      commandName: "generateCbkeKeys",
      description: "This call starts the generation of the ECC
                    Ephemeral Public/Private key pair. When complete it
                    stores the private key. The results are returned
                    via sl_zigbee_ezsp_generate_cbke_keys_handler().",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## GENERATE_CBKE_KEYS_HANDLER
    {
      value: "0x009E",
      needGeneratedHandler : "no",
      commandName: "generateCbkeKeysHandler",
      description: "A callback by the Crypto Engine indicating that a
                    new ephemeral public/private key pair has been
                    generated. The public/private key pair is stored on
                    the NCP, but only the associated public key is
                    returned to the host. The node's associated
                    certificate is also returned.",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The result of the CBKE operation.",
        },
        {
          type: "sl_zigbee_public_key_data_t",
          name: "ephemeralPublicKey",
          description: "The generated ephemeral public key.",
        },
      ],
    },
    ## CALCULATE_SMACS
    {
      value: "0x009F",
      needGeneratedHandler : "yes",
      commandName: "calculateSmacs",
      description: "Calculates the SMAC verification keys for both the
                    initiator and responder roles of CBKE using the
                    passed parameters and the stored public/private key
                    pair previously generated with
                    ezspGenerateKeysRetrieveCert(). It also stores the
                    unverified link key data in temporary storage on
                    the NCP until the key establishment is complete.",
      commandArguments: [
        {
          type: "bool",
          name: "amInitiator",
          description: "The role of this device in the Key
                        Establishment protocol.",
        },
        {
          type: "sl_zigbee_certificate_data_t",
          name: "partnerCertificate",
          description: "The key establishment partner's implicit
                        certificate.",
        },
        {
          type: "sl_zigbee_public_key_data_t",
          name: "partnerEphemeralPublicKey",
          description: "The key establishment partner's ephemeral public
                        key",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## CALCULATE_SMACS_HANDLER
    {
      value: "0x00A0",
      needGeneratedHandler : "no",
      commandName: "calculateSmacsHandler",
      description: "A callback to indicate that the NCP has finished
                    calculating the Secure Message Authentication Codes
                    (SMAC) for both the initiator and responder. The
                    associated link key is kept in temporary storage
                    until the host tells the NCP to store or discard
                    the key via sli_zigbee_stack_clear_temporary_data_maybe_store_link_key().",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The Result of the CBKE operation.",
        },
        {
          type: "sl_zigbee_smac_data_t",
          name: "initiatorSmac",
          description: "The calculated value of the initiator's SMAC",
        },
        {
          type: "sl_zigbee_smac_data_t",
          name: "responderSmac",
          description: "The calculated value of the responder's SMAC",
        },
      ],
    },
    ## GENERATE_CBKE_KEYS283K1
    {
      value: "0x00E8",
      needGeneratedHandler : "yes",
      commandName: "generateCbkeKeys283k1",
      description: "This call starts the generation of the ECC 283k1
                    curve Ephemeral Public/Private key pair. When
                    complete it stores the private key. The results are
                    returned via sl_zigbee_ezsp_generate_cbke_keys_283k1_handler().",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## GENERATE_CBKE_KEYS_283K1_HANDLER
    {
      value: "0x00E9",
      needGeneratedHandler : "no",
      commandName: "generateCbkeKeys283k1Handler",
      description: "A callback by the Crypto Engine indicating that a
                    new 283k1 ephemeral public/private key pair has been
                    generated. The public/private key pair is stored on
                    the NCP, but only the associated public key is
                    returned to the host. The node's associated
                    certificate is also returned.",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The result of the CBKE operation.",
        },
        {
          type: "sl_zigbee_public_key_283k1_data_t",
          name: "ephemeralPublicKey",
          description: "The generated ephemeral public key.",
        },
      ],
    },
    ## CALCULATE_SMACS283K1
    {
      value: "0x00EA",
      needGeneratedHandler : "yes",
      commandName: "calculateSmacs283k1",
      description: "Calculates the SMAC verification keys for both the
                    initiator and responder roles of CBKE for the 283k1
                    ECC curve using the passed parameters and the
                    stored public/private key pair previously generated
                    with sl_zigbee_ezsp_generate_keys_retrieve_cert_283k1(). It also
                    stores the unverified link key data in temporary
                    storage on the NCP until the key establishment is
                    complete.",
      commandArguments: [
        {
          type: "bool",
          name: "amInitiator",
          description: "The role of this device in the Key
                        Establishment protocol.",
        },
        {
          type: "sl_zigbee_certificate_283k1_data_t",
          name: "partnerCertificate",
          description: "The key establishment partner's implicit
                        certificate.",
        },
        {
          type: "sl_zigbee_public_key_283k1_data_t",
          name: "partnerEphemeralPublicKey",
          description: "The key establishment partner's ephemeral public
                        key",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## CALCULATE_SMACS_283K1_HANDLER
    {
      value: "0x00EB",
      needGeneratedHandler : "no",
      commandName: "calculateSmacs283k1Handler",
      description: "A callback to indicate that the NCP has finished
                    calculating the Secure Message Authentication Codes
                    (SMAC) for both the initiator and responder for the
                    CBKE 283k1 Library. The associated link key is kept
                    in temporary storage until the host tells the NCP
                    to store or discard the key via
                    sli_zigbee_stack_clear_temporary_data_maybe_store_link_key().",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The Result of the CBKE operation.",
        },
        {
          type: "sl_zigbee_smac_data_t",
          name: "initiatorSmac",
          description: "The calculated value of the initiator's SMAC",
        },
        {
          type: "sl_zigbee_smac_data_t",
          name: "responderSmac",
          description: "The calculated value of the responder's SMAC",
        },
      ],
    },
    ## CLEAR_TEMPORARY_DATA_MAYBE_STORE_LINK_KEY
    {
      value: "0x00A1",
      needGeneratedHandler : "yes",
      commandName: "clearTemporaryDataMaybeStoreLinkKey",
      description: "Clears the temporary data associated with CBKE and
                    the key establishment, most notably the ephemeral
                    public/private key pair. If storeLinKey is true it
                    moves the unverified link key stored in temporary
                    storage into the link key table. Otherwise it
                    discards the key.",
      commandArguments: [
        {
          type: "bool",
          name: "storeLinkKey",
          description: "A bool indicating whether to store (true) or
                        discard (false) the unverified link key derived
                        when sl_zigbee_ezsp_calculate_smacs() was previously called.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## CLEAR_TEMPORARY_DATA_MAYBE_STORE_LINK_KEY283K1
    {
      value: "0x00EE",
      needGeneratedHandler : "yes",
      commandName: "clearTemporaryDataMaybeStoreLinkKey283k1",
      description: "Clears the temporary data associated with CBKE and
                    the key establishment, most notably the ephemeral
                    public/private key pair. If storeLinKey is true it
                    moves the unverified link key stored in temporary
                    storage into the link key table. Otherwise it
                    discards the key.",
      commandArguments: [
        {
          type: "bool",
          name: "storeLinkKey",
          description: "A bool indicating whether to store (true) or
                        discard (false) the unverified link key derived
                        when sl_zigbee_ezsp_calculate_smacs() was previously called.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## GET_CERTIFICATE
    {
      value: "0x00A5",
      needGeneratedHandler : "yes",
      commandName: "getCertificate",
      description: "Retrieves the certificate installed on the NCP.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
        {
          type: "sl_zigbee_certificate_data_t",
          name: "localCert",
          description: "The locally installed certificate.",
        },
      ],
    },
    ## GET_CERTIFICATE283K1
    {
      value: "0x00EC",
      needGeneratedHandler : "yes",
      commandName: "getCertificate283k1",
      description: "Retrieves the 283k certificate installed on the
                    NCP.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
        {
          type: "sl_zigbee_certificate_283k1_data_t",
          name: "localCert",
          description: "The locally installed certificate.",
        },
      ],
    },
    ## DSA_SIGN
    {
      value: "0x00A6",
      needGeneratedHandler : "ezspyes",
      commandName: "dsaSign",
      description: "LEGACY FUNCTION: This functionality has been
                    replaced by a single bit in the sl_zigbee_aps_frame_t,
                    SL_ZIGBEE_APS_OPTION_DSA_SIGN. Devices wishing to send
                    signed messages should use that as it requires
                    fewer function calls and message buffering. The
                    dsaSignHandler response is still called when
                    SL_ZIGBEE_APS_OPTION_DSA_SIGN is used. However, this
                    function is still supported. This function begins
                    the process of signing the passed message contained
                    within the messageContents array. If no other ECC
                    operation is going on, it will immediately return
                    with SL_STATUS_IN_PROGRESS to indicate the start
                    of ECC operation. It will delay a period of time
                    to let APS retries take place, but then it will
                    shut down the radio and consume the CPU processing
                    until the signing is complete. This may take up to
                    1 second. The signed message will be returned in
                    the dsaSignHandler response. Note that the last byte
                    of the messageContents passed to this function has
                    special significance. As the typical use case for
                    DSA signing is to sign the ZCL payload of a DRLC
                    Report Event Status message in SE 1.0, there is
                    often both a signed portion (ZCL payload) and an
                    unsigned portion (ZCL header). The last byte in the
                    content of messageToSign is therefore used as a
                    special indicator to signify how many bytes of
                    leading data in the array should be excluded from
                    consideration during the signing process. If the
                    signature needs to cover the entire array (all
                    bytes except last one), the caller should ensure
                    that the last byte of messageContents is 0x00. When
                    the signature operation is complete, this final byte
                    will be replaced by the signature type indicator
                    (0x01 for ECDSA signatures), and the actual
                    signature will be appended to the original contents
                    after this byte.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The message contents for which to create a
                        signature. Per above notes, this may include a
                        leading portion of data not included in the
                        signature, in which case the last byte of this
                        array should be set to the index of the first
                        byte to be considered for signing. Otherwise,
                        the last byte of messageContents should be 0x00
                        to indicate that a signature should occur across
                        the entire contents.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "SL_STATUS_IN_PROGRESS if the stack has
                        queued up the operation for execution.
                        SL_STATUS_INVALID_STATE if the operation can't be
                        performed in this context, possibly because
                        another ECC operation is pending.",
        },
      ],
    },
    ## DSA_SIGN_HANDLER
    {
      value: "0x00A7",
      needGeneratedHandler : "no",
      commandName: "dsaSignHandler",
      description: "The handler that returns the results of the
                    signing operation. On success, the signature will be
                    appended to the original message (including the
                    signature type indicator that replaced the startIndex
                    field for the signing) and both are returned via
                    this callback.",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The result of the DSA signing operation.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The message and attached which includes the
                        original message and the appended signature.",
        },
      ],
    },
    ## DSA_VERIFY
    {
      value: "0x00A3",
      needGeneratedHandler : "yes",
      commandName: "dsaVerify",
      description: "Verify that signature of the associated message
                    digest was signed by the private key of the
                    associated certificate.",
      commandArguments: [
        {
          type: "sl_zigbee_message_digest_t",
          name: "digest",
          description: "The AES-MMO message digest of the signed data.
                        If dsaSign command was used to generate the
                        signature for this data, the final byte
                        (replaced by signature type of 0x01) in the
                        messageContents array passed to dsaSign is
                        included in the hash context used for the digest
                        calculation.",
        },
        {
          type: "sl_zigbee_certificate_data_t",
          name: "signerCertificate",
          description: "The certificate of the signer. Note that the
                        signer's certificate and the verifier's
                        certificate must both be issued by the same
                        Certificate Authority, so they should share the
                        same CA Public Key.",
        },
        {
          type: "sl_zigbee_signature_data_t",
          name: "receivedSig",
          description: "The signature of the signed data.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## DSA_VERIFY_HANDLER
    {
      value: "0x0078",
      needGeneratedHandler : "no",
      commandName: "dsaVerifyHandler",
      description: "This callback is executed by the stack when the
                    DSA verification has completed and has a result. If
                    the result is SL_STATUS_OK, the signature is valid.
                    If the result is SL_STATUS_ZIGBEE_SIGNATURE_VERIFY_FAILURE then
                    the signature is invalid. If the result is anything
                    else then the signature verify operation failed and
                    the validity is unknown.",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "The result of the DSA verification operation.",
        },
      ],
    },
    ## DSA_VERIFY_283K1
    {
      value: "0x00B0",
      needGeneratedHandler : "yes",
      commandName: "dsaVerify283k1",
      description: "Verify that signature of the associated message
                    digest was signed by the private key of the
                    associated certificate.",
      commandArguments: [
        {
          type: "sl_zigbee_message_digest_t",
          name: "digest",
          description: "The AES-MMO message digest of the signed data.
                        If dsaSign command was used to generate the
                        signature for this data, the final byte
                        (replaced by signature type of 0x01) in the
                        messageContents array passed to dsaSign is
                        included in the hash context used for the digest
                        calculation.",
        },
        {
          type: "sl_zigbee_certificate_283k1_data_t",
          name: "signerCertificate",
          description: "The certificate of the signer. Note that the
                        signer's certificate and the verifier's
                        certificate must both be issued by the same
                        Certificate Authority, so they should share the
                        same CA Public Key.",
        },
        {
          type: "sl_zigbee_signature_283k1_data_t",
          name: "receivedSig",
          description: "The signature of the signed data.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## SET_PREINSTALLED_CBKE_DATA
    {
      value: "0x00A2",
      needGeneratedHandler : "yes",
      commandName: "setPreinstalledCbkeData",
      description: "Sets the device's CA public key, local certificate,
                    and static private key on the NCP associated with
                    this node.",
      commandArguments: [
        {
          type: "sl_zigbee_public_key_data_t",
          name: "caPublic",
          description: "The Certificate Authority's public key.",
        },
        {
          type: "sl_zigbee_certificate_data_t",
          name: "myCert",
          description: "The node's new certificate signed by the CA.",
        },
        {
          type: "sl_zigbee_private_key_data_t",
          name: "myKey",
          description: "The node's new static private key.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
    ## SAVE_PREINSTALLED_CBKE_DATA283K1
    {
      value: "0x00ED",
      needGeneratedHandler : "ezspyes",
      commandName: "savePreinstalledCbkeData283k1",
      description: "Sets the device's 283k1 curve CA public key, local
                    certificate, and static private key on the NCP
                    associated with this node.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "",
        },
      ],
    },
  ],

}
# END Certificate Based Key Exchange (CBKE) Frames

################################################################################
- {
  section: Mfglib Frames,

  ncpCpps: [
    "#ifndef EZSP_NO_MFGLIB",
    "#endif /* ndef EZSP_NO_MFGLIB */",
  ],

  typedefs: ~,

  enums: ~,

  frames: [
    ## MFGLIB_INTERNAL_START
    {
      value: "0x0083",
      needGeneratedHandler : "ezspyes",
      commandName: "mfglibInternalStart",
      description: "Activate use of mfglib test routines and enables
                    the radio receiver to report packets it receives to
                    the mfgLibRxHandler() callback. These packets will
                    not be passed up with a CRC failure. All other
                    mfglib functions will return an error until the
                    mfglibInternalStart() has been called",
      commandArguments: [
        {
          type: "bool",
          name: "rxCallback",
          description: "true to generate a mfglibRxHandler callback when
                        a packet is received.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MFGLIB_INTERNAL_END
    {
      value: "0x0084",
      needGeneratedHandler : "mfglibyes",
      commandName: "mfglibInternalEnd",
      description: "Deactivate use of mfglib test routines; restores
                    the hardware to the state it was in prior to
                    mfglibInternalStart() and stops receiving packets started by
                    mfglibInternalStart() at the same time.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MFGLIB_INTERNAL_START_TONE
    {
      value: "0x0085",
      needGeneratedHandler : "mfglibyes",
      commandName: "mfglibInternalStartTone",
      description: "Starts transmitting an unmodulated tone on the
                    currently set channel and power level. Upon
                    successful return, the tone will be transmitting. To
                    stop transmitting tone, application must call
                    mfglibInternalStopTone(), allowing it the flexibility to
                    determine its own criteria for tone duration (time,
                    event, etc.)",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MFGLIB_INTERNAL_STOP_TONE
    {
      value: "0x0086",
      needGeneratedHandler : "mfglibyes",
      commandName: "mfglibInternalStopTone",
      description: "Stops transmitting tone started by mfglibInternalStartTone().",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MFGLIB_INTERNAL_START_STREAM
    {
      value: "0x0087",
      needGeneratedHandler : "mfglibyes",
      commandName: "mfglibInternalStartStream",
      description: "Starts transmitting a random stream of characters.
                    This is so that the radio modulation can be
                    measured.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MFGLIB_INTERNAL_STOP_STREAM
    {
      value: "0x0088",
      needGeneratedHandler : "mfglibyes",
      commandName: "mfglibInternalStopStream",
      description: "Stops transmitting a random stream of characters
                    started by mfglibInternalStartStream().",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MFGLIB_INTERNAL_SEND_PACKET
    {
      value: "0x0089",
      needGeneratedHandler : "ezspyes",
      commandName: "mfglibInternalSendPacket",
      description: "Sends a single packet consisting of the following
                    bytes: packetLength, packetContents[0], ... ,
                    packetContents[packetLength - 3], CRC[0], CRC[1]. The
                    total number of bytes sent is packetLength + 1.
                    The radio replaces the last two bytes of
                    packetContents[] with the 16-bit CRC for the packet.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "packetLength",
          description: "The length of the packetContents parameter in
                        bytes. Must be greater than 3 and less than
                        123.",
        },
        {
          type: "uint8_t[packetLength]",
          name: "packetContents",
          description: "The packet to send. The last two bytes will
                        be replaced with the 16-bit CRC.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MFGLIB_INTERNAL_SET_CHANNEL
    {
      value: "0x008a",
      needGeneratedHandler : "mfglibyes",
      commandName: "mfglibInternalSetChannel",
      description: "Sets the radio channel. Calibration occurs if this
                    is the first time the channel has been used.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "channel",
          description: "The channel to switch to. Valid values are 11
                        to 26.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MFGLIB_INTERNAL_GET_CHANNEL
    {
      value: "0x008b",
      needGeneratedHandler : "mfglibyes",
      commandName: "mfglibInternalGetChannel",
      description: "Returns the current radio channel, as previously
                    set via mfglibInternalSetChannel().",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "channel",
          description: "The current channel.",
        },
      ],
    },
    ## MFGLIB_INTERNAL_SET_POWER
    {
      value: "0x008c",
      needGeneratedHandler : "mfglibyes",
      commandName: "mfglibInternalSetPower",
      description: "First select the transmit power mode, and then
                    include a method for selecting the radio transmit
                    power. The valid power settings depend upon the
                    specific radio in use. Ember radios have discrete
                    power settings, and then requested power is rounded
                    to a valid power setting; the actual power output
                    is available to the caller via
                    mfglibInternalGetPower().",
      commandArguments: [
        {
          type: "uint16_t",
          name: "txPowerMode",
          description: "Power mode. Refer to txPowerModes in
                        stack/include/sl_zigbee_types.h for possible values.",
        },
        {
          type: "int8_t",
          name: "power",
          description: "Power in units of dBm. Refer to radio data
                        sheet for valid range.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## MFGLIB_INTERNAL_GET_POWER
    {
      value: "0x008d",
      needGeneratedHandler : "mfglibyes",
      commandName: "mfglibInternalGetPower",
      description: "Returns the current radio power setting, as
                    previously set via mfglibInternalSetPower().",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "int8_t",
          name: "power",
          description: "Power in units of dBm. Refer to radio data
                        sheet for valid range.",
        },
      ],
    },
    ## MFGLIB_INTERNAL_RX_HANDLER
    {
      value: "0x008e",
      needGeneratedHandler : "no",
      commandName: "mfglibRxHandler",
      description: "A callback indicating a packet with a valid CRC
                    has been received.",
      responseArguments: [
        {
          type: "uint8_t",
          name: "linkQuality",
          description: "The link quality observed during the reception",
        },
        {
          type: "int8_t",
          name: "rssi",
          description: "The energy level (in units of dBm) observed
                        during the reception.",
        },
        {
          type: "uint8_t",
          name: "packetLength",
          description: "The length of the packetContents parameter in
                        bytes. Will be greater than 3 and less than
                        123.",
        },
        {
          type: "uint8_t[packetLength]",
          name: "packetContents",
          description: "The received packet (last 2 bytes are not FCS / CRC and may be discarded)",
        },
      ],
    },
  ],

}
# END Mfglib Frames

################################################################################
- {
  section: Bootloader Frames,

  ncpCpps: [
    "#ifndef EZSP_NO_BOOTLOADER",
    "#endif /* ndef EZSP_NO_BOOTLOADER */",
  ],

  typedefs: ~,

  enums: ~,

  frames: [
    ## LAUNCH_STANDALONE_BOOTLOADER
    {
      value: "0x008f",
      needGeneratedHandler : "no",
      commandName: "launchStandaloneBootloader",
      description: "Quits the current application and launches the
                    standalone bootloader (if installed) The function
                    returns an error if the standalone bootloader is
                    not present",
      commandArguments: [
        {
          type: "bool",
          name: "enabled",
          description: "If true, launch the standalone bootloader. If false, 
                        do nothing.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## SEND_BOOTLOAD_MESSAGE
    {
      value: "0x0090",
      needGeneratedHandler : "no",
      commandName: "sendBootloadMessage",
      description: "Transmits the given bootload message to a
                    neighboring node using a specific 802.15.4 header
                    that allows the EmberZNet stack as well as the
                    bootloader to recognize the message, but will not
                    interfere with other ZigBee stacks.",
      commandArguments: [
        {
          type: "bool",
          name: "broadcast",
          description: "If true, the destination address and pan id
                        are both set to the broadcast address.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "destEui64",
          description: "The EUI64 of the target node. Ignored if the
                        broadcast field is set to true.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The multicast message.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## GET_STANDALONE_BOOTLOADER_VERSION_PLAT_MICRO_PHY
    {
      value: "0x0091",
      needGeneratedHandler : "no",
      commandName: "getStandaloneBootloaderVersionPlatMicroPhy",
      description: "Detects if the standalone bootloader is installed,
                    and if so returns the installed version. If not
                    return 0xffff. A returned version of 0x1234 would
                    indicate version 1.2 build 34. Also return the
                    node's version of PLAT, MICRO and PHY.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint16_t",
          name: "bootloader_version",
          description: "BOOTLOADER_INVALID_VERSION if the standalone
                        bootloader is not present, or the version of
                        the installed standalone bootloader.",
        },
        {
          type: "uint8_t",
          name: "nodePlat",
          description: "The value of PLAT on the node",
        },
        {
          type: "uint8_t",
          name: "nodeMicro",
          description: "The value of MICRO on the node",
        },
        {
          type: "uint8_t",
          name: "nodePhy",
          description: "The value of PHY on the node",
        },
      ],
    },
    ## INCOMING_BOOTLOAD_MESSAGE_HANDLER
    {
      value: "0x0092",
      needGeneratedHandler : "no",
      commandName: "incomingBootloadMessageHandler",
      description: "A callback invoked by the EmberZNet stack when a
                    bootload message is received.",
      responseArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "longId",
          description: "The EUI64 of the sending node.",
        },
        {
          type: "sl_zigbee_rx_packet_info_t",
          name: "packetInfo",
          description: "Information about the incoming packet.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The bootload message that was sent.",
        },
      ],
    },
    ## BOOTLOAD_TRANSMIT_COMPLETE_HANDLER
    {
      value: "0x0093",
      needGeneratedHandler : "no",
      commandName: "bootloadTransmitCompleteHandler",
      description: "A callback invoked by the EmberZNet stack when the
                    MAC has finished transmitting a bootload message.",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value of SL_STATUS_OK if an ACK
                        was received from the destination or
                        SL_STATUS_ZIGBEE_DELIVERY_FAILED if no ACK was received.",
        },
        {
          type: "uint8_t",
          name: "messageLength",
          description: "The length of the <i>messageContents</i>
                        parameter in bytes.",
        },
        {
          type: "uint8_t[messageLength]",
          name: "messageContents",
          description: "The message that was sent.",
        },
      ],
    },
    ## AES_ENCRYPT
    {
      value: "0x0094",
      needGeneratedHandler : "no",
      commandName: "aesEncrypt",
      description: "Perform AES encryption on plaintext using key.",
      commandArguments: [
        {
          type: "uint8_t[16]",
          name: "plaintext",
          description: "16 bytes of plaintext.",
        },
        {
          type: "uint8_t[16]",
          name: "key",
          description: "The 16-byte encryption key to use.",
        },
      ],
      responseArguments: [
        {
          type: "uint8_t[16]",
          name: "ciphertext",
          description: "16 bytes of ciphertext.",
        },
      ],
    },
    ## INCOMING_MFG_TEST_MESSAGE_HANDLER
    {
      value: "0x0147",
      needGeneratedHandler : "no",
      commandName: "incomingMfgTestMessageHandler",
      description: "A callback to be implemented on the Golden Node to process
                    acknowledgements. If you supply a custom version of this handler, you
                    must define SL_ZIGBEE_APPLICATION_HAS_INCOMING_MFG_TEST_MESSAGE_HANDLER in
                    your application's CONFIGURATION_HEADER",
      responseArguments: [
        {
          type: "uint8_t",
          name: "messageType",
          description: "The type of the incoming message. Currently, the
                        only possibility is MFG_TEST_TYPE_ACK.",
        },
        {
          type: "uint8_t",
          name: "dataLength",
          description: "The length of the incoming message.",
        },
        {
          type: "uint8_t[1]",
          name: "data",
          description: "A pointer to the data received in the current message.",
        },
      ],
    },
    ## MFG_TEST_SET_PACKET_MODE
    {
      value: "0x0148",
      needGeneratedHandler : "yes",
      commandName: "mfgTestSetPacketMode",
      description: "A function used on the Golden Node to switch between
                    normal network operation (for testing) and manufacturing
                    configuration. Like emberSleep(), it may not be possible to execute this
                    command due to pending network activity. For the transition
                    from normal network operation to manufacturing configuration,
                    it is customary to loop, calling this function alternately
                    with emberTick() until the mode change succeeds.",
      commandArguments: [
        {
          type: "bool",
          name: "beginConfiguration",
          description: "Determines the new mode of operation.
                        true causes the node to enter manufacturing configuration. false
                        causes the node to return to normal network operation.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or failure of the
                        command."
        },
      ],
    },
    ## MFG_TEST_SEND_REBOOT_COMMAND
    {
      value: "0x0149",
      needGeneratedHandler : "yes",
      commandName: "mfgTestSendRebootCommand",
      description: "A function used during manufacturing configuration
                    on the Golden Node to send the DUT a reboot command. The usual
                    practice is to execute this command at the end of manufacturing
                    configuration, to place the DUT into normal network operation for
                    testing. This function executes only during manufacturing configuration
                    mode and returns an error otherwise. If successful, the DUT
                    acknowledges the reboot command within 20 milliseconds and then
                    reboots.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or failure of the
                        command."
        },
      ],
    },
    ## MFG_TEST_SEND_EUI64
    {
      value: "0x014A",
      needGeneratedHandler : "yes",
      commandName: "mfgTestSendEui64",
      description: "A function used during manufacturing configuration
                    on the Golden Node to set the DUT's 8-byte EUI ID.
                    This function executes only during manufacturing configuration
                    mode and returns an error otherwise. If successful,
                    the DUT acknowledges the new EUI ID within 150 milliseconds.",
      commandArguments: [
        {
          type: "sl_802154_long_addr_t",
          name: "newId",
          description: "The 8-byte EUID for the DUT."
        }
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or failure of the
                        command."
        },
      ],
    },
    ## MFG_TEST_SEND_MANUFACTURING_STRING
    {
      value: "0x014B",
      needGeneratedHandler : "yes",
      commandName: "mfgTestSendManufacturingString",
      description: "A function used during manufacturing configuration
                    on the Golden Node to set the DUT's 16-byte configuration string.
                    This function executes only during manufacturing configuration
                    mode and will return an error otherwise. If successful,
                    the DUT will acknowledge the new string within 150 milliseconds.",
      commandArguments: [
        {
          type: "sl_zigbee_manufacturing_string_t",
          name: "newString",
          description: "The 16-byte manufacturing string."
        }
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or failure of the
                        command."
        },
      ],
    },
    ## MFG_TEST_SEND_RADIO_PARAMETERS
    {
      value: "0x014C",
      needGeneratedHandler : "yes",
      commandName: "mfgTestSendRadioParameters",
      description: "A function used during manufacturing configuration
                    on the Golden Node to set the DUT's radio parameters. This function
                    executes only during manufacturing configuration
                    mode and returns an error otherwise. If successful,
                    the DUT acknowledges the new parameters within 25 milliseconds.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "supportedBands",
          description: "Sets the radio band for the DUT. See
                        ember-common.h for possible values."
        },
        {
          type: "int8_t",
          name: "crystalOffset",
          description: "Sets the CC1020 crystal offset. This
                        parameter has no effect on the EM2420, and it may safely be
                        set to 0 for this RFIC."
        }
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or failure of the
                        command."
        },
      ],
    },
    ## MFG_TEST_SEND_COMMAND
    {
      value: "0x014D",
      needGeneratedHandler : "yes",
      commandName: "mfgTestSendCommand",
      description: "A function used in each of the manufacturing
                    configuration API calls. Most implementations will not need
                    to call this function directly. See mfg-test.c for more detail.
                    This function executes only during manufacturing configuration
                    mode and returns an error otherwise.",
      commandArguments: [
        {
          type: "uint8_t[1]",
          name: "command",
          description: "A pointer to the outgoing command string."
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or failure of the
                        command."
        },
      ],
    }
  ],
}
# END Bootloader Frames

################################################################################
- {
  section: ZLL Frames,

  ncpCpps: [
    "#ifndef EZSP_NO_ZLL",
    "#endif /* ifndef EZSP_NO_ZLL */",
  ],

  typedefs: ~,

  enums: ~,

  frames: [
    ## ZLL_NETWORK_OPS
    {
      value: "0x00B2",
      needGeneratedHandler : "ezspyes",
      commandName: "zllNetworkOps",
      description: "A consolidation of ZLL network operations with
                    similar signatures; specifically, forming and joining
                    networks or touch-linking.",
      commandArguments: [
        {
          type: "sl_zigbee_zll_network_t",
          name: "networkInfo",
          description: "Information about the network.",
        },
        {
          type: "sl_zigbee_ezsp_zll_network_operation_t",
          name: "op",
          description: "Operation indicator.",
        },
        {
          type: "int8_t",
          name: "radioTxPower",
          description: "Radio transmission power.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## ZLL_SET_INITIAL_SECURITY_STATE
    {
      value: "0x00B3",
      needGeneratedHandler : "yes",
      commandName: "zllSetInitialSecurityState",
      description: "This call will cause the device to setup the
                    security information used in its network. It must
                    be called prior to forming, starting, or joining a
                    network.",
      commandArguments: [
        {
          type: "sl_zigbee_key_data_t",
          name: "networkKey",
          description: "ZLL Network key.",
        },
        {
          type: "sl_zigbee_zll_initial_security_state_t",
          name: "securityState",
          description: "Initial security state of the network.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## ZLL_SET_SECURITY_STATE_WITHOUT_KEY
    {
      value: "0x00CF",
      needGeneratedHandler : "yes",
      commandName: "zllSetSecurityStateWithoutKey",
      description: "This call will update ZLL security token information. Unlike
                    sli_zigbee_stack_zll_set_initial_security_state, this can be called while a network is
                    already established.",
      commandArguments: [
        {
          type: "sl_zigbee_zll_initial_security_state_t",
          name: "securityState",
          description: "Security state of the network.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## ZLL_START_SCAN
    {
      value: "0x00B4",
      needGeneratedHandler : "yes",
      commandName: "zllStartScan",
      description: "This call will initiate a ZLL network scan on all
                    the specified channels.",
      commandArguments: [
        {
          type: "uint32_t",
          name: "channelMask",
          description: "The range of channels to scan.",
        },
        {
          type: "int8_t",
          name: "radioPowerForScan",
          description: "The radio output power used for the scan
                        requests.",
        },
        {
          type: "sl_zigbee_node_type_t",
          name: "nodeType",
          description: "The node type of the local device.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## ZLL_SET_RX_ON_WHEN_IDLE
    {
      value: "0x00B5",
      needGeneratedHandler : "yes",
      commandName: "zllSetRxOnWhenIdle",
      description: "This call will change the mode of the radio so
                    that the receiver is on for a specified amount of
                    time when the device is idle.",
      commandArguments: [
        {
          type: "uint32_t",
          name: "durationMs",
          description: "The duration in milliseconds to leave the radio
                        on.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## ZLL_NETWORK_FOUND_HANDLER
    {
      value: "0x00B6",
      needGeneratedHandler : "no",
      commandName: "zllNetworkFoundHandler",
      description: "This call is fired when a ZLL network scan finds
                    a ZLL network.",
      responseArguments: [
        {
          type: "sl_zigbee_zll_network_t",
          name: "networkInfo",
          description: "Information about the network.",
        },
        {
          type: "bool",
          name: "isDeviceInfoNull",
          description: "Used to interpret deviceInfo field.",
        },
        {
          type: "sl_zigbee_zll_device_info_record_t",
          name: "deviceInfo",
          description: "Device specific information.",
        },
        {
          type: "sl_zigbee_rx_packet_info_t",
          name: "packetInfo",
          description: "Information about the incoming packet
                        received from this network.",
        },
      ],
    },
    ## ZLL_SCAN_COMPLETE_HANDLER
    {
      value: "0x00B7",
      needGeneratedHandler : "no",
      commandName: "zllScanCompleteHandler",
      description: "This call is fired when a ZLL network scan is
                    complete.",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "Status of the operation.",
        },
      ],
    },
    ## ZLL_ADDRESS_ASSIGNMENT_HANDLER
    {
      value: "0x00B8",
      needGeneratedHandler : "no",
      commandName: "zllAddressAssignmentHandler",
      description: "This call is fired when network and group
                    addresses are assigned to a remote mode in a
                    network start or network join request.",
      responseArguments: [
        {
          type: "sl_zigbee_zll_address_assignment_t",
          name: "addressInfo",
          description: "Address assignment information.",
        },
        {
          type: "sl_zigbee_rx_packet_info_t",
          name: "packetInfo",
          description: "Information about the incoming packet.",
        },
      ],
    },
    ## ZLL_TOUCH_LINK_TARGET_HANDLER
    {
      value: "0x00BB",
      needGeneratedHandler : "no",
      commandName: "zllTouchLinkTargetHandler",
      description: "This call is fired when the device is a target
                    of a touch link.",
      responseArguments: [
        {
          type: "sl_zigbee_zll_network_t",
          name: "networkInfo",
          description: "Information about the network.",
        },
      ],
    },
    ## ZLL_GET_TOKENS
    {
      value: "0x00BC",
      needGeneratedHandler : "yes",
      commandName: "zllGetTokens",
      description: "Get the ZLL tokens.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_zigbee_tok_type_stack_zll_data_t",
          name: "data",
          description: "Data token return value.",
        },
        {
          type: "sl_zigbee_tok_type_stack_zll_security_t",
          name: "security",
          description: "Security token return value.",
        },
      ],
    },
    ## ZLL_SET_DATA_TOKEN
    {
      value: "0x00BD",
      needGeneratedHandler : "yes",
      commandName: "zllSetDataToken",
      description: "Set the ZLL data token.",
      commandArguments: [
        {
          type: "sl_zigbee_tok_type_stack_zll_data_t",
          name: "data",
          description: "Data token to be set.",
        },
      ],
      responseArguments: [
      ],
    },
    ## ZLL_SET_NON_ZLL_NETWORK
    {
      value: "0x00BF",
      needGeneratedHandler : "yes",
      commandName: "zllSetNonZllNetwork",
      description: "Set the ZLL data token bitmask to reflect the ZLL
                    network state.",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    ## IS_ZLL_NETWORK
    {
      value: "0x00BE",
      needGeneratedHandler : "yes",
      commandName: "isZllNetwork",
      description: "Is this a ZLL network?",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "bool",
          name: "isZllNetwork",
          description: "ZLL network?",
        },
      ],
    },
    ## ZLL_SET_RADIO_IDLE_MODE
    {
      value: "0x00D4",
      needGeneratedHandler : "yes",
      commandName: "zllSetRadioIdleMode",
      description: "This call sets the radio's default idle power mode.",
      commandArguments: [
        {
          type: "sl_zigbee_radio_power_mode_t",
          name: "mode",
          description: "The power mode to be set.",
        },
      ],
      responseArguments: [
      ],
    },
    ## ZLL_GET_RADIO_IDLE_MODE
    {
      value: "0x00BA",
      needGeneratedHandler : "yes",
      commandName: "zllGetRadioIdleMode",
      description: "This call gets the radio's default idle power mode.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "radioIdleMode",
          description: "The current power mode.",
        },
      ],
    },
    ## SET_ZLL_NODE_TYPE
    {
      value: "0x00D5",
      needGeneratedHandler : "yes",
      commandName: "setZllNodeType",
      description: "This call sets the default node type for a factory new ZLL device.",
      commandArguments: [
        {
          type: "sl_zigbee_node_type_t",
          name: "nodeType",
          description: "The node type to be set.",
        },
      ],
      responseArguments: [
      ],
    },
    ## SET_ZLL_ADDITIONAL_STATE
    {
      value: "0x00D6",
      needGeneratedHandler : "yes",
      commandName: "setZllAdditionalState",
      description: "This call sets additional capability bits in the ZLL state.",
      commandArguments: [
        {
          type: "uint16_t",
          name: "state",
          description: "A mask with the bits to be set or cleared.",
        },
      ],
      responseArguments: [
      ],
    },
    ## ZLL_OPERATION_IN_PROGRESS
    {
      value: "0x00D7",
      needGeneratedHandler : "yes",
      commandName: "zllOperationInProgress",
      description: "Is there a ZLL (Touchlink) operation in progress?",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "bool",
          name: "zllOperationInProgress",
          description: "ZLL operation in progress?",
        },
      ],
    },
    ## ZLL_RX_ON_WHEN_IDLE_GET_ACTIVE
    {
      value: "0x00D8",
      needGeneratedHandler : "yes",
      commandName: "zllRxOnWhenIdleGetActive",
      description: "Is the ZLL radio on when idle mode is active?",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "bool",
          name: "zllRxOnWhenIdleGetActive",
          description: "ZLL radio on when idle mode is active?",
        },
      ],
    },
    ## ZLL_SCANNING_COMPLETE
    {
      value: "0x00F6",
      needGeneratedHandler : "yes",
      commandName: "zllScanningComplete",
      description: "Informs the ZLL API that application scanning is complete",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    ## GET_ZLL_PRIMARY_CHANNEL_MASK
    {
      value: "0x00D9",
      needGeneratedHandler : "yes",
      commandName: "getZllPrimaryChannelMask",
      description: "Get the primary ZLL (touchlink) channel mask.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint32_t",
          name: "zllPrimaryChannelMask",
          description: "The primary ZLL channel mask",
        },
      ],
    },
    ## GET_ZLL_SECONDARY_CHANNEL_MASK
    {
      value: "0x00DA",
      needGeneratedHandler : "yes",
      commandName: "getZllSecondaryChannelMask",
      description: "Get the secondary ZLL (touchlink) channel mask.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint32_t",
          name: "zllSecondaryChannelMask",
          description: "The secondary ZLL channel mask",
        },
      ],
    },
    ## SET_ZLL_PRIMARY_CHANNEL_MASK
    {
      value: "0x00DB",
      needGeneratedHandler : "yes",
      commandName: "setZllPrimaryChannelMask",
      description: "Set the primary ZLL (touchlink) channel mask",
      commandArguments: [
        {
          type: "uint32_t",
          name: "zllPrimaryChannelMask",
          description: "The primary ZLL channel mask",
        },
      ],
      responseArguments: [
      ],
    },
    ## SET_ZLL_SECONDARY_CHANNEL_MASK
    {
      value: "0x00DC",
      needGeneratedHandler : "yes",
      commandName: "setZllSecondaryChannelMask",
      description: "Set the secondary ZLL (touchlink) channel mask.",
      commandArguments: [
        {
          type: "uint32_t",
          name: "zllSecondaryChannelMask",
          description: "The secondary ZLL channel mask",
        },
      ],
      responseArguments: [
      ],
    },
    ## ZLL_CLEAR_TOKENS
    {
      value: "0x0025",
      needGeneratedHandler : "yes",
      commandName: "zllClearTokens",
      description: "Clear ZLL stack tokens.",
      commandArguments: [
      ],
      responseArguments: [
      ],
    }
  ],

}
# END ZLL Frames

################################################################################
- {
  section: Green Power Frames,

  ncpCpps: [
    "#ifndef EZSP_NO_GREEN_POWER",
    "#endif /* ndef EZSP_NO_GREEN_POWER */",
  ],

  typedefs: [
    {
      name: "sl_zigbee_gp_address_t",
      description: "A GP address structure.",
      definition: [
        {
          type: "uint8_t[8]",
          name: "id",
          description: "Contains either a 4-byte source ID or
                        an 8-byte IEEE address, as indicated
                        by the value of the applicationId field.",
        },
        {
          type: "uint8_t",
          name: "applicationId",
          description: "The GPD Application ID specifying either
                        source ID (0x00) or IEEE address (0x02).",
        },
        {
          type: "uint8_t",
          name: "endpoint",
          description: "The GPD endpoint.",
        },
      ],
    },
    {
      name: "sl_zigbee_gp_sink_list_entry_t",
      description: "A sink list entry.",
      definition: [
        {
          type: "uint8_t",
          name: "type",
          description: "The sink list type.",
        },
        {
          type: "sl_802154_long_addr_t",
          name: "sinkEUI",
          description: "The EUI64 of the target sink.",
        },
        {
          type: "sl_802154_short_addr_t",
          name: "sinkNodeId",
          description: "The short address of the target sink.",
        },
      ],
    },

    {
      name: "sl_zigbee_gp_security_level_t",
      description: "The security level of the GPD.",
      definition: "uint8_t",
    },
    {
      name: "sl_zigbee_gp_key_type_t",
      description: "The type of security key to use for the GPD.",
      definition: "uint8_t",
    },
    {
      name: "sl_zigbee_gp_proxy_table_entry_status_t",
      description: "The proxy table entry status",
      definition: "uint8_t",
    },
    {
      name: "sl_zigbee_gp_security_frame_counter_t",
      description: "The security frame counter",
      definition: "uint32_t",
    },
    {
      name: "sl_zigbee_gp_proxy_table_entry_t",
      description: "The internal representation of a proxy table entry.",
      definition: [
      {
        type: "sl_zigbee_gp_proxy_table_entry_status_t",
        name: "status",
        description: "Internal status of the proxy table entry.",
      },
      {
        type: "uint32_t",
        name: "options",
        description: "The tunneling options (this contains both options and
                      extendedOptions from the spec).",
      },
      {
        type: "sl_zigbee_gp_address_t",
        name: "gpd",
        description: "The addressing info of the GPD.",
      },
      {
        type: "sl_802154_short_addr_t",
        name: "assignedAlias",
        description: "The assigned alias for the GPD.",
      },
      {
        type: "uint8_t",
        name: "securityOptions",
        description: "The security options field.",
      },
      {
        type: "sl_zigbee_gp_security_frame_counter_t",
        name: "gpdSecurityFrameCounter",
        description: "The security frame counter of the GPD.",
      },
      {
        type: "sl_zigbee_key_data_t",
        name: "gpdKey",
        description: "The key to use for GPD.",
      },
      {
        type: "sl_zigbee_gp_sink_list_entry_t",
        name: "sinkList[GP_SINK_LIST_ENTRIES]",
        description: "The list of sinks (hardcoded to 2 which is the spec
                      minimum).",
      },
      {
        type: "uint8_t",
        name: "groupcastRadius",
        description: "The groupcast radius.",
      },
      {
        type: "uint8_t",
        name: "searchCounter",
        description: "The search counter.",
      }
      ]
    },
    {
      name: "sl_zigbee_gp_sink_table_entry_status_t",
      description: "The sink table entry status",
      definition: "uint8_t",
    },
    {
      name: "sl_zigbee_gp_sink_table_entry_t",
      description: "The internal representation of a sink table entry.",
      definition: [
      {
        type: "sl_zigbee_gp_sink_table_entry_status_t",
        name: "status",
        description: "Internal status of the sink table entry.",
      },
      {
        type: "uint32_t",
        name: "options",
        description: "The tunneling options (this contains both options and
                      extendedOptions from the spec).",
      },
      {
        type: "sl_zigbee_gp_address_t",
        name: "gpd",
        description: "The addressing info of the GPD.",
      },
      {
        type: "uint8_t",
        name: "deviceId",
        description: "The device id for the GPD.",
      },
      {
        type: "sl_zigbee_gp_sink_list_entry_t",
        name: "sinkList[GP_SINK_LIST_ENTRIES]",
        description: "The list of sinks (hardcoded to 2 which is the spec
                      minimum).",
      },
      {
        type: "sl_802154_short_addr_t",
        name: "assignedAlias",
        description: "The assigned alias for the GPD.",
      },
      {
        type: "uint8_t",
        name: "groupcastRadius",
        description: "The groupcast radius.",
      },
      {
        type: "uint8_t",
        name: "securityOptions",
        description: "The security options field.",
      },
      {
        type: "sl_zigbee_gp_security_frame_counter_t",
        name: "gpdSecurityFrameCounter",
        description: "The security frame counter of the GPD.",
      },
      {
        type: "sl_zigbee_key_data_t",
        name: "gpdKey",
        description: "The key to use for GPD.",
      },
      ]
    },
  ],

  enums: ~,

  frames: [
    ## GP_PROXY_TABLE_PROCESS_GP_PAIRING
    {
      value: "0x00C9",
      needGeneratedHandler : "yes",
      commandName: "gpProxyTableProcessGpPairing",
      description: "Update the GP Proxy table based on a GP pairing.",
      commandArguments: [
        {
          type: "uint32_t",
          name: "options",
          description: "The options field of the GP Pairing command.",
        },
        {
          type: "sl_zigbee_gp_address_t",
          name: "addr",
          description: "The target GPD.",
        },
        {
          type: "uint8_t",
          name: "commMode",
          description: "The communication mode of the GP Sink.",
        },
        {
          type: "uint16_t",
          name: "sinkNetworkAddress",
          description: "The network address of the GP Sink.",
        },
        {
          type: "uint16_t",
          name: "sinkGroupId",
          description: "The group ID of the GP Sink.",
        },
        {
          type: "uint16_t",
          name: "assignedAlias",
          description: "The alias assigned to the GPD.",
        },
        {
          type: "uint8_t[8]",
          name: "sinkIeeeAddress",
          description: "The IEEE address of the GP Sink.",
        },
        {
          type: "sl_zigbee_key_data_t",
          name: "gpdKey",
          description: "The key to use for the target GPD.",
        },
        {
          type: "uint32_t",
          name: "gpdSecurityFrameCounter",
          description: "The GPD security frame counter.",
        },
        {
          type: "uint8_t",
          name: "forwardingRadius",
          description: "The forwarding radius.",
        },
      ],
      responseArguments: [
        {
          type: "bool",
          name: "gpPairingAdded",
          description: "Whether a GP Pairing has been created or not.",
        },
      ],
    },
    ## DGP_SEND
    {
      value: "0x00C6",
      needGeneratedHandler : "yes",
      commandName: "dGpSend",
      description: "Adds/removes an entry from the GP Tx Queue.",
      commandArguments: [
        {
          type: "bool",
          name: "action",
          description: "The action to perform on the GP TX queue
                        (true to add, false to remove).",
        },
        {
          type: "bool",
          name: "useCca",
          description: "Whether to use ClearChannelAssessment when
                        transmitting the GPDF.",
        },
        {
          type: "sl_zigbee_gp_address_t",
          name: "addr",
          description: "The Address of the destination GPD.",
        },
        {
          type: "uint8_t",
          name: "gpdCommandId",
          description: "The GPD command ID to send.",
        },
        {
          type: "uint8_t",
          name: "gpdAsduLength",
          description: "The length of the GP command payload.",
        },
        {
          type: "uint8_t[gpdAsduLength]",
          name: "gpdAsdu",
          description: "The GP command payload.",
        },
        {
          type: "uint8_t",
          name: "gpepHandle",
          description: "The handle to refer to the GPDF.",
        },
        {
          type: "uint16_t",
          name: "gpTxQueueEntryLifetimeMs",
          description: "How long to keep the GPDF in the TX Queue.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },

    ##GPEP_SENT_HANDLER
    {
      value: "0x00C7",
      needGeneratedHandler : "no",
      commandName: "dGpSentHandler",
      description: "A callback to the GP endpoint to indicate the
                    result of the GPDF transmission.",
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "uint8_t",
          name: "gpepHandle",
          description: "The handle of the GPDF.",
        },
      ],
    },



    ## GP_EP_INCOMING_MESSAGE
    {
      value: "0x00C5",
      needGeneratedHandler : "no",
      commandName: "gpepIncomingMessageHandler",
      description: "A callback invoked by the ZigBee GP stack when
                    a GPDF is received.",
      responseArguments: [
        {
          type: "sl_zigbee_gp_status_t",
          name: "gp_status",
          description: "The status of the GPDF receive.",
        },
        {
          type: "uint8_t",
          name: "gpdLink",
          description: "The gpdLink value of the received GPDF.",
        },
        {
          type: "uint8_t",
          name: "sequenceNumber",
          description: "The GPDF sequence number.",
        },
        {
          type: "sl_zigbee_gp_address_t",
          name: "addr",
          description: "The address of the source GPD.",
        },
        {
          type: "sl_zigbee_gp_security_level_t",
          name: "gpdfSecurityLevel",
          description: "The security level of the received GPDF.",
        },
        {
          type: "sl_zigbee_gp_key_type_t",
          name: "gpdfSecurityKeyType",
          description: "The securityKeyType used to decrypt/authenticate
                        the incoming GPDF.",
        },
        {
          type: "bool",
          name: "autoCommissioning",
          description: "Whether the incoming GPDF had the auto-commissioning
                        bit set.",
        },
        {
          type: "uint8_t",
          name: "bidirectionalInfo",
          description: "Bidirectional information represented in bitfields,
                        where bit0 holds the rxAfterTx of incoming gpdf and
                        bit1 holds if tx queue is available for outgoing gpdf.",
        },
        {
          type: "uint32_t",
          name: "gpdSecurityFrameCounter",
          description: "The security frame counter of the incoming GDPF.",
        },
        {
          type: "uint8_t",
          name: "gpdCommandId",
          description: "The gpdCommandId of the incoming GPDF.",
        },
        {
          type: "uint32_t",
          name: "mic",
          description: "The received MIC of the GPDF.",
        },
        {
          type: "uint8_t",
          name: "proxyTableIndex",
          description: "The proxy table index of the corresponding proxy
                        table entry to the incoming GPDF.",
        },
        {
          type: "uint8_t",
          name: "gpdCommandPayloadLength",
          description: "The length of the GPD command payload.",
        },
        {
          type: "uint8_t[gpdCommandPayloadLength]",
          name: "gpdCommandPayload",
          description: "The GPD command payload.",
        },
        {
          type: "sl_zigbee_rx_packet_info_t",
          name: "packetInfo",
          description: "Rx packet information.",
        }
      ],
    },
    ## GP_PROXY_TABLE_GET_ENTRY
    {
      value: "0x00C8",
      needGeneratedHandler : "yes",
      commandName: "gpProxyTableGetEntry",
      description: "Retrieves the proxy table entry stored at the
                    passed index.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "proxyIndex",
          description: "The index of the requested proxy table entry.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "sl_zigbee_gp_proxy_table_entry_t",
          name: "entry",
          description: "An sl_zigbee_gp_proxy_table_entry_t struct containing a
                        copy of the requested proxy entry.",
        },
      ],
    },
    ## GP_PROXY_TABLE_LOOKUP
    {
      value: "0x00C0",
      needGeneratedHandler : "yes",
      commandName: "gpProxyTableLookup",
      description: "Finds the index of the passed address in the gp table.",
      commandArguments: [
        {
          type: "sl_zigbee_gp_address_t",
          name: "addr",
          description: "The address to search for",
        },
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index, or 0xFF for not found",
        },
      ],
    },
    ## GP_SINK_TABLE_GET_ENTRY
    {
      value: "0x00DD",
      needGeneratedHandler : "yes",
      commandName: "gpSinkTableGetEntry",
      description: "Retrieves the sink table entry stored at the
                    passed index.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "sinkIndex",
          description: "The index of the requested sink table entry.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "sl_zigbee_gp_sink_table_entry_t",
          name: "entry",
          description: "An sl_zigbee_gp_sink_table_entry_t struct containing a
                        copy of the requested sink entry.",
        },
      ],
    },
    ##GP_SINK_TABLE_LOOKUP
    {
      value: "0x00DE",
      needGeneratedHandler : "yes",
      commandName: "gpSinkTableLookup",
      description: "Finds the index of the passed address in the gp table.",
      commandArguments: [
        {
          type: "sl_zigbee_gp_address_t",
          name: "addr",
          description: "The address to search for.",
        },
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "The index, or 0xFF for not found",
        },
      ],
    },
    ## GP_SINK_TABLE_SET_ENTRY
    {
      value: "0x00DF",
      needGeneratedHandler : "yes",
      commandName: "gpSinkTableSetEntry",
      description: "Retrieves the sink table entry stored at the
                    passed index.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "sinkIndex",
          description: "The index of the requested sink table entry.",
        },
        {
          type: "sl_zigbee_gp_sink_table_entry_t",
          name: "entry",
          description: "An sl_zigbee_gp_sink_table_entry_t struct containing a
                        copy of the sink entry to be updated.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## GP_SINK_TABLE_REMOVE_ENTRY
    {
      value: "0x00E0",
      needGeneratedHandler : "yes",
      commandName: "gpSinkTableRemoveEntry",
      description: "Removes the sink table entry stored at the
                    passed index.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "sinkIndex",
          description: "The index of the requested sink table entry.",
        },
      ],
      responseArguments: [
      ],
    },
    ## GP_SINK_TABLE_FIND_OR_ALLOCATE_ENTRY
    {
      value: "0x00E1",
      needGeneratedHandler : "yes",
      commandName: "gpSinkTableFindOrAllocateEntry",
      description: "Finds or allocates a sink entry",
      commandArguments: [
        {
          type: "sl_zigbee_gp_address_t",
          name: "addr",
          description: "An sl_zigbee_gp_address_t struct containing a
                        copy of the gpd address to be found.",
        },
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "An index of found or allocated sink or 0xFF if failed.",
        },
      ],
    },
    ##GP_CLEAR_SINK_TABLE
    {
      value: "0x00E2",
      needGeneratedHandler : "yes",
      commandName: "gpSinkTableClearAll",
      description: "Clear the entire sink table",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    ## GP_SINK_TABLE_INIT
    {
      value: "0x0070",
      needGeneratedHandler : "yes",
      commandName: "gpSinkTableInit",
      description: "Iniitializes Sink Table",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    # GP_SINK_TABLE_SET_SECURITY_FRAME_COUNTER
    {
      value: "0x00F5",
      needGeneratedHandler : "yes",
      commandName: "gpSinkTableSetSecurityFrameCounter",
      description: "Sets security framecounter in the sink table",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "Index to the Sink table",
        },
        {
          type: "uint32_t",
          name: "sfc",
          description: "Security Frame Counter",
        },
      ],
      responseArguments: [
      ],
    },
    ## GP_SINK_COMMISSION
    {
      value: "0x010A",
      needGeneratedHandler : "no",
      commandName: "gpSinkCommission",
      description: "Puts the GPS in commissioning mode.",
      commandArguments: [
        {
          type: "uint8_t",
          name: "options",
          description: "commissioning options",
        },
        {
          type: "uint16_t",
          name: "gpmAddrForSecurity",
          description: "gpm address for security.",
        },
        {
          type: "uint16_t",
          name: "gpmAddrForPairing",
          description: "gpm address for pairing.",
        },
        {
          type: "uint8_t",
          name: "sinkEndpoint",
          description: "sink endpoint.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ## GP_TRANSLATION_TABLE_CLEAR
    {
      value: "0x010B",
      needGeneratedHandler : "no",
      commandName: "gpTranslationTableClear",
      description: "Clears all entries within the translation table.",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    ## GP_GET_NUMBER_OF_ACTIVE_ENTRIES
    {
      value: "0x0118",
      needGeneratedHandler : "yes",
      commandName: "gpSinkTableGetNumberOfActiveEntries",
      description: "Return number of active entries in sink table.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "number_of_entries",
          description: "Number of active entries in sink table.",
        },
      ],
    },
  ],
}
# END Green Power Frames

################################################################################
- {
  section: Token Interface Frames,

  ncpCpps: ~,

  typedefs: [
    {
      name: "sl_zigbee_token_info_t",
      description: "Information of a token in the token table.",
      definition: [
        {
          type: "uint32_t",
          name: "nvm3Key",
          description: "NVM3 key of the token",
        },
        {
          type: "bool",
          name: "isCnt",
          description: "Token is a counter type",
        },
        {
          type: "bool",
          name: "isIdx",
          description: "Token is an indexed token",
        },
        {
          type: "uint8_t",
          name: "size",
          description: "Size of the token",
        },
        {
          type: "uint8_t",
          name: "arraySize",
          description: "Array size of the token",
        },
      ]
    },
    {
      name: "sl_zigbee_token_data_t",
      description: "Token Data",
      definition: [
        {
          type: "uint32_t",
          name: "size",
          description: "Token data size in bytes",
        },
        # 64 is larger than the size of the largest token
        {
          type: "uint8_t[64]",
          name: "data",
          description: "Token data pointer",
        },
      ]
    },
  ],

  enums: ~,

  frames: [
    ##getTokenCount
    {
      value: "0x0100",
      needGeneratedHandler : "yes",
      commandName: "getTokenCount",
      description: "Gets the total number of tokens.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "uint8_t",
          name: "count",
          description: "Total number of tokens.",
        },
      ],
    },
    ##getTokenInfo
    {
      value: "0x0101",
      needGeneratedHandler : "yes",
      commandName: "getTokenInfo",
      description: "Gets the token information for a single token at provided index",
      commandArguments: [
        {
          type: "uint8_t",
          name: "index",
          description: "Index of the token in the token table for which information
                        is needed.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "sl_zigbee_token_info_t",
          name: "tokenInfo",
          description: "Token information.",
        },
      ],
    },
    ##getTokenData
    {
      value: "0x0102",
      needGeneratedHandler : "no",
      commandName: "getTokenData",
      description: "Gets the token data for a single token with provided key",
      commandArguments: [
        {
          type: "uint32_t",
          name: "token",
          description: "Key of the token in the token table for which data
                        is needed.",
        },
        {
          type: "uint32_t",
          name: "index",
          description: "Index in case of the indexed token.",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
        {
          type: "sl_zigbee_token_data_t",
          name: "tokenData",
          description: "Token Data",
        },
      ],
    },
    ##setTokenData
    {
      value: "0x0103",
      needGeneratedHandler : "no",
      commandName: "setTokenData",
      description: "Sets the token data for a single token with provided key",
      commandArguments: [
        {
          type: "uint32_t",
          name: "token",
          description: "Key of the token in the token table for which data
                        is to be set.",
        },
        {
          type: "uint32_t",
          name: "index",
          description: "Index in case of the indexed token.",
        },
        {
          type: "sl_zigbee_token_data_t",
          name: "tokenData",
          description: "Token Data",
        },
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ##reset
    {
      value: "0x0104",
      needGeneratedHandler : "no",
      commandName: "resetNode",
      description: "Reset the node by calling halReboot.",
      commandArguments: [
      ],
      responseArguments: [
      ],
    },
    ##GP_SECURITY_TEST_VECTORS
    {
      value: "0x0117",
      needGeneratedHandler : "no",
      commandName: "gpSecurityTestVectors",
      description: "Run GP security test vectors.",
      commandArguments: [
      ],
      responseArguments: [
        {
          type: "sl_status_t",
          name: "status",
          description: "An sl_status_t value indicating success or the
                        reason for failure.",
        },
      ],
    },
    ##tokenFactoryReset
    {
      value: "0x0077",
      needGeneratedHandler : "no",
      commandName: "tokenFactoryReset",
      description: "Factory reset all configured zigbee tokens",
      commandArguments: [
        {
          type: "bool",
          name: "excludeOutgoingFC",
          description: "Exclude network and APS outgoing frame counter tokens.",
        },
        {
          type: "bool",
          name: "excludeBootCounter",
          description: "Exclude stack boot counter token.",
        },
      ],
      responseArguments: [
      ],
    },

  ],
}
# END Token Interface Frames
